% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[
  11pt,
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
  \setmonofont[Scale=0.7]{Source Code Pro}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Notes de cours de R - Version 2},
  pdfauthor={Ewen Gallic},
  colorlinks=true,
  linkcolor=Maroon,
  filecolor=Maroon,
  citecolor=Blue,
  urlcolor=Blue,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{etex} %vers l'infini et au-dela
%\reserveinserts{28} % (et plus loin encore)

\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc} % pour taper les lettres accentuees
\usepackage[english, french]{babel}
\usepackage{amsthm,amssymb,amsbsy,amsmath,amsfonts,amssymb,amscd,mathrsfs}
%Mise en page
\usepackage{geometry} %pour la modification des marges
\usepackage{fancyhdr} %pour modification des pieds de page
\usepackage{lastpage} %numero de la derniËre page
\usepackage{lscape} % Pour pouvoir activer le mode landscape
\usepackage{lmodern}
%Images, figures, etc.
\usepackage{booktabs} %tableaux
\usepackage{float}	%pour forcer le placement des images.
\usepackage{graphicx} %pour afficher des images
\usepackage{longtable} %tables sur plusieurs pages
\usepackage{animate} %transformer des gifs
\usepackage{caption}
%\usepackage{subcaption}
\captionsetup{labelformat=simple}
\usepackage[scriptsize]{subfigure}
\usepackage{multirow} 			%fusionner lignes
\usepackage{tikz}
\usepackage{adjustbox}
\usetikzlibrary{arrows,positioning}
\usetikzlibrary{mindmap,trees,shadows,backgrounds}
\usepackage{tabularx}
%Code
\usepackage{verbatim}%insertion de code
\usepackage{listings}
%Polices, format,couleurs
\usepackage{dsfont} % Pour les lettres mathematiques

\usepackage[nottoc]{tocbibind}

\usepackage{hyperref} %pour que les references soient des liens hypertextes
\usepackage{natbib}
\usepackage{bibentry}
%\usepackage{color}
\usepackage{xcolor,colortbl}
\definecolor{light-gray}{gray}{0.85}
\usepackage{ragged2e} % Pour justifier
%Symboles, theoremes
\newcommand{\iid}{\stackrel{\mathrm{iid}}{\sim}}
\newtheorem{theorem}{Theorem}[part]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{hypothese}{Hypoth\`ese}
\newtheorem{corollary}[theorem]{Corollary}
\usepackage{enumerate}%listes
\usepackage[subnum]{cases}% cas numerotes
%\newtheorem{laRemarque}{Remarque}[section]
 \newtheorem{rmarque}{Remarque}[section]
\newtheorem{exmp}{Exemple}[section]
\numberwithin{equation}{section}

\usepackage[official,right]{eurosym} % symbols euro
\usepackage{gensymb} % symbole degre \degre
\usepackage{rotating}
\usepackage{multicol}
\usepackage{empheq}
% Bibliographie
%\usepackage{bib entry}
%\nobibliography*
%\let\newblock\relax

%\usepackage[notocbib]{apacite}
%\usepackage[style=apa]{biblatex}
%\usepackage[round]{natbib}
%\usepackage[style=authoryear]{biblatex}
%\usepackage[backend=bibtex, style=authoryear-comp]{biblatex}
%\usepackage{biblatex}
\renewcommand*{\bibfont}{\scriptsize} % Pour avoir la biblio en plus petit
%\usepackage{apacite}
%\bibliographystyle{apacite}

%\titlegraphic{
%\centering
%\includegraphics[height=2em]{/Users/ewengallic/Dropbox/Universite_Aix_Marseille/Enseignements/template/assets/images/logo_amu_rvb_blanc.png}\hskip 3em
%%\colorbox{white}{\includegraphics[height=3em]{../../images/logo_feg.png}}
%\includegraphics[height=2em]{/Users/ewengallic/Dropbox/Universite_Aix_Marseille/Enseignements/template/assets/images/logo_feg_blanc.png}\hskip 3em
%%\colorbox{white}{\includegraphics[height=3em]{../../images/logo_amse.png}}
%\includegraphics[height=2em]{/Users/ewengallic/Dropbox/Universite_Aix_Marseille/Enseignements/template/assets/images/logo_amse.png}
%}

\justifying %on justifie le texte du document


% Pour les codes Python
\lstset{
language=Python,
basicstyle=\small\ttfamily,
commentstyle=\ttfamily\color{gray},
backgroundcolor=\color{white},
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=4,
captionpos=b,
breaklines=true,
breakatwhitespace=false,
title=\lstname,
escapeinside={},
keywordstyle={},
morekeywords={},
literate=%
         {á}{{\'a}}1
         {à}{{\`a}}1
         {^a}{{\^a}}1
         {í}{{\'i}}1
         {ï}{{\"\i}}1
         {é}{{\'e}}1
         {è}{{\`e}}1
         {ê}{{\^e}}1
         {ë}{{\"e}}1
         {ý}{{\'y}}1
         {ú}{{\'u}}1
         {ù}{{\`u}}1
         {ó}{{\'o}}1
         {ô}{{\^o}}1         
         {ě}{{\v{e}}}1
         {š}{{\v{s}}}1
         {č}{{\v{c}}}1
         {ř}{{\v{r}}}1
         {ž}{{\v{z}}}1
         {ď}{{\v{d}}}1
         {ť}{{\v{t}}}1
         {ň}{{\v{n}}}1                
         {ů}{{\r{u}}}1
         {Á}{{\'A}}1
         {Í}{{\'I}}1
         {É}{{\'E}}1
         {Ý}{{\'Y}}1
         {Ú}{{\'U}}1
         {Ó}{{\'O}}1
         {Ě}{{\v{E}}}1
         {É}{{\'E}}1
         {È}{{\`E}}1
         {Ê}{{\^E}}1
         {Š}{{\v{S}}}1
         {Č}{{\v{C}}}1
         {Ř}{{\v{R}}}1
         {Ž}{{\v{Z}}}1
         {Ď}{{\v{D}}}1
         {Ť}{{\v{T}}}1
         {Ň}{{\v{N}}}1                
         {Ů}{{\r{U}}}1 
}




%\graphicspath{{../images}}


\usepackage{array,dcolumn}
\newcolumntype{C}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}m{#1}}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}m{#1}}




\definecolor{vert}{RGB}{0,157,87}
\definecolor{Lime}{RGB}{191,255,0}
\definecolor{limegreen}{RGB}{50,205,50}
\definecolor{vertsombre}{RGB}{27,68,21}
\definecolor{vertclair}{HTML}{06D6A0}

%
\definecolor{Camel}{RGB}{193,154,107}
\definecolor{rouge}{HTML}{EF476F}
\definecolor{orange}{RGB}{199,118,34}
%
\definecolor{ProcessYellow}{RGB}{255, 239, 0}
\definecolor{jauneAMSE}{RGB}{240, 171, 0}
\definecolor{jaune}{HTML}{FFD166}


%
\definecolor{bleu}{HTML}{118AB2}
\definecolor{LBlue}{RGB}{173, 216, 230}
\definecolor{bleusombre}{RGB}{18, 37, 67}
\definecolor{bleufonce}{RGB}{91,112,170}
\definecolor{bleuAMSE}{RGB}{0,101,189}
%
\definecolor{DPurple}{RGB}{48,25,52}
\definecolor{Indigo}{RGB}{75, 0, 130}
\definecolor{Periwinkle}{RGB}{204, 204, 255}
\definecolor{ElectricViolet}{RGB}{143, 0, 255}
\definecolor{AfricanViolet}{RGB}{178, 132, 190}
\definecolor{ChineseViolet}{RGB}{133, 96, 136}
\definecolor{Grape}{RGB}{111, 45, 168}
\definecolor{RussianViolet}{RGB}{50, 23, 77}
\definecolor{EnglishViolet}{RGB}{86, 60, 92}
%

\definecolor{bottomcolour}{rgb}{0.32,0.3,0.38}
\definecolor{middlecolour}{rgb}{0.08,0.08,0.16}



%\hypersetup{
%    colorlinks = true,
%    linkcolor = ProcessYellow
%}




\newcommand*\grasO[1]{\textbf{\textcolor{Camel}{#1}}} 
\newcommand*\grasR[1]{\textbf{\textcolor{rouge}{#1}}}
\newcommand*\grasV[1]{\textbf{\textcolor{vertclair}{#1}}} 
\newcommand*\grasB[1]{\textbf{\textcolor{bleu}{#1}}} 
\newcommand*\grasJ[1]{\textbf{\textcolor{jaune}{#1}}} 
\newcommand*\grasP[1]{\textbf{\textcolor{AfricanViolet}{#1}}} 

\definecolor{rcp26}{RGB}{39, 55, 122}
\definecolor{rcp45}{RGB}{112, 159, 200}
\definecolor{rcp60}{RGB}{222, 99, 43}
\definecolor{rcp85}{RGB}{205, 16, 32}

\newcommand*\grasRCPa[1]{\textbf{\textcolor{rcp26}{#1}}}
\newcommand*\grasRCPb[1]{\textbf{\textcolor{rcp45}{#1}}} 
\newcommand*\grasRCPc[1]{\textbf{\textcolor{rcp60}{#1}}} 
\newcommand*\grasRCPd[1]{\textbf{\textcolor{rcp85}{#1}}}

\usepackage{tcolorbox}

\makeatletter
\let\@@magyar@captionfix\relax
\makeatother


\definecolor{deepblue}{RGB}{0,110,160}



\usepackage{xparse}
\NewDocumentCommand\afun{v}{%
\texttt{#1}\index[fonctions]{#1@\ifun{#1}}%
}
\NewDocumentCommand\afunDeux{v}{%
\index[fonctions]{#1@\ifun{#1}}%
}


\NewDocumentCommand{\ifun}{v}{\texttt{#1}}


 \newcounter{countremarque}


\newenvironment{remarque}{%
 \refstepcounter{countremarque}
    \begin{tcolorbox}[width=\linewidth, colback=blue!3, boxrule=0.5pt,arc=0pt,title = Remarque \thecountremarque]
    }%
    {
    \end{tcolorbox}
    }
\numberwithin{countremarque}{section}


\newcounter{exercices}[section]

\definecolor{shadecolorex}{HTML}{CFE3D1}
\makeatletter
\newenvironment{exframe}{%
 \def\at@end@of@exframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@exframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolorex}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@exframe}
\makeatother




\hypersetup{
bookmarks=true,
pdfauthor={Ewen Gallic},
unicode=false,
pdftoolbar=true,
pdfmenubar=true,
pdffitwindow=false
pdfnewwindow=true,
colorlinks=true,
linkcolor=bleuAMSE,
citecolor=bleuAMSE,
filecolor=bleuAMSE,
urlcolor=bleuAMSE,}
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newenvironment{cslreferences}%
  {\setlength{\parindent}{0pt}%
  \everypar{\setlength{\hangindent}{\cslhangindent}}\ignorespaces}%
  {\par}

\title{Notes de cours de R - Version 2}
\author{Ewen Gallic}
\date{Septembre 2020}

\begin{document}
\maketitle

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{3}
\tableofcontents
}
\listoftables
\listoffigures
\hypertarget{avant-propos}{%
\chapter*{Avant Propos}\label{avant-propos}}
\addcontentsline{toc}{chapter}{Avant Propos}

Ces notes de cours ont été réalisées dans le cadre d'un enseignement à R adressé à des étudiants en Économie. La première version remonte à 2014. Le contenu était proposé à des étudiant•e•s de Master à la Faculté de Sciences Economiques de l'Université de Rennes 1. En six ans, le langage R a beaucoupé évolué, notamment avec l'émergence d'une collection de packages à destination de la \emph{data science} : \href{https://www.tidyverse.org/}{\texttt{tidyverse}}. Les notes de cours de la première version se devaient être dépoussiérées pour présenter ce que j'appelle les nouveautés du langage. Cette refonte partielle de la première version s'effectue dans le cadre d'un enseignement à destination des étudiant•e•s de 3e année de Licence et Economie et Gestion à la \href{https://feg.univ-amu.fr/}{Faculté d'Economie et de Gestion} d'Aix-Marseille Université.

\hypertarget{objectifs}{%
\section{Objectifs}\label{objectifs}}

Cet ouvrage a pour but l'initiation au logiciel statistique et au langage informatique portant le même nom, R, afin d'être capable de s'en servir de manière efficace et autonome. Le lecteur ou la lectrice peut exécuter tous les exemples fournis (et est vivement encouragé•e à le faire). Les exercices viennent clore certains chapitres. Les corrections sont disponibles à l'adresse suivante : \url{http://egallic.fr/enseignement/}.

\hypertarget{uxe0-qui-sadressent-ces-notes}{%
\section{À qui s'adressent ces notes ?}\label{uxe0-qui-sadressent-ces-notes}}

Dans un premier temps, cet ouvrage s'adresse aux débutant•e•s qui souhaitent apprendre les bases du langage et du logiciel R. Le lecteur ou la lectrice initié•e peut également s'appuyer sur ces note afin de retrouver des rappels sur des notions basiques.

\hypertarget{remerciements}{%
\section{Remerciements}\label{remerciements}}

Ce manuel est le produit de plusieurs années de pratique, qui ont débutées en 2011 grâce à Christophe Cariou, que je tiens à remercier pour m'avoir soufflé l'idée d'utiliser R pour réaliser des projets amusants sur lesquels nous avons travaillés. Un énorme merci à Arthur Charpentier pour la quantité de savoir et d'astuces fournis sur l'utilisation de R, et qui est à l'origine de nombreux exemples présents dans ces notes de cours. Merci aussi à François Briatte de m'avoir introduit à de nouveaux horizons dans le langage, et aussi à Gauthier Vermandel pour ses nombreux conseils. Merci également à Julien-Yacine Chaqra pour ses suggestions et relectures. Je remercie également les étudiant•e•s qui au fil des années permettent de modifier le contenu de ce cours. Enfin, merci à toute la communauté R d'exister et de proposer ce partage de savoir librement et gratuitement.

\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

Ce document est construit principalement à l'aide des références suivantes :

\begin{itemize}
\tightlist
\item
  Grolemund and Wickham (\protect\hyperlink{ref-grolemund_2018_r}{2018}), Lafaye de Micheaux, Drouilhet, and Liquet (\protect\hyperlink{ref-Lafaye_2011_Logiciel}{2011}), Farnsworth (\protect\hyperlink{ref-Farnsworth_2008_Econometrics}{2008}), Charpentier (\protect\hyperlink{ref-Charpentier_2014_Computational}{2014}), Paradis (\protect\hyperlink{ref-Paradis_2002_R}{2002}), Zuur, Ieno, and Meesters (\protect\hyperlink{ref-Zuur_2009_Beginner}{2009}), Goulet (\protect\hyperlink{ref-Goulet_2014_Introduction}{2014})
\end{itemize}

\hypertarget{historique}{%
\section{Historique}\label{historique}}

Dans le milieu des années 1970, une équipe de chercheurs de AT\&T Bell Laboratories, composée de John Chambers, Douglas Bates, Rick Becker, Bill Cleveland, Trevor Hastie, Daryl Pregibon et Allan Wilks, développe un langage de programmation appelé \texttt{S} (la lettre \texttt{S} faisant référence à \emph{statistics}). Il s'agit d'un langage permettant de manipuler les données et d'effectuer des analyses statistiques et graphiques. Dans le milieu des années 1990, Ross Ihaka et Robert Gentleman créént le \texttt{R} au département de Statistiques de l'Université d'Auckland. Ce langage et logiciel, inspiré du \texttt{S} et de \texttt{Scheme} est distribué sous les termes de la GNU \emph{General Public Licence}. La \texttt{R} Development Core Team\} se charge de distribuer et de développer le logiciel \texttt{R}. De nombreux contributeurs à travers le monde participent au développement de \texttt{R}.

\hypertarget{pruxe9sentation-de-lespace-de-travail}{%
\section{Présentation de l'espace de travail}\label{pruxe9sentation-de-lespace-de-travail}}

\hypertarget{la-console-et-les-fenuxeatres-de-script}{%
\subsection{La console et les fenêtres de script}\label{la-console-et-les-fenuxeatres-de-script}}

\texttt{R} est un langage interprété, c'est-à-dire qu'il nécessite un interprète pour exécuter les commandes, et n'a pas de phase de compilation. Il existe plusieurs façons de travailler avec \texttt{R} : soit directement dans la console (qui est un interprète), soit dans une fenêtre de script (Fig\textasciitilde\ref{fig:intro-script}). La seconde méthode est fortement conseillée, puisqu'elle permet de sauvegarder le code et d'y accéder facilement pour une utilisation utlérieure. De plus, il existe souvent des raccourcis claviers, en fonction de l'éditeur utilisé, qui permettent de soumettre le code de la fenêtre de script à l'interprète. Les fichiers de code que l'on sauvegardent possèdent l'extension \texttt{.R}.

\begin{figure}[H]

{\centering \includegraphics[width=0.4\linewidth]{figs/fenetre_script} 

}

\caption{Fenêtre de script sous Mac OS Catalina}\label{fig:intro-script}
\end{figure}

\begin{figure}[H]

{\centering \includegraphics[width=0.4\linewidth]{figs/console_mac} 

}

\caption{Console sous Mac OS Catalina}\label{fig:intro-console}
\end{figure}

Dans la console (Fig\textasciitilde\ref{fig:intro-console}), à la fin de l'affichage d'ouverture de session R, se trouve le caractère \texttt{\textgreater{}} (\emph{prompt}), invitant l'utilisateur à inscrire une commande. Les expressions sont évaluées une fois qu'elle sont soumises (à l'aide de la touche \texttt{ENTREE}) et le résultat est donné, lorsqu'il n'y a pas d'erreur dans le code, juste en dessous :

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\OperatorTok{+}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

Par la suite, le symbole d'invite de commande ne sera plus affichée dans les cadres de code, afin de permettre au lecteur ou à la lectrice de reproduire facilement les résultats obtenus en copiant et collant les instructions. Par ailleurs, dans ce document, contrairement à ce que l'on peut observer dans la console \texttt{R}, le résultat de l'évalutation de l'expression \texttt{2+1} est précédé de deux croisillons. Le croisillon \texttt{\#} indique à \texttt{R} de ne pas evaluer le code qui suit, jusqu'à la fin de la ligne. Il permet donc de placer des lignes en commentaires.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Des commentaires}
\DecValTok{2}\OperatorTok{+}\DecValTok{1} \CommentTok{\# +1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

Lorsqu'on travaille dans une fenêtre de script, la combinaison de touches pour soumettre le code dépend du système d'exploitation et de l'éditeur de texte utilisé (\texttt{CTRL+R} sous Windows, \texttt{CMD+ENTER} sous Mac OS).

\hypertarget{les-variables}{%
\subsection{Les variables}\label{les-variables}}

\hypertarget{assignation}{%
\subsubsection{Assignation}\label{assignation}}

De base, le résultat d'une évaluation n'est pas enregistré, et est de fait perdu une fois affiché. Cependant, dans la plupart des cas, il est utile de conserver la sortie dans une variable. Il suffit alors d'attribuer un nom et un contenu à un objet. La flèche d'affectation \texttt{\textless{}-} permet cela. L'affichage du contenu de l'objet \texttt{x} se fait en inscrivant son nom et en l'évaluant.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\DecValTok{2}\OperatorTok{+}\DecValTok{1}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

\begin{remarque}
Il est possible d'afficher le contenu de l'objet en entourant l'expression de son affectation à une valeur par des parenthèses. La syntaxe est la suivante :

\texttt{(x\ \textless{}-\ 2+1)}
\end{remarque}

\begin{remarque}
Comme de nombreux langages de programmation utilisent le symbole \texttt{=} pour assigner une valeur à un objet, cette pratique est permise dans beaucoup de cas en \texttt{R}, mais il arrive qu'elle ne produise pas l'effet escompté dans d'autres cas de figures.
\end{remarque}

\hypertarget{introduction-espace-nommage}{%
\subsubsection{Conventions de nommage}\label{introduction-espace-nommage}}

Le nom d'une variable doit être composé de caractères alphanumériques ou du point ou du trait de soulignement uniquement. Il ne doit pas commencer par un chiffre ou contenir d'espace, sauf s'il est entouré par des guillemets. Il est important de noter que ces noms sont sensibles à la casse, c'est à dire qu'une distinction entre les majuscules et les minuscules a lieu. Il existe plusieurs pratiques pour nommer des variables, et il n'est pas rare de voir des combinaisons de ces pratiques. Un billet de Robin Lovelace explique les différences entre les méthodes et propose d'en adopter une seule Lovelace (\protect\hyperlink{ref-Lovelace_2014_Consistent}{2014}) :

\begin{itemize}
\tightlist
\item
  tout en minuscule : \texttt{nomvariable} ;
\item
  séparation par un point : \texttt{nom.variable} ;
\item
  séparation par un trait de soulignement : \texttt{nom\_variable} ;
\item
  lowerCamelCase, avec la première lettre en minuscule : \texttt{nomVariable} ;
\item
  PascalCase, avec la première lettre en majuscule : \texttt{NomVariable}.
\end{itemize}

Robin Lovelace propose d'avoir recours aux traits de soulignement, pour la facilité de lecture qu'ils permettent, et par leur emploi par quelques grands noms de la communauté \texttt{R} (comme Hadley Wickham\footnote{\url{http://had.co.nz/}} ou Yihui Xie\footnote{\url{http://yihui.name/}}).

\hypertarget{les-objets-en-muxe9moire}{%
\subsubsection{Les objets en mémoire}\label{les-objets-en-muxe9moire}}

Pour lister les éléments de la session \texttt{R} stockés en mémoire de l'ordinateur, il faut appeler la fonction \texttt{ls()} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ls}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "x"
\end{lstlisting}

\hypertarget{modidification-suppression}{%
\subsubsection{Modidification, suppression}\label{modidification-suppression}}

Il est important de noter que l'assignation du contenu d'un objet à un autre objet permet d'obtenir deux objets distincts. Ainsi, si un des deux objets est modifié, cela n'affecte pas l'autre.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{premier\_objet \textless{}{-}}\StringTok{ }\DecValTok{2}\OperatorTok{+}\DecValTok{1}
\NormalTok{second\_objet \textless{}{-}}\StringTok{ }\NormalTok{premier\_objet }\CommentTok{\# Assigne la valeur de premier\_objet}
\CommentTok{\# à second\_objet}
\NormalTok{premier\_objet \textless{}{-}}\StringTok{ }\DecValTok{2}\OperatorTok{+}\DecValTok{2} \CommentTok{\# Change la valeur de premier\_objet}
\CommentTok{\# Puis affiche le contenu des deux objets :}
\NormalTok{premier\_objet }\CommentTok{\# Le résultat doit être 4}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{second\_objet }\CommentTok{\# Le résultat doit être 3}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

Pour supprimer un objet, il faut utiliser la fonction \texttt{rm()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{premier\_objet }\CommentTok{\# L\textquotesingle{}objet existe}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rm}\NormalTok{(premier\_objet) }\CommentTok{\# Suppression}
\NormalTok{premier\_objet }\CommentTok{\# Son affichage provoque un message d\textquotesingle{}erreur}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in eval(expr, envir, enclos): objet 'premier_objet' introuvable
\end{lstlisting}

\hypertarget{les-packages}{%
\subsection{\texorpdfstring{Les \emph{packages}}{Les packages}}\label{les-packages}}

Les fonctions de base de \texttt{R} sont contenues dans un \emph{package} nommé \texttt{\{base\}} (lorsque qu"un nom de \emph{package} sera mentionné dans ces notes, il sera entouré d'accolades). Celui-ci est chargé automatiquement à l'ouverture de \texttt{R}, en même temps qu'une poignée d'autres. Les \emph{packages} sont des jeux de fonctions, accompagnés de fichiers d'aides, parfois de jeux de données, qui sont mis à disposition des utilisateurs. La liste des \emph{packages} chargés en mémoire par défaut s'obtient par l'instruction suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getOption}\NormalTok{(}\StringTok{"defaultPackages"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "datasets"  "utils"     "grDevices" "graphics"  "stats"     "methods"
\end{lstlisting}

Les fonctions qui ne sont pas dans les \emph{packages} en mémoire nécessitent d'être chargées. Mais avant de pouvoir le faire, encore faut-il que le \emph{package} soit installé. Si ce n'est pas le cas, il suffit de faire appel à l'instruction \emph{install.packages()}, puis de choisir, selon l'éditeur utilisé, un site miroir. Par exemple, pour installer le \emph{package} \{\texttt{ggplot2}\}, qui permet de réaliser des graphiques plus ou moins sophistiqués, l'instruction est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pour charger le \emph{package} en mémoire et ainsi avoir accès aux fonctions que celui-ci contient, l'instruction est \texttt{library()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

L'instruction \texttt{require()}, qui tente de charger le \emph{package} et retourne une valeur logique indiquant le succès ou l'échec de l'opération, est utilisée par certains, mais Yihui Xie indique sur un billet publié sur le site R-bloggers Xie (\protect\hyperlink{ref-Xie_r2014_require}{2014}) que lors d'un échec du chargement du \emph{package} en début de fichier, l'emploi des fonctions contenues dans ce \emph{package} échouera, tout simplement.

\begin{figure}[H]

{\centering \includegraphics[width=0.4\linewidth]{figs/require_vs_library} 

}

\caption{require() versus library().}\label{fig:intro-require}
\end{figure}

Certains \emph{packages} ne sont pas disponible sur CRAN (soit ils ne le seront jamais, soit il sont en cours de développement). Ils peuvent en revanche être mis à disposition sur GitHub. Pour installer un \emph{package} depuis GitHub, on peut faire appel à la fonction \texttt{install\_github()} du \emph{package} \{\texttt{devtools}\} (il faut au préalable avoir installé \{\texttt{devtool}\} depuis CRAN). Admettons que le \emph{package} \texttt{rJordan} à installer depuis GitHub est mis à disposition sur un répertoire de l'utilisateur \texttt{toto}, la syntaxe à respecter est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install.packages("devtools) \# Installer devtools si necessaire}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{install\_github}\NormalTok{(}\StringTok{"toto/rJordan"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{laide}{%
\subsection{L'aide}\label{laide}}

Pour conclure cette introduction, il semble important de mentionner la présence de l'aide en ligne. L'accès aux fichiers d'aide pour une fonction dont on connaît le nom, par exemple la fonction logarithme, peut se faire de plusieurs manières :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?log }\CommentTok{\# Première manière}
\KeywordTok{help}\NormalTok{(log) }\CommentTok{\# Seconde manière}
\KeywordTok{help}\NormalTok{(}\StringTok{"log"}\NormalTok{) }\CommentTok{\# Troisième manière}
\end{Highlighting}
\end{Shaded}

Pour trouver toutes les fonctions dont le nom contient une cha\^{}iine de cractètres donnée, on peut utiliser la fonction \texttt{apropos()} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apropos}\NormalTok{(}\StringTok{"log"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1] "annotation_logticks"   "as.data.frame.logical" "as.logical"           
##  [4] "as.logical.factor"     "col_logical"           "dlogis"               
##  [7] "GeomLogticks"          "is_bare_logical"       "is_logical"           
## [10] "is_scalar_logical"     "is.logical"            "log"                  
## [13] "log10"                 "log1p"                 "log2"                 
## [16] "logb"                  "Logic"                 "logical"              
## [19] "logLik"                "loglin"                "parse_logical"        
## [22] "plogis"                "qlogis"                "read_log"             
## [25] "rlogis"                "scale_x_log10"         "scale_y_log10"        
## [28] "SSlogis"               "tidyverse_logo"        "tokenizer_log"
\end{lstlisting}

Les fichiers sont souvent riches d'informations, très bien décrits, et proposent des exemples d'utilisation.

Par ailleurs, la communauté \texttt{R} est importante, et rares sont les questions sans réponses sur les \emph{mailing-lists} ou les pages de \href{http://stackoverflow.com/questions/tagged/r}{Stack Overflow}\}. Si vous n'arrivez pas à résoudre un problème après avoir parcouru StackOverflow, vous pouvez toujours y poser une question pour que la communauté tente de vous aider. Vous pouvez également rejoindre le groupe de discussion des utilisateurs de R francophones sur Slack : \href{https://r-grrr.slack.com/}{Grrr}. Dans les deux cas, pour permettre aux autres de vous aider : proposez un exemple reproductible. Pour ce faire, veuillez consulter par exemple ce \href{https://www.tidyverse.org/help/}{tutoriel}. N'hésitez pas à suivre les résolutions de problèmes des autres, cela favorise l'apprentissage de techniques efficaces et fais progresser la pratique du langage.

\hypertarget{un-environnement-de-duxe9veloppement-rstudio}{%
\section{Un environnement de développement : RStudio}\label{un-environnement-de-duxe9veloppement-rstudio}}

Bien qu'il soit possible d'utiliser \texttt{R} \emph{via} le terminal, ou \emph{via} l'éditeur installé par défaut, il est également possible d'utiliser un environnement de développement, comme RStudio. La version \emph{desktop}, gratuite et en \emph{open source}, est téléchargeable à l'adresse suivante : \url{https://www.rstudio.com/}.

Pour utiliser RStudio, il est nécessaire d'avoir au préalable installé R.

La figure ci-dessous montre l'interface graphique proposée par RStudio. Cette interface est composée de quatre panneaux : un éditeur, une console, une fenêtre historique et environnement, et une dernière avec divers onglets (fichiers, graphiques, \emph{packages}, aide et un navigateur interne).

\begin{figure}[H]

{\centering \includegraphics[width=1\linewidth]{figs/rstudio} 

}

\caption{Interface graphique de RStudio.}\label{fig:intro-rstudio}
\end{figure}

On peut noter que RStudio dispose d'un colorateur syntaxique et propose l'auto-complétion (à l'aide de la touche \texttt{TAB}).

\hypertarget{donnuxe9es}{%
\chapter{Données}\label{donnuxe9es}}

L'objectif de R étant d'analyser des données, il est tout aussi important de connaître les différents types qu'elles peuvent prendre que de savoir les manipuler. Ce chapitre présente dans un premier temps les objets en R, puis s'intéresse à l'importation et à l'exportation de données, et finit par la manièere de créer et de manipuler les différents types de données.

\hypertarget{types-de-donnuxe9es}{%
\section{Types de données}\label{types-de-donnuxe9es}}

R gère des objets, qui sont caractérisés par un \emph{nom}, un \emph{mode}, une \emph{longueur} et un \emph{contenu}.

\hypertarget{donnees-mode}{%
\subsection{Mode}\label{donnees-mode}}

Le mode d'un objet est la nature des éléments qui le composent, leur type. On y accède par la fonction \texttt{mode()} ou encore \texttt{typeof()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ }\DecValTok{2}
\KeywordTok{mode}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "numeric"
\end{lstlisting}

Il existe quatre principaux types :

\begin{itemize}
\item
  \emph{numeric} (numérique) :
  On distingue deux types numériques, à savoir les \emph{integers} (entiers) et les \emph{double} ou \emph{real} (réels).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ }\FloatTok{2.0}
\KeywordTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "double"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.integer}\NormalTok{(a) }\CommentTok{\# a est un réel, pas un entier.}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b \textless{}{-}}\StringTok{ }\DecValTok{2}
\KeywordTok{typeof}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "double"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c \textless{}{-}}\StringTok{ }\KeywordTok{as.integer}\NormalTok{(b)}
\KeywordTok{typeof}\NormalTok{(c)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "integer"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.numeric}\NormalTok{(c) }\CommentTok{\# c est bien un numérique.}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

  La variable \texttt{c} a la même valeur que la variable \texttt{b}, mais elle nécessite un stockage en mémoire moins important (Lafaye de Micheaux, Drouilhet, and Liquet \protect\hyperlink{ref-Lafaye_2011_Logiciel}{2011}). La fonction \texttt{is.integer()} retourne \texttt{TRUE} lorsque l'objet qui est fourni en argument est un entier, \texttt{FALSE} sinon. De manière plus générale, les instructions commençant par \texttt{as.} et suivies du nom d'un mode permettent de tester si l'objet indiqué en argument est de ce mode.
\item
  \emph{character} (caractère) :
  Les chaînes de caractères sont placées entre guillemets simples \texttt{\textquotesingle{}} ou doubles \texttt{"}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ "Hello world!"}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Hello world!"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "character"
\end{lstlisting}
\item
  \emph{logical} (logique, booléen) :
  Les données de type logique peuvent prendre deux valeurs : \texttt{TRUE} ou \texttt{FALSE}. Elles répondent à une condition logique.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ }\DecValTok{1}\NormalTok{ ; b \textless{}{-}}\StringTok{ }\DecValTok{2}
\NormalTok{a }\OperatorTok{\textless{}}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{==}\StringTok{ }\DecValTok{1} \CommentTok{\# Test d\textquotesingle{}égalité}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{!=}\StringTok{ }\DecValTok{1} \CommentTok{\# Test d\textquotesingle{}inégalité}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.character}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a \textless{}{-}}\StringTok{ }\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a \textless{}{-}}\StringTok{ }\NormalTok{T)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

  Comme le montre l'exemple ci-dessus, il est possible d'abréger \texttt{TRUE} en \texttt{T} ; il en est de même pour \texttt{FALSE}, qui peut s'abéger en \texttt{F}.
\end{itemize}

\begin{remarque}
Il peut parfois être pratique d'utiliser le fait que \texttt{TRUE} peut être automatiquement converti en 1 et \texttt{FALSE} en 0.
\texttt{TRUE\ +\ TRUE\ +\ FALSE\ +\ TRUE*TRUE} retournera 3.
\end{remarque}

\begin{itemize}
\item
  \emph{complex} (complexe) :
  Les nombres complexes sont caractérisés par leur partie réelle, que l'on peut obtenir à l'aide de la fonction \texttt{Re()} ; et par leur partie imaginaire, que l'on obtient grâce à la fonction \texttt{Im()}. On créé un nombre complexe à l'aide de la lettre \texttt{i}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{1i}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0+1i
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z \textless{}{-}}\StringTok{ }\DecValTok{2}\OperatorTok{+}\NormalTok{3i}
\KeywordTok{Re}\NormalTok{(z) }\CommentTok{\# Partie réelle de z}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Im}\NormalTok{(z) }\CommentTok{\# Partie imaginaire de z}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Mod}\NormalTok{(z) }\CommentTok{\# Module de z}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3.605551
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Arg}\NormalTok{(z) }\CommentTok{\# Argument de z}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0.9827937
\end{lstlisting}
\end{itemize}

\hypertarget{longueur}{%
\subsection{Longueur}\label{longueur}}

La longueur d'un objet correspond au nombre d'éléments qu'il contient. On utilise la fonction \texttt{length()} pour connaître la longueur d'un objet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ }\DecValTok{1}
\KeywordTok{length}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1
\end{lstlisting}

Les données manquantes \texttt{NA} (\emph{not available}) sont considérées comme étant de type \texttt{logical} par R.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "double"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.na}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\hypertarget{lobjet-vide}{%
\subsection{L'objet vide}\label{lobjet-vide}}

L'objet \texttt{NULL} représente le vide en R. Il est de mode \texttt{NULL} et de longueur 0. Il ne faut cependant pas le confondre avec un objet vide.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\OtherTok{NULL}
\KeywordTok{typeof}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "NULL"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.null}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.null}\NormalTok{(}\KeywordTok{list}\NormalTok{()) }\CommentTok{\# La liste vide n\textquotesingle{}est pas NULL}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\hypertarget{structures}{%
\section{Structure des données}\label{structures}}

Il existe de nombreuses structures servant à organiser les données dans R. Cette introduction à R n'a pas pour vocation de lister toutes celles qui existantent, aussi, seules quelques unes (les principales à mes yeux) sont présentées dans cette section. Pour connaître la structure d'un objet, il est possible d'utiliser la fonction \texttt{}class()`.

\hypertarget{structures-de-base}{%
\subsection{Structures de base}\label{structures-de-base}}

\hypertarget{vecteurs}{%
\subsubsection{Vecteurs}\label{vecteurs}}

Les vecteurs sont extrêmement employés en R, et sont composés de données de mêmes types. La création d'un vecteur peut se faire à l'aide de la fonction de concaténation \texttt{c()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3
\end{lstlisting}

\begin{remarque}
Dans l'affichage de la console, \texttt{{[}1{]}} indique le rang de l'élément qui le suit dans le vecteur dont le contenu est affiché. La Section~\ref{manip-acces}) permettra de mieux comprendre cet affichage.
\end{remarque}

Il est possible d'attribuer un nom aux éléments d'un vecteur, soit lors de la création, soit \emph{a posteriori}, en utilisant la fonction \texttt{names()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{nom =} \StringTok{"Piketty"}\NormalTok{, }\DataTypeTok{prenom =} \StringTok{"Thomas"}\NormalTok{, }\DataTypeTok{annee\_naissance =} \StringTok{"1971"}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##             nom          prenom annee_naissance 
##       "Piketty"        "Thomas"          "1971"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Piketty"}\NormalTok{, }\StringTok{"Thomas"}\NormalTok{, }\StringTok{"1971"}\NormalTok{)}
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Piketty" "Thomas"  "1971"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(b) \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"nom"}\NormalTok{, }\StringTok{"prenom"}\NormalTok{, }\StringTok{"annee\_naissance"}\NormalTok{)}
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##             nom          prenom annee_naissance 
##       "Piketty"        "Thomas"          "1971"
\end{lstlisting}

Lorsque plusieurs types de données sont mélangés lors de la création du vecteur, R convertit les données dans le type le plus général.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\StringTok{"deux"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "deux" "1"    "TRUE"
\end{lstlisting}

La fonction \texttt{is.vector()} retourne \texttt{TRUE} si l'objet passé en argument est un vecteur.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\KeywordTok{is.vector}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

La fonction \texttt{length()} donne le nombre d'éléments qui composent le vecteur.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\KeywordTok{length}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2
\end{lstlisting}

\hypertarget{facteurs}{%
\subsubsection{Facteurs}\label{facteurs}}

Les travaux d'économétrie requièrent souvent l'emploi de variables \emph{qualitatives}. R possède une structure qui gère ces variables : \texttt{factor}. On utilise la fonction \texttt{factor()} pour encoder un vecteur en facteur.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pays \textless{}{-}}\StringTok{ }\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"France"}\NormalTok{, }\StringTok{"France"}\NormalTok{, }\StringTok{"Chine"}\NormalTok{, }\StringTok{"Espagne"}\NormalTok{, }\StringTok{"Chine"}\NormalTok{))}
\NormalTok{pays}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] France  France  Chine   Espagne Chine  
## Levels: Chine Espagne France
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(pays)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "factor"
\end{lstlisting}

La fonction \texttt{levels()} retourne les niveaux du facteur.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{levels}\NormalTok{(pays)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Chine"   "Espagne" "France"
\end{lstlisting}

Lors des analyses, il arrive de vouloir choisir la modalité de réféfence plutôt que de laisser R le faire automatiquement. Il suffit alors d'utiliser la fonction \texttt{relevel()}. Il faut toutefois ne pas oublier de réassigner le résultat à l'objet !

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pays \textless{}{-}}\StringTok{ }\KeywordTok{relevel}\NormalTok{(pays, }\DataTypeTok{ref =} \StringTok{"Espagne"}\NormalTok{)}
\NormalTok{pays}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] France  France  Chine   Espagne Chine  
## Levels: Espagne Chine France
\end{lstlisting}

Si les variables catégorielles sont ordonnées, R propose la fonction \texttt{ordered()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{revenus \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{ordered}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\textless{}1500"}\NormalTok{, }\StringTok{"\textgreater{}2000"}\NormalTok{, }\StringTok{"\textgreater{}2000"}\NormalTok{, }\StringTok{"1500{-}2000"}\NormalTok{, }\StringTok{"\textgreater{}2000"}\NormalTok{, }\StringTok{"\textless{}1500"}\NormalTok{),}
          \DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"\textless{}1500"}\NormalTok{, }\StringTok{"1500{-}2000"}\NormalTok{, }\StringTok{"\textgreater{}2000"}\NormalTok{))}
\NormalTok{revenus}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] <1500     >2000     >2000     1500-2000 >2000     <1500    
## Levels: <1500 < 1500-2000 < >2000
\end{lstlisting}

\hypertarget{structure-dates}{%
\subsubsection{Dates}\label{structure-dates}}

On note trois principales classes pour représenter des dates en R :

\begin{itemize}
\tightlist
\item
  \emph{Date} : adapté pour les dates, uniquement celles pour lesquelles on ne possède pas d'informations à propos de l'heure (e.g., \texttt{1977-05-27});
\item
  \emph{POSIXct} et \emph{POSIXlt} : pour les dates avec des heures (e.g., \texttt{1977-05-27\ 20:00:00}).
\end{itemize}

\hypertarget{dates}{%
\paragraph{Dates}\label{dates}}

Les dates sont stoquées comme le nombre de jours depuis \texttt{1970-01-01}, avec des valeurs négatives pour des dates antérieures. Le format d'affichage est celui du calendrier grégorien.

La fonction \texttt{as.Date()} convertit une chaîne de caratcères en date. Si le format est de la forme \texttt{\%Y-\%m-\%d} ou \texttt{\%Y/\%m/\%d} (avec \texttt{\%Y} l'année avec le siècle, \texttt{\%m} le mois sur deux chiffres et \texttt{\%d} le jour sur deux chiffres), il n'est pas nécessaire de renseigner l'argument \texttt{format} de la fonction. L'argument \texttt{origin} permet quant à lui de préciser une origine différente de \texttt{1970-01-01}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(d \textless{}{-}}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"2020{-}10{-}21"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-21"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Date"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unclass}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 18556
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La date du jour}
\KeywordTok{as.Date}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-19"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec un format non standard}
\NormalTok{(d \textless{}{-}}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"2020 21 10"}\NormalTok{, }\DataTypeTok{format =}\NormalTok{ (}\StringTok{"\%Y \%d \%m"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-21"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(d \textless{}{-}}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"21 Octobre, 2020"}\NormalTok{, }\DataTypeTok{format =}\NormalTok{ (}\StringTok{"\%d \%B, \%Y"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-21"
\end{lstlisting}

La fonction \texttt{unclass()} utilisée dans le précédent exemple permet de voir la valeur stockée en interne.

Comme on peut le voir dans le précédent exemple, l'argument \texttt{format} a été utilisé. Cet argument permet de préciser comment la date est écrite dans la chaîne de caractères, pour que la conversion en objet de classe \texttt{date} soit possible. Cette conversion est réalisée, en interne, par la fonction\texttt{strptime()}. La page d'aide de cette fonction (\texttt{?strptime}) donne les différents codes qui spécifient les formats de date. Attention, certains de ces formats dépendent d'arguments locaux à la machine (des exemples sont donnés plus loin).

Les codes spécifiant les formats de date sont consignés dans le tableau suivant.

\begin{longtable}[]{@{}lll@{}}
\toprule
\begin{minipage}[b]{0.20\columnwidth}\raggedright
Code\strut
\end{minipage} & \begin{minipage}[b]{0.42\columnwidth}\raggedright
Description\strut
\end{minipage} & \begin{minipage}[b]{0.29\columnwidth}\raggedright
Exemple\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%a}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Abréviation du jour de la semaine (dépend du lieu)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Mer\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%A}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Jour de la semaine complet (dépend du lieu)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Mercredi\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%b}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Abréviation du mois (dépend du lieu)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
oct\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%B}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Nom du mois complet (dépend du lieu)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
octobre\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%c}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Date et heure (dépend du lieu) au format \texttt{\%a\ \%e\ \%b\ \%H:\%M:\%S\ \%Y}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Mer 21 oct 13:55:44 2020\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%C}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Siècle (00-99) -1 (partie entière de la division de l'année par 100)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
20\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%d}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Jour du mois (01--31)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
21\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%D}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Date au format \texttt{\%m/\%d/\%y}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
10/21/20\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%e}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Jour du mois en nombre décimal (1--31)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
21\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%F}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Date au format \texttt{\%Y-\%m-\%d}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
2020-10-21\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%h}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Même chose que \texttt{\%b}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
oct\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%H}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Heure (00--24)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
13\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%I}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Heure (01--12)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
01\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%j}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Jour de l'année (001--366)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
295\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%m}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Mois (01--12)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
10\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%M}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Minute (00-59)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
55\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%n}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Retour à la ligne en \emph{output}, caractère blanc en \emph{input}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%p}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
AM/PM\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
PM\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%r}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Heure au format 12 AM/PM\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
\texttt{format(d,\ "\%r")}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%R}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Même chose que \texttt{\%H:\%M}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
13:55\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%S}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Seconde (00-61)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
44\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%t}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Tabulation en \emph{output}, caractère blanc en \emph{input}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%T}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Même chose que \texttt{\%H:\%M:\%S}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
13:55:44\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%u}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Jour de la semaine (1--7), commence le lundi\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
3\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%U}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Semaine de l'anné (00--53), dimanche comme début de semaine, et le premier dimanche de l'année définit la semaine 1\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
42\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%V}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Semaine de l'année (00-53). Si la semaine (qui commence un lundi) qui contient le \(1^\textrm{er}\) janvier a quatre jours ou plus dans la nouvelle année, alors elle est considérée comme la semaine 1. Sinon, elle est considérée comme la dernière de l'année précédente, et la semaine suivante est considérée comme semaine 1 (norme ISO 8601)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
43\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%w}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Jour de la semaine (0--6), dimanche étant 0\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
3\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%W}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Semaine de l'année (00--53), le lundi étant le premier jour de la semaine, et typiquement, le premier lundi de l'année définit la semaine 1 (conviention G.B.)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
42\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%x}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Date (dépend du lieu)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
21.10.2020\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%X}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Heure (dépend du lieu)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
13:55:44\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%y}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Année sans le siècle (00--99)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
20\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%Y}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Année (en input, uniquement de 0 à 9999)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
2020\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%z}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
offset en heures et minutes par rapport au temps UTC\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
+0200\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.20\columnwidth}\raggedright
\texttt{\%Z}\strut
\end{minipage} & \begin{minipage}[t]{0.42\columnwidth}\raggedright
Abréviation du fuseau horraire (en output seulement)\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
CEST\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{dates-POSIXct}{%
\paragraph{POSIXct et POSIXlt}\label{dates-POSIXct}}

Si les dates à représenter contiennent des heures, il faut préférer le format \emph{POSIXct} ou \emph{POSIXlt}. Avec \emph{POSIXct}, les dates sont stockées en secondes depuis les débuts d'Unix (\texttt{1970-01-01\ 01:00:00}). Avec \emph{POSIXlt}, les dates sont stockées sous forme de liste dont les éléments correspondent à différentes composantes de la date (voir le tableau ci-dessous). Les fonctions \texttt{as.POSIXct()} et \texttt{as.POSIXlt()} permettent de convertir une chaîne de caractère représentant une date en objet \texttt{POSIXct} ou \texttt{POSIXlt}. à nouveau, la fonction \texttt{strptime()} est utilisée en interne pour réaliser la conversion des chaînes de caractères en dates.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# POSIXct}
\NormalTok{d \textless{}{-}}\StringTok{ }\KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"2015{-}10{-}21 13:55:44"}\NormalTok{)}
\KeywordTok{unclass}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1445428544
## attr(,"tzone")
## [1] ""
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unclass}\NormalTok{(}\KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"1970{-}01{-}01 01:00:00"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0
## attr(,"tzone")
## [1] ""
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# POSIXlt}
\NormalTok{d \textless{}{-}}\StringTok{ }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015{-}10{-}21 13:55:44"}\NormalTok{)}
\KeywordTok{unlist}\NormalTok{(}\KeywordTok{unclass}\NormalTok{(d))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    sec    min   hour   mday    mon   year   wday   yday  isdst   zone gmtoff 
##   "44"   "55"   "13"   "21"    "9"  "115"    "3"  "293"    "1" "CEST"     NA
\end{lstlisting}

Les éléments de la liste d'un objet de classe \texttt{POSIXlt} sont répertoriés dans le tableau suivant (voir page d'aide \texttt{?DateTimeClasses}).

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.19\columnwidth}\raggedright
Code\strut
\end{minipage} & \begin{minipage}[b]{0.75\columnwidth}\raggedright
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{sec}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
secondes (0--61)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{min}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
minutes (0--59)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{hour}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
heures (0--23)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{mday}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
jour du mois (1--31)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{mon}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
mois après le premier de l'année (0--11)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{year}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
années depuis 1900\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{wday}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
jour de la semaine (0--6), début de semaine le dimanche\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{yday}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
jour de l'année (0--365)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{isdst}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
indicateur d'heure d'été (positif si appliquable, zéro sinon ; néi inconnu)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{zone}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
Abréviation du fuseau horaire local (\texttt{""} si inconnu, ou UTC)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\texttt{gmtoff}\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
décalage en minutes par rapport au temps GMT (\texttt{NA} ou\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Le \emph{package} \{\texttt{lubridate}\} propose également des fonctions pour gérer les dates. Il est pratique de charger le \emph{package} en mémoire.

Pour convertir une chaîne de caractères représentant une date, il suffit d'utiliser une des trois fonctions suivantes : \texttt{ymd()}, \texttt{mdy()} et \texttt{dmy()}. Les trois lettres de ces fonctions font référence à l'année (\texttt{y} -- \emph{year}), le mois (\texttt{m} -- \emph{month}) et le jour (\texttt{d} -- \emph{day}). La position de ces lettres dans le nom de la fonction doit correspondre à celui des éléments correspondants dans la chaîne de caractères. Ainsi, \texttt{ymd()} s'attend à trouver d'abord l'année, puis le mois et enfin le jour dans la chaîne de caractères. Le gros avantage de ces fonctions est qu'il n'est pas nécessaire de préciser les séparateurs, une analyse est faite automatiquement pour le deviner.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(lubridate)}
\KeywordTok{ymd}\NormalTok{(}\StringTok{"2015{-}10{-}21"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2015-10-21"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mdy}\NormalTok{(}\StringTok{"10.21{-}15"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2015-10-21"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dmy}\NormalTok{(}\StringTok{"21 oct 2015"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2015-10-21"
\end{lstlisting}

Il est possible de préciser le fuseau horaire (à condition que le nom soit reconnu par le système d'exploitation), en renseignant l'argument \texttt{tz}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ymd}\NormalTok{(}\StringTok{"2015{-}10{-}21"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Pacific/Auckland"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2015-10-21 NZDT"
\end{lstlisting}

\begin{remarque}
La fonction \texttt{OlsonNames()} retourne un vecteur contenant tous les fuseaux horaires disponibles.
\end{remarque}

S'il y a des informations d'heures dans les chaînes de caractères repésentant les dates, il suffit d'ajouter \texttt{h} (heures), ou \texttt{hm} (heures et minutes) ou \texttt{hms} (heures, minutes et secondes) au nom de la fonction, en séparant par un trait de soulignement.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2015{-}10{-}21 10:00:50"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2015-10-21 10:00:50 UTC"
\end{lstlisting}

\hypertarget{structures-base-matrices}{%
\subsubsection{Matrices}\label{structures-base-matrices}}

Les matrices sont des vecteurs auxquels un attribut \texttt{dim} de dimension est ajouté. Une matrice est un vecteur pour lequel l'attribut \texttt{dim} est de longueur 2. La fonction \texttt{matrix()} permet de créer une matrice en R. Le code ci-après stoque dans \texttt{X} une matrice de 3 lignes (\texttt{nrow\ =\ 3}) et de 2 colonnes (\texttt{ncol\ =\ 2}). Cette matrice est remplie par colonnes successives par les éléments du vecteur \texttt{1:6}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{X}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
\end{lstlisting}

Pour que la matrice soit remplie par lignes successives plutôt que par colonne, il suffit d'ajouter l'argument \texttt{byrow} à la fonction \texttt{matrix()} et de lui donner la valeur \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Y \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{Y}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
\end{lstlisting}

Lorsque la dimension dépasse 2, on parle de tableau (\emph{array}). Par exemple, le code ci-après permet de créer un tableau de dimension \(2\times 4 \times 3\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Z \textless{}{-}}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{24}\NormalTok{, }\DataTypeTok{dim =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\NormalTok{Z}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## , , 1
## 
##      [,1] [,2] [,3] [,4]
## [1,]    1    3    5    7
## [2,]    2    4    6    8
## 
## , , 2
## 
##      [,1] [,2] [,3] [,4]
## [1,]    9   11   13   15
## [2,]   10   12   14   16
## 
## , , 3
## 
##      [,1] [,2] [,3] [,4]
## [1,]   17   19   21   23
## [2,]   18   20   22   24
\end{lstlisting}

Pour les matrices comme pour les tableaux, les données doivent toutes être du même type.

Les fonctions \texttt{nrow()} et \texttt{ncol()} donnent le nombre de lignes (\texttt{rows}) et de colonnes (\texttt{columns}) d'une matrice. La fonction \texttt{dim()} donne un vecteur contenant les dimensions de la matrice ou du tableau donné en argument.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{)}
\KeywordTok{dim}\NormalTok{(X)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nrow}\NormalTok{(X)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ncol}\NormalTok{(X)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2
\end{lstlisting}

\hypertarget{listes}{%
\subsubsection{Listes}\label{listes}}

Les listes dans R sont les structures les moins rigides. Elles peuvent contenir des éléments de modes différents, y compris des listes. Le mode des éléments de la liste n'est pas altéré, ce qui peut s'avérer utile dans certains cas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(personne \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\StringTok{"Piketty"}\NormalTok{, }\StringTok{"Thomas"}\NormalTok{, }\StringTok{"1971"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "Piketty"
## 
## [[2]]
## [1] "Thomas"
## 
## [[3]]
## [1] "1971"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(personne)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "list"
\end{lstlisting}

Comme pour les vecteurs, il est possible de nommer les éléments de la liste, ce qui permet une meilleure lecture et un accès aux données parfois plus pratique. La Section~@ref(donnees\_manipulation) apportera plus de détails à ce propos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\StringTok{"nom de famille"}\NormalTok{ =}\StringTok{ "Piketty"}\NormalTok{,}
                 \DataTypeTok{prenom =} \StringTok{"Thomas"}\NormalTok{,}
                 \DataTypeTok{annee =} \DecValTok{1971}\NormalTok{)}
\NormalTok{personne}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $`nom de famille`
## [1] "Piketty"
## 
## $prenom
## [1] "Thomas"
## 
## $annee
## [1] 1971
\end{lstlisting}

Pour aplatir une liste, R propose une fonction : \texttt{unlist()}. Cette fonction retourne un vecteur contenant tous les composants de la liste. Il faut toutefois garder à l'esprit que R se charge alors de convertir tous les éléments dans le mode le plus général. De fait, si cette fonction peut s'avérer pratique dans le cas de scalaires par exemple, elle peut également être destructrice lorsque mal employée.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unlist}\NormalTok{(personne)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## nom de famille         prenom          annee 
##      "Piketty"       "Thomas"         "1971"
\end{lstlisting}

\hypertarget{tableaux-de-donnuxe9es}{%
\subsection{Tableaux de données}\label{tableaux-de-donnuxe9es}}

\hypertarget{data-frames}{%
\subsubsection{Data Frames}\label{data-frames}}

Les tableaux de données sont au cœur de nombreuses procédures dans R notemment lorsqu'on estimes des modèles économétriques.

Traditionnellement, la structure adaptée aux données rectangulaires (variables en colonnes et observations en lignes) est ce que l'on appelle les \emph{data frames}. Du fait de l'évolution des besoins ces dernières années, les \emph{data frames}, bien qu'elles demeurent largement utilisées, tendent à être remplacées par les \emph{tibbles} (cf La Section~\ref{donnees-tibbles} pour découvrir cette structure similaire et comprendre pourquoi les \emph{tibbles} remplacent progressivement les \emph{data frames}).

Un \emph{data frame} est une liste composée d'un ou plusieurs vecteurs de même longueur. Le mode des vecteurs n'est pas nécessairement identique à celui des autres. Une manière simple de se représenter les tableaux de données est de penser à une matrice dans laquelle les lignes représentent des individus et les colonnes des caractéristiques propres à ces individus. La création d'un tableau de données se fait \emph{via} la fonction \emph{data.frame()}. La fonction \emph{as.data.frame()} permet quant à elle de convertir un objet d'un autre type en \emph{data frame}.

L'exemple ci-après utilise les données du \emph{dataset} \texttt{women}, présent dans le \emph{package} \{\texttt{datasets}\}. Il s'agit de la taille (en pouces) et du poids (en livres) moyen des femmes américaines âgées entre 30 et 39 ans.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{femmes \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{height =} \KeywordTok{c}\NormalTok{(}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{, }\DecValTok{63}\NormalTok{, }\DecValTok{64}\NormalTok{,}
                        \DecValTok{65}\NormalTok{, }\DecValTok{66}\NormalTok{, }\DecValTok{67}\NormalTok{, }\DecValTok{68}\NormalTok{, }\DecValTok{69}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{72}\NormalTok{),}
           \DataTypeTok{weight =} \KeywordTok{c}\NormalTok{(}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{, }\DecValTok{129}\NormalTok{,}\DecValTok{132}\NormalTok{, }
                      \DecValTok{135}\NormalTok{, }\DecValTok{139}\NormalTok{, }\DecValTok{142}\NormalTok{, }\DecValTok{146}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{154}\NormalTok{, }\DecValTok{159}\NormalTok{, }\DecValTok{164}\NormalTok{))}
\NormalTok{femmes}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height weight
## 1      58    115
## 2      59    117
## 3      60    120
## 4      61    123
## 5      62    126
## 6      63    129
## 7      64    132
## 8      65    135
## 9      66    139
## 10     67    142
## 11     68    146
## 12     69    150
## 13     70    154
## 14     71    159
## 15     72    164
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.data.frame}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "data.frame"
\end{lstlisting}

Comme pour les matrices, on peut obtenir les dimensions d'un \emph{data frame} avec la fonction \texttt{dim()}, le nombre de lignes avec \texttt{nrow()} et le nombre de colonnes avec \texttt{ncol()}.

\hypertarget{donees-tibbles}{%
\subsubsection{Tibbles}\label{donees-tibbles}}

Lorsque le volume des données devient conséquent, les \emph{data frames} deviennt désagréables à manipuler. Par exemple, lorque l'on tente d'appeler un \emph{data frame} dans la console, R tente d'aficher un maximum de lignes, puis finit par s'arrêter à la millième. Lorsque le nombre d'observation est important, il n'est pas rare que cet affichage provoque un très long temps d'attente. Une strucutre plus récente, les \emph{tibbles}, gère ce genre de soucis en affichant uniquement un extrait plus court. Les \emph{tibbles} (\emph{package} \{\texttt{tibble}\}) font partie de l'ensemble de \emph{packages} de l'environnement \emph{tidyverse}.

La création d'un \emph{tibble} est similaire à celle d'un \emph{data.frame}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tidyverse)}
\NormalTok{femmes\_tibble \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{height =} \KeywordTok{c}\NormalTok{(}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{, }\DecValTok{63}\NormalTok{, }\DecValTok{64}\NormalTok{, }\DecValTok{65}\NormalTok{,}
                                \DecValTok{66}\NormalTok{, }\DecValTok{67}\NormalTok{, }\DecValTok{68}\NormalTok{, }\DecValTok{69}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{72}\NormalTok{),}
                     \DataTypeTok{weight =} \KeywordTok{c}\NormalTok{(}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{, }\DecValTok{129}\NormalTok{, }\DecValTok{132}\NormalTok{,}
                                \DecValTok{135}\NormalTok{, }\DecValTok{139}\NormalTok{, }\DecValTok{142}\NormalTok{, }\DecValTok{146}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{154}\NormalTok{, }\DecValTok{159}\NormalTok{, }\DecValTok{164}\NormalTok{))}
\NormalTok{femmes\_tibble}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 15 x 2
##    height weight
##     <dbl>  <dbl>
##  1     58    115
##  2     59    117
##  3     60    120
##  4     61    123
##  5     62    126
##  6     63    129
##  7     64    132
##  8     65    135
##  9     66    139
## 10     67    142
## 11     68    146
## 12     69    150
## 13     70    154
## 14     71    159
## 15     72    164
\end{lstlisting}

Lorsqu'un \emph{tibble} est créé, le nom des colonnes n'est pas modifié s'il ne respecte pas les anciennes règles de nommage (à condition d'utiliser les accents graves pour définir le nom).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\StringTok{\textasciigrave{}}\DataTypeTok{1essai!}\StringTok{\textasciigrave{}}\NormalTok{ =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 1
##   `1essai!`
##       <dbl>
## 1         1
## 2         2
## 3         3
## 4         4
## 5         5
\end{lstlisting}

Les lignes ne sont pas nommées, elles sont simplement numérotées.

On peut noter que les vecteurs de longueur 1 seront recyclés, c'est-à-dire que la valeur sera répétée le nombre de lignes du tableau final.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{col\_deux =} \KeywordTok{c}\NormalTok{(}\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{),}
       \DataTypeTok{col\_trois =} \DecValTok{0}\NormalTok{,)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 2
##   col_deux col_trois
##      <dbl>     <dbl>
## 1        6         0
## 2        7         0
## 3        8         0
## 4        9         0
## 5       10         0
\end{lstlisting}

Il est intéressant de noter qu'il est possible de faire appel au nom d'une colonne qui vient d'être créée, lors de la création d'un \emph{tibble}, ce qui n'est pas réalisable avec un \emph{data frame}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}
  \StringTok{\textasciigrave{}}\DataTypeTok{1essai!}\StringTok{\textasciigrave{}}\NormalTok{ =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{),}
  \DataTypeTok{col\_deux =} \KeywordTok{c}\NormalTok{(}\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{),}
  \DataTypeTok{col\_trois =} \DecValTok{0}\NormalTok{,}
  \DataTypeTok{test =} \StringTok{\textasciigrave{}}\DataTypeTok{1essai!}\StringTok{\textasciigrave{}} \OperatorTok{+}\StringTok{ }\NormalTok{col\_deux)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 4
##   `1essai!` col_deux col_trois  test
##       <dbl>    <dbl>     <dbl> <dbl>
## 1         1        6         0     7
## 2         2        7         0     9
## 3         3        8         0    11
## 4         4        9         0    13
## 5         5       10         0    15
\end{lstlisting}

Un \emph{data frame} peut aisément être converti en \emph{tibble}, à l'aide de la fonction \texttt{as\_tibble()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{femmes\_tibble\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{as\_tibble}\NormalTok{(femmes)}
\NormalTok{femmes\_tibble\_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 15 x 2
##    height weight
##     <dbl>  <dbl>
##  1     58    115
##  2     59    117
##  3     60    120
##  4     61    123
##  5     62    126
##  6     63    129
##  7     64    132
##  8     65    135
##  9     66    139
## 10     67    142
## 11     68    146
## 12     69    150
## 13     70    154
## 14     71    159
## 15     72    164
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(femmes\_tibble\_}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "tbl_df"     "tbl"        "data.frame"
\end{lstlisting}

Pour comprendre pourquoi les \emph{tibbles} ont tendance à remplacer les \emph{data frames}, il est possible d'avancer les raisons suivantes (il en existe d'autres, mais à ce stade de la lecture de ces notes, cela ferait intervenir des concepts qui ne seront abordés que plus loin) :

\begin{itemize}
\tightlist
\item
  Lorsque l'on affiche un \emph{tibble} en évaluant son nom dans la console, R n'affichera que les 10 premières lignes et l'ensemble des colonnes qui peuvent s'afficher sur l'écran ;
\item
  Le mode des colonnes est décrit lors de l'affichage ;
\item
  Une coloration syntaxique est proposée pour visualiser plus facilement les contenus.
\end{itemize}

Si l'on désire afficher davantage de lignes d'un \emph{tibbles} dans la console que ce qui est proposé par défaut, il est possible de modifier les options de R, à l'aide de la fonction \texttt{options()}.

Si le \emph{tibble} est composé de plus de \texttt{n} lignes et que l'on souhaite afficher les \texttt{m} premières, il faut procéder comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{options}\NormalTok{(}\DataTypeTok{tibble.print\_max =}\NormalTok{ n, }\DataTypeTok{tibble.print\_min =}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

L'affichage restreint le nombre de colonnes dans la console. Pour en afficher davantage, il faut modifier l'argument \texttt{tibble.width}. Par exemple, pour retourner toutes les colonnes, il faut procéder comme suit (attention, le code suivant n'est pas adapté en présence de volumes de données avec un nombre de variables très important) :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{options}\NormalTok{(}\DataTypeTok{tibble.width =} \OtherTok{Inf}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{data-table}{%
\subsubsection{Data table}\label{data-table}}

Le \emph{package} \{\texttt{data.table}\} propose une structure de données appelée \emph{data.table}{[}\^{}La vignette d'introduction qui accompagne le \emph{package} est très bien faite : \url{https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html}.{]}, qui se veut être une alternative aux objets \emph{data frame} et \emph{tibbles}. Il faut toutefois noter qu'un objet de classe \emph{data.table} est également un \emph{data.frame}. L'idée derrière les \emph{data.table} est de réduire la longueur du code, de proposer une syntatxe plus facile à écrire et lire, mais aussi de réduire drastiquement les temps de calculs en présence de volumes de données massifs. La syntaxe se rapproche un peu du SQL, mais évite pas mal de lourdeurs de ce langage.

Pour utiliser les fonctions du \emph{packages}, il est pratique de charger ce dernier.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(data.table)}
\NormalTok{femmes \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{data.table}\NormalTok{(}\DataTypeTok{height =} \KeywordTok{c}\NormalTok{(}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{, }\DecValTok{63}\NormalTok{, }\DecValTok{64}\NormalTok{, }\DecValTok{65}\NormalTok{, }\DecValTok{66}\NormalTok{, }
                        \DecValTok{67}\NormalTok{, }\DecValTok{68}\NormalTok{, }\DecValTok{69}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{72}\NormalTok{),}
           \DataTypeTok{weight =} \KeywordTok{c}\NormalTok{(}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{, }\DecValTok{129}\NormalTok{, }\DecValTok{132}\NormalTok{, }\DecValTok{135}\NormalTok{, }
                      \DecValTok{139}\NormalTok{, }\DecValTok{142}\NormalTok{, }\DecValTok{146}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{154}\NormalTok{, }\DecValTok{159}\NormalTok{, }\DecValTok{164}\NormalTok{))}
\NormalTok{femmes}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##     height weight
##  1:     58    115
##  2:     59    117
##  3:     60    120
##  4:     61    123
##  5:     62    126
##  6:     63    129
##  7:     64    132
##  8:     65    135
##  9:     66    139
## 10:     67    142
## 11:     68    146
## 12:     69    150
## 13:     70    154
## 14:     71    159
## 15:     72    164
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.data.frame}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.data.table}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "data.table" "data.frame"
\end{lstlisting}

\hypertarget{importation-exportation-et-cruxe9ation-de-donnuxe9es}{%
\section{Importation, exportation et création de données}\label{importation-exportation-et-cruxe9ation-de-donnuxe9es}}

Pour pouvoir analyser des données, il faut pourvoir les charger en mémoire. Heureusement, il n'est pas nécessaire de les rentrer à la main, il existe des fonctions qui permettent de les importer, depuis divers formats. Il est également possible d'enregistrer les données dans plusieurs formats. Puisqu'il est souvent utile de créer des données à l'intérieur de la session (par exemple des années, des variables indicatrices, des noms de mois, etc.), cette section présente quelques fonctions utiles à la création de données.

Avant toute chose, il convient de préciser qu'un environnement de travail (\emph{working directory}) est assigné à R. Si R est lancé depuis un terminal, l'environnement de travail sera par défaut le répertoire courant à partir duquel la commande de lancement de R a été évaluée. C'est dans ce répertoire, dont on peut se rappeler le chemin grâce à l'instruction \texttt{getwd()} que R ira chercher les fichiers à importer et enregistrer les données lors de l'exportation. Si on souhaite lire des fichiers qui sont hors de ce répertoire, il est nécessaire d'indiquer à R leur chemin (relatif ou absolu). Pour changer de répertoire courant, il est possible d'utiliser la fonction \texttt{setwd()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "/Users/ewengallic/Documents"
\end{lstlisting}

\emph{Attention}, l'utilisation de la fonction \texttt{setwd()} est considérée comme une \emph{mauvaise pratique}. Deux exemples permettent de comprendre que l'utilisation de cette fonction peut s'avérer très pénible :

\begin{itemize}
\tightlist
\item
  lors d'un travail en collaboration, il est fort probable que la ou les personnes avec qui l'on travaille ne s'appellent pas comme nous ; de fait, le chemin indiquant le répertoire courant sera faux ;
\item
  lors de l'acquisition d'un nouvel ordinateur, il est fort possible que l'arborescence ne soit pas exactement la même ; à nouveau, le chemin indiquant le répertoire de travail ne sera plus le bon.
\end{itemize}

Quelle pratique adopter, dans ce cas ? La réponse est simple : travailler à l'aide de projets. RStudio propose cette alternative{[}\^{}Menu \texttt{File} \textgreater{} \texttt{New\ Project...}.{]}, et dans ce cas, le chemin vers le répertoire de travail est défini à l'extérieur, par RStudio. Il suffit alors d'utiliser des chemins relatifs lors de l'importation ou l'exportation de données, graphiques, etc., plutôt que des chemins absolus. Les deux problèmes mentionnés plus haut n'apparaitront pas.

\begin{remarque}
La fonction \texttt{list.files()} est très pratique : elle permet de lister tous les documents et répertoires contenus dans le répertoire de travail, ou dans n'importe quel répertoire si l'argument \texttt{path} renseigne le chemin.
\end{remarque}

\hypertarget{importation}{%
\subsection{Importation}\label{importation}}

Lorsque les données sont présentes dans un fichier texte (ASCII), R propose deux fonctions : \texttt{read.table()} et \texttt{scan()}. Pour les données stockées dans des fichiers aux formats différents, il est nécessaire de s'appuyer sur d'autres fonctions, non contenues dans le \texttt{package} \{\texttt{base}\}. C'est le cas pour les fichiers Excel, SAS\textasciitilde ou STATA.

\hypertarget{la-fonction-read.table}{%
\subsubsection{\texorpdfstring{La fonction \texttt{read.table}}{La fonction read.table}}\label{la-fonction-read.table}}

Cette fonction est très pratique lorsque les données sont déjà organisées dans un tableau dans le fichier à importer. Elle crée alors un \emph{data frame} contenant les données. Dans l'exemple fictif ci-dessous, les données du fichier \emph{fichier.txt} sont stockées dans le \emph{data frame} \texttt{df}. Les variables seront nommées par défaut \texttt{V1}, \texttt{V2},\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df \textless{}{-}}\StringTok{ }\KeywordTok{read.table}\NormalTok{(}\StringTok{"fichier.txt"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Il existe de nombreux arguments pour la fonction \texttt{read.table()}. Seuls les principaux seront abordés ici. Le lecteur ou la lectrice pourra consulter l'aide \texttt{?read.table()} pour obtenir de plus amples détails.

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.18\columnwidth}\raggedright
Argument\strut
\end{minipage} & \begin{minipage}[b]{0.76\columnwidth}\raggedright
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.18\columnwidth}\raggedright
\texttt{file}\strut
\end{minipage} & \begin{minipage}[t]{0.76\columnwidth}\raggedright
Le nom du fichier, doit être une chaîne de caractères. Il peut être précédé du chemin relatif ou absolu. Attention (utile pour les utilisateurs de Windows) le caractère \texttt{\textbackslash{}} est proscrit, et doit être remplacé par \texttt{/} ou bien \texttt{\textbackslash{}\textbackslash{}}. à noter qu'il est possible de saisir une adresse web (URL) en guise de chaîne de caractère.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
\texttt{header}\strut
\end{minipage} & \begin{minipage}[t]{0.76\columnwidth}\raggedright
Valeur logique (\texttt{header=FALSE} par défaut) indiquant si la première ligne contient les noms de variables.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
\texttt{sep}\strut
\end{minipage} & \begin{minipage}[t]{0.76\columnwidth}\raggedright
Le séparateur de champ dans le fichier (chaîne vide par défaut, ce qui est au final traduit par une espace comme séparation). Par exmple, \texttt{sep=";"} si les champs sont séparés par un point-virgule, ou encore \texttt{sep="\textbackslash{}textbackslash\ t"} s'ils sont séparés par une tabulation.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
\texttt{dec}\strut
\end{minipage} & \begin{minipage}[t]{0.76\columnwidth}\raggedright
Le caractère employé pour les décimales (par défaut, \texttt{dec="."}).\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
\texttt{row.names}\strut
\end{minipage} & \begin{minipage}[t]{0.76\columnwidth}\raggedright
Un vecteur contenant le nom des lignes (de type caractère), ou bien le numéro ou le nom d'une variable du fichier. En omettant cet argument, les lignes sont numérotées.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
\texttt{na.strings}\strut
\end{minipage} & \begin{minipage}[t]{0.76\columnwidth}\raggedright
Une chaîne de caractère (ou un vecteur de chaînes de caractères) indiquant la valeur des données manquantes (par défaut, \texttt{na.strings="NA"}). Ces données manquantes seront converties en \texttt{NA}.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright
\texttt{colClasses}\strut
\end{minipage} & \begin{minipage}[t]{0.76\columnwidth}\raggedright
Un vecteur de caractères indiquant les modes des colonnes.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{remarque}
Il est possible d'employer l'instruction \texttt{file.choose()} pour ouvrir une boîte de dialogue au lieu d'écrire le chemin complet vers le fichier de données. Bien que cette interface puisse paraître agréable à l'utilisateur novice, elle risque de vite devenir contraignante si le fichier R est amené à être exécuté plusieurs fois, puisqu'à chaque appel, la boîte de dialogue s'ouvrira.

\texttt{df\ \textless{}-\ read.table(file.choose())}
\end{remarque}

\begin{remarque}
Il existe des variantes de \texttt{read.table()} qui s'appuient sur cette fonction pour proposer à l'utilisateur des fonctions directement capables de lire leur fichier de données, sans avoir à changer les arguments \texttt{sep} et \texttt{decim}.

\begin{longtable}[]{@{}lcc@{}}
\toprule
Fonction & Séparateur de champs & Séparateur décimal\tabularnewline
\midrule
\endhead
\texttt{read.csv()} & ``\texttt{,}'' & ``\texttt{.}''\tabularnewline
\texttt{read.csv2()} & ``\texttt{;}'' & ``\texttt{,}''\tabularnewline
\texttt{read.delim()} & ``\texttt{\textbackslash{}t}'' & ``\texttt{.}''\tabularnewline
\texttt{read.delim2()} & ``\texttt{\textbackslash{}t}'' & ``\texttt{,}''\tabularnewline
\bottomrule
\end{longtable}
\end{remarque}

\begin{remarque}
Le \emph{package} \{\texttt{readr}\} propose des alternatives extrêmement rapides aux fonctions \texttt{read.table()} et dérivées. L'équivalent de \texttt{read.table()} est \texttt{read\_delim()}. Il suffit de lui préciser le séparateur de champ (\texttt{delim}), le séparateur des miliers étant automatiquement détecté. Attention, une ligne d'en-tête doit être présente dans le fichier de données.

\texttt{df\ \textless{}-\ read\_delim("data.csv",\ ";")}

\begin{longtable}[]{@{}lcc@{}}
\toprule
Fonction & Séparateur de champs & Séparateur décimal\tabularnewline
\midrule
\endhead
\texttt{read\_csv()} & ``\texttt{,}'' & ``\texttt{.}''\tabularnewline
\texttt{read\_csv2()} & ``\texttt{;}'' & ``\texttt{,}''\tabularnewline
\texttt{read\_delim()} & ``\texttt{\textbackslash{}t}'' & ``\texttt{.}''\tabularnewline
\texttt{read\_delim2()} & ``\texttt{\textbackslash{}t}'' & ``\texttt{,}''\tabularnewline
\bottomrule
\end{longtable}
\end{remarque}

\hypertarget{la-fonction-scan}{%
\subsubsection{\texorpdfstring{La fonction \texttt{scan}}{La fonction scan}}\label{la-fonction-scan}}

La fonction \texttt{scan()} est beaucoup plus souple que \texttt{read.table()}. Son emploi est requis dès que les données ne sont pas organisées comme un tableau. La nature des variables peut être spécifiée en renseignant l'argument \texttt{what}. On retrouve la plupart des arguments de la fonction \texttt{read.table()}. Le tableau ci-dessous présente les principaux; le lecteur ou la lectrice est invité•e à se reporter au fichier d'aide (\texttt{?scan}) pour obtenir de plus amples détails.

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.43\columnwidth}\raggedright
Argument\strut
\end{minipage} & \begin{minipage}[b]{0.51\columnwidth}\raggedright
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{file}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Nom de fichier ou chemin complet vers le fichier (peut être une URL)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{what}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Type des données lues\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{nmax}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Nombre de données maximum à lire\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{n}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Nombre de données à lire (pas de limite par défaut)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{sep}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Champ de séparation (caractère blanc par défaut)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{dec}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Caractère pour les décimales (``\texttt{.}'' par défaut)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{skio}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Nombre de lignes à omettre avant de débuter l'importation\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{na.strings}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Vecteur de chaînes de caractères indiquant les valeurs manquantes (\texttt{NA} par défaut)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{flush}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Si \texttt{TRUE}, commence l'importation de la ligne suivante après le dernier champs requis (permet d'avoir des commentaires après le dernier champ)\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{remarque}
Si dans l'appel de \texttt{scan()}, l'argument \texttt{file} est comme suit : \texttt{file=""}, l'utilisateur est invité à entrer les données au clavier. Pour clore la saisie, il suffit de terminer par une ligne blanche.
\end{remarque}

\hypertarget{la-fonction-read.fwf}{%
\subsubsection{\texorpdfstring{La fonction \emph{read.fwf}}{La fonction read.fwf}}\label{la-fonction-read.fwf}}

Parfois, les données que l'on récupère sont dans un format à largeur fixée (\emph{fixed width format}). C'est le cas par exemple pour les données météorologiques issues du site de la \emph{National Oceanic and Atmospheric Administration} (NOAA). R propose une fonction pour importer rapidement ce type de données : \emph{read.fwf()}. Un argument fait son apparition par rapport à la fonction \emph{read.table()}, il s'agit de \emph{widths}, qui permet d'indiquer la largeur de chaque champ.

Prenons un exemple. Si le fichier de données est nommé \texttt{data\_fwf.txt} et est présent dans le répertoire de travail, et qu'il contient les données suivantes :

\begin{quote}
FRANCEFR14.01
FRANCEFR23.02
FRANCEFR32.96
ITALIEIT15.90
ITALIEIT25.48
ITALIEIT34.32
\end{quote}

alors, l'importation de ces données dans R pourra se faire de la manière suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(df\_fwf \textless{}{-}}\StringTok{ }\KeywordTok{read.fwf}\NormalTok{(}\StringTok{"data\_fwf.txt"}\NormalTok{, }\DataTypeTok{widths =} \KeywordTok{c}\NormalTok{(}\DecValTok{6}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{remarque}
La fonction \texttt{read\_fwf()} du \emph{package} \{\texttt{readr}\} est une alternative à la fonction \texttt{read.fwf()}.
\end{remarque}

\hypertarget{importation-depuis-excel}{%
\subsubsection{Importation depuis Excel©}\label{importation-depuis-excel}}

Nous allons voir comment importer des données directement depuis un fichier à l'extension \texttt{.xls} ou \texttt{.xlsx}. Il existe plusieurs méthodes, qui sont bien expliquées dans les documents de référence de ce document. Nous allons uniquement aborder la manière à l'aide des fonctions \texttt{read.xls()} et \texttt{read\_excel()} contenues dans les \emph{packages} \{\texttt{gdata}\} et \{\texttt{readxl}\} respectivement. Par souci de reproductibilité, nous allons nous appuyer sur le fichier \texttt{iris.xls}, contenu dans le répertoire du \emph{package} \{\texttt{gdata}\}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"gdata"}\NormalTok{)}
\CommentTok{\# Récupérer le lien vers le fichier iris.xls}
\NormalTok{xlsfile \textless{}{-}}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{path.package}\NormalTok{(}\StringTok{\textquotesingle{}gdata\textquotesingle{}}\NormalTok{),}\StringTok{\textquotesingle{}xls\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}iris.xls\textquotesingle{}}\NormalTok{)}
\NormalTok{iris \textless{}{-}}\StringTok{ }\KeywordTok{read.xls}\NormalTok{(xlsfile) }\CommentTok{\# Créé un fichier csv temporaire}
\KeywordTok{head}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
\end{lstlisting}

Par défaut, la fonction \texttt{read.xls()} importe les données de la première feuille. L'argument \texttt{sheet} permet d'indiquer la feuille souhaitée, en la référençant soit par son numéro, soit par son nom.

\begin{remarque}
En pratique, si le fichier contient des formules, il est préférable d'utiliser la fonction `collage spécial' d'Excel pour coller les valeurs dans un nouveau fichier, ou bien d'enregistrer le fichier sous un format \texttt{.txt} dans Excel.
\end{remarque}

\begin{remarque}
Pour les utilisateurs sous Windows, il est peut-être nécessaire d'indiquer le chemin vers l'interprète perl (le fichier se nomme \texttt{perl.exe} )

\texttt{perl\ \textless{}-\ "C:\textbackslash{}\textbackslash{}Program\ Files\textbackslash{}\textbackslash{}FusionInventory-Agent\textbackslash{}\textbackslash{}perl\textbackslash{}\textbackslash{}bin\textbackslash{}\textbackslash{}perl.exe"}

\texttt{iris\ \textless{}-\ read.xls(xlsfile,\ perl\ =\ perl)\ \#\ Créé\ un\ fichier\ csv\ temporaire}
\end{remarque}

Avec \texttt{read\_xl()}, la procédure est identique :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"readxl"}\NormalTok{)}
\CommentTok{\# Récupérer le lien vers le fichier iris.xls}
\NormalTok{xlsfile \textless{}{-}}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{path.package}\NormalTok{(}\StringTok{\textquotesingle{}gdata\textquotesingle{}}\NormalTok{),}\StringTok{\textquotesingle{}xls\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}iris.xls\textquotesingle{}}\NormalTok{)}
\NormalTok{iris \textless{}{-}}\StringTok{ }\KeywordTok{read\_excel}\NormalTok{(xlsfile)}
\end{Highlighting}
\end{Shaded}

\hypertarget{importation-depuis-dautres-formats}{%
\subsubsection{Importation depuis d'autres formats}\label{importation-depuis-dautres-formats}}

Le \emph{package} \{\texttt{foreign}\}, installé de base sous Windows, mais non chargé automatiquement en mémoire, permet de lire des données stockées dans de nombreux formats (par exemple DBF, STATA, SPSS, etc.). Pour les fichiers \texttt{sas7bdat}, produits par SAS©, on peut utiliser la fonction \texttt{read.sas7bdat()} du \emph{package} \{\texttt{sas7bdat}\}.

\hypertarget{exportation}{%
\subsection{Exportation}\label{exportation}}

Pour enregistrer des données depuis un \emph{tibble}, un \emph{data frame}, un vecteur ou une matrice, la fonction \texttt{write.table()} peut être utilisée. Par exemple, si le \emph{tibble} se nomme \texttt{donnees}, l'instruction ressemble à :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write.table}\NormalTok{(donnees, }\DataTypeTok{file =} \StringTok{"nom\_fichier.txt"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{";"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Il existe d'autres arguments, que le lecteur ou la lectrice pourra consulter dans l'aide de la fonction \texttt{write.table()}.

\begin{remarque}
La fonction \texttt{write\_csv()} du \emph{package} \{\texttt{readr}\} est une alternative à la fonction \texttt{write.csv()}.
\end{remarque}

La fonction \texttt{save()} permet elle aussi de sauvegarder des données en dehors de la session R, et cette fois, n'importe quelle classe d'objet peut être sauvegardée. Par exemple, si l'utilisateur souhaite sauvegarder les objets \texttt{d1}, \texttt{d2} et \texttt{d3}, il lui suffit de rentrer l'instruction suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{save}\NormalTok{(d1, d2, d3, }\DataTypeTok{file =} \StringTok{"nom\_fichier.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pour charger les fichiers d'extention \texttt{.RData}, il faut utiliser la fonction \texttt{load()} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{load}\NormalTok{(}\StringTok{"nom\_fichier.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{remarque}
Pour sauvegarder tous les éléments de la session R, la fonction \texttt{save.image()} peut être appelée, ce qui revient au même que d'évaluer l'instruction \texttt{save(list\ =\ ls(all=TRUE),\ file=".RData")}.
\end{remarque}

\hypertarget{guxe9nuxe9ration}{%
\subsection{Génération}\label{guxe9nuxe9ration}}

\hypertarget{suxe9quences-ruxe9guliuxe8res}{%
\subsubsection{Séquences régulières}\label{suxe9quences-ruxe9guliuxe8res}}

La fonction de concaténation, abordée précédemment est un moyen simple de créer un vecteur de données.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3
\end{lstlisting}

La fonction \texttt{seq()} est extrêmement utile. Elle crée un vecteur de séquences de nombres. Le premier argument définit la valeur du début de séquence, tandis que le second argument définit la valeur finale. L'argument \texttt{by} définit l'incrément, et vaut 1 par défaut. L'argument \texttt{length.out} permet quant à lui de définir la longueur souhaitée de la séquence, et définit donc automatiquement la valeur de l'incrément. Il faut noter que \texttt{by} et \texttt{length.out} ne peuvent évidemment pas être utilisés en même temps.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a \textless{}{-}}\StringTok{ }\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2 3 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{, }\DataTypeTok{by =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1.0 1.5 2.0 2.5 3.0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1] 1.000000 1.222222 1.444444 1.666667 1.888889 2.111111 2.333333 2.555556
##  [9] 2.777778 3.000000
\end{lstlisting}

La fonction \texttt{:()} génère une séquence de données espacées d'une unité. Attention, cette fonction, que l'on peut voir comme un opérateur, est prioritaire sur les opérations arithmétiques.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1.5}\OperatorTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5
\end{lstlisting}

Comme mentionné en Section~\ref{donnees-mode}, le stockage des données de mode \emph{integer} prend moins de place que celles de type \emph{numeric}. Avec les fonctions \texttt{seq()} ou \texttt{:()}, les données sont de type \texttt{integer}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "numeric"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(}\KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "integer"
\end{lstlisting}

Pour créer une séquence de valeurs avec duplication du premier argument, on peut utiliser la fonction \texttt{rep()}. En jouant avec les arguments, on peut créer des réplications différentes. Voici quelques exemples.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{) }\CommentTok{\# Répète trois fois la valeur 1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 1 1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{) }\CommentTok{\# Répète trois fois la séquence 1:2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 1 2 1 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DataTypeTok{each =} \DecValTok{3}\NormalTok{) }\CommentTok{\# Répète chaque élément de la séquence 1:2 trois fois}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 1 1 2 2 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Répète deux fois la séquence dans laquelle}
\CommentTok{\# les éléments de la séquence 1:2 sont répétés trois fois}
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DataTypeTok{each =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1] 1 1 1 2 2 2 1 1 1 2 2 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Répète la séquence 1:2 jusqu\textquotesingle{}à ce que}
\CommentTok{\# la longueur du résultat soit égale à 3 (le résultat peut être tronqué)}
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 1
\end{lstlisting}

La fonction \texttt{seq\_len()} crée une suite de nombres entiers allant de 1 au nombre passé à l'unique argument \texttt{length.out}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq\_len}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3 4
\end{lstlisting}

La fonction \texttt{sequence()} génère une suite de nombres. Pour chaque élément passé à l'argument \texttt{nvec}, une séquence de nombre allant de 1 à cet élément, est créée. Les séquences d'entiers ainsi créées sont concaténées.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sequence}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 1 2 3 1 2 3 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sequence}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3 1 2 3 4 5
\end{lstlisting}

La fonction \texttt{gl()} permet de créer des séries de facteurs. Elle requière deux arguments : \texttt{n}, pour indiquer le nombre de niveaux souhaité, et \texttt{k} pour indiquer le nombre de réplications voulu. Il est possible de définir les étiquettes pour chacun des niveaux, en renseignant l'argument \texttt{labels} ou encore de préciser si les niveaux des facteurs doivent être ordonnés, avec l'argument logique \texttt{ordered}. L'argument \texttt{length} permet quant à lui de définir la longueur souhaitée du résultat.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gl}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 1 1 1 2 2 2 2
## Levels: 1 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gl}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DataTypeTok{length =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1] 1 1 1 1 2 2 2 2 1 1
## Levels: 1 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gl}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DataTypeTok{labels =} \KeywordTok{c}\NormalTok{(}\StringTok{"Oui"}\NormalTok{, }\StringTok{"Non"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] Oui Oui Oui Oui Non Non Non Non
## Levels: Oui Non
\end{lstlisting}

Enfin, \texttt{expand.grid()} est une fonction très utile pour générer toutes les combinaisons possibles des vecteurs donnés en arguments.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expand.grid}\NormalTok{(}\DataTypeTok{age =} \KeywordTok{seq}\NormalTok{(}\DecValTok{18}\NormalTok{, }\DecValTok{20}\NormalTok{), }\DataTypeTok{genre =} \KeywordTok{c}\NormalTok{(}\StringTok{"Femme"}\NormalTok{, }\StringTok{"Homme"}\NormalTok{), }\DataTypeTok{fumeur =} \KeywordTok{c}\NormalTok{(}\StringTok{"Oui"}\NormalTok{, }\StringTok{"Non"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    age genre fumeur
## 1   18 Femme    Oui
## 2   19 Femme    Oui
## 3   20 Femme    Oui
## 4   18 Homme    Oui
## 5   19 Homme    Oui
## 6   20 Homme    Oui
## 7   18 Femme    Non
## 8   19 Femme    Non
## 9   20 Femme    Non
## 10  18 Homme    Non
## 11  19 Homme    Non
## 12  20 Homme    Non
\end{lstlisting}

\hypertarget{suxe9quences-pseudo-aluxe9atoires}{%
\subsubsection{Séquences pseudo-aléatoires}\label{suxe9quences-pseudo-aluxe9atoires}}

R propose des fonctions pour de nombreuses distributions de probabilité. Pour chaque distribution de probabilité, il y a en général quatre fonctions, dont le nom commence par une des quatre lettres suivantes : \texttt{r} (\emph{random}), \texttt{d} (\emph{density}), \texttt{p} (\emph{probability}) et \texttt{q} (\emph{quantile}). Les fonctions commençant par la lettre \texttt{r} permettent de générer des données issues d'une loi de probabilité donnée ; celles commençant par la lettre \texttt{d} correspondent aux densités de probabilité (ou fonctions de masse dans le cas d'une variable aléatoire discrète) ; celles dont la première lettre est un \texttt{p} donnent la densité de probabilité cumulée (fonctions de répartition) ; et enfin celles commençant par la lettre \texttt{q} donnent les valeur de quantiles (fonctions quantiles).

Prenons un exemple avec la loi \(\mathcal{N}(0,1)\) :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rnorm}\NormalTok{(}\DataTypeTok{n =} \DecValTok{1}\NormalTok{, }\DataTypeTok{mean =} \DecValTok{0}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -1.406723
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dnorm}\NormalTok{(}\DecValTok{1}\NormalTok{) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2}\OperatorTok{*}\NormalTok{pi) }\OperatorTok{*}\StringTok{ }\KeywordTok{exp}\NormalTok{(}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{/}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pnorm}\NormalTok{(}\FloatTok{1.96}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0.9750021
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{qnorm}\NormalTok{(}\FloatTok{0.025}\NormalTok{) ; }\KeywordTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -1.959964
\end{lstlisting}

\begin{lstlisting}
## [1] 1.959964
\end{lstlisting}

R propose des fonctions pour les lois de probabilité discrètes suivantes (liste non exhaustive) :

\begin{itemize}
\tightlist
\item
  Binomiale : \texttt{rbinom(n,\ size,\ prob)} ;
\item
  Poisson : \texttt{rpois(n,\ lambda)} ;
\item
  Géométrique : \texttt{rgeom(n,\ prob)} ;
\item
  Hyper-géométrique : \texttt{rhyper(nn,\ m,\ n,\ k)} ;
\item
  Binomiale négative : \texttt{rnbinom(n,\ size,\ prob,\ mu)}.
\end{itemize}

R propose des fonctions pour les lois de probabilité continues suivantes (liste non exhaustive) :

\begin{itemize}
\tightlist
\item
  Normale : \texttt{rnorm(n,\ mean\ =\ 0,\ sd\ =\ 1)}
\item
  Student : \texttt{rt(n,\ df,\ ncp)}
\item
  Khi-deux : \texttt{rchisq(n,\ df,\ ncp\ =\ 0)}
\item
  Fisher : \texttt{rf(n,\ df1,\ df2,\ ncp)}
\item
  Exponentielle : \texttt{rexp(n,\ rate\ =\ 1)}
\item
  Uniforme : \texttt{runif(n,\ min\ =\ 0,\ max\ =\ 1)}
\item
  Beta : \texttt{rbeta(n,\ shape1,\ shape2,\ ncp\ =\ 0)}
\item
  Logistique : \texttt{rlogis(n,\ location\ =\ 0,\ scale\ =\ 1)}
\item
  Log-Normale : \texttt{rlnorm(n,\ meanlog\ =\ 0,\ sdlog\ =\ 1)}
\item
  Gamma : \texttt{rgamma(n,\ shape,\ rate\ =\ 1,\ scale\ =\ 1/rate)}
\item
  Weibull : \texttt{rweibull(n,\ shape,\ scale\ =\ 1)}
\end{itemize}

\hypertarget{manipulation-des-donnuxe9es}{%
\section{Manipulation des données}\label{manipulation-des-donnuxe9es}}

Dans la Section~\ref{structures}, nous avons vu comment créer différents objets en R. Cette section présente d'abord les opérateurs, puis les façons d'accéder aux données en fonction du type d'objet, les calculs sur les listes et vecteurs, et enfin les calculs matriciels.

\hypertarget{opuxe9rateurs}{%
\subsection{Opérateurs}\label{opuxe9rateurs}}

Il existe trois sortes d'opérateurs en R, à savoir arithmétiques, de comparaison et logiques.

\hypertarget{opuxe9rateurs-arithmuxe9tiques}{%
\subsubsection{Opérateurs arithmétiques}\label{opuxe9rateurs-arithmuxe9tiques}}

Les opérateurs arithmétiques agissent sur des vecteurs ou des matrices. Ils opèrent sur des objets de type numérique, complèxe ou logique. En voici la liste :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{y \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y  }\CommentTok{\# Addition}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  3  7  5 12  6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{{-}}\StringTok{ }\NormalTok{y  }\CommentTok{\# Soustraction}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -1 -3  1 -4  4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{*}\StringTok{ }\NormalTok{y   }\CommentTok{\# Multiplication}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  2 10  6 32  5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{/}\StringTok{ }\NormalTok{y   }\CommentTok{\# Division}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0.5 0.4 1.5 0.5 5.0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{\^{}}\NormalTok{y  }\CommentTok{\# Puissance}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]     1    32     9 65536     5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{\%\%}\StringTok{ }\NormalTok{y  }\CommentTok{\# Modulo}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 1 4 0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{\%/\%}\StringTok{ }\NormalTok{y }\CommentTok{\# Division entière}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0 0 1 0 5
\end{lstlisting}

\hypertarget{opuxe9rateurs-de-comparaison}{%
\subsubsection{Opérateurs de comparaison}\label{opuxe9rateurs-de-comparaison}}

Les opérateurs de comparaison agissent sur des vecteurs, des matrices, des tableaux de données et des listes. Le type de données n'est pas restreint comme pour les opérateurs arithmétiques.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{seq\_len}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\NormalTok{x }\OperatorTok{\textless{}}\StringTok{ }\DecValTok{2}  \CommentTok{\# Inférieur à}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE FALSE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{\textless{}=}\StringTok{ }\DecValTok{2}  \CommentTok{\# Inférieur ou égal à}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE FALSE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{\textgreater{}}\StringTok{ }\DecValTok{2}   \CommentTok{\# Supérieur à}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE  TRUE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{\textgreater{}=}\StringTok{ }\DecValTok{2}  \CommentTok{\# Supérieur ou égal à}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{==}\StringTok{ }\DecValTok{2}  \CommentTok{\# Égal à}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE FALSE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{!=}\StringTok{ }\DecValTok{2}  \CommentTok{\# Différent de}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE  TRUE  TRUE  TRUE
\end{lstlisting}

Attention, il faut être prudent avec la fonction d'égalité. En effet, un exemple simple (voir Paradis (\protect\hyperlink{ref-Paradis_2002_R}{2002})) montre que deux objets qui nous semblent identiques ne le sont pas aux yeux de la machine, à cause des approximations effectuées lors des calculs. Il convient alors dans certains cas d'utiliser la fonction \texttt{all.equal()} plutôt que l'opérateur logique \texttt{==} ou la fonction \texttt{identical()}.

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0.9} \OperatorTok{==}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{{-}}\StringTok{ }\FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{all.equal}\NormalTok{(}\FloatTok{0.9}\NormalTok{, }\DecValTok{1}\FloatTok{{-}0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(}\FloatTok{0.9}\NormalTok{, }\DecValTok{1} \OperatorTok{{-}}\StringTok{ }\FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0.9} \OperatorTok{==}\StringTok{ }\NormalTok{(}\FloatTok{1.1} \OperatorTok{{-}}\StringTok{ }\FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{all.equal}\NormalTok{(}\FloatTok{0.9}\NormalTok{, }\FloatTok{1.1{-}0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(}\FloatTok{0.9}\NormalTok{, }\FloatTok{1.1{-}0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

En fait, la fonction \texttt{all.equal()} donne une égalité approximative, à l'aide d'un seuil de tolérance !

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{all.equal}\NormalTok{(}\FloatTok{0.9}\NormalTok{, }\FloatTok{1.1{-}0.2}\NormalTok{, }\DataTypeTok{tolerance =} \FloatTok{1e{-}16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Mean relative difference: 1.233581e-16"
\end{lstlisting}

\hypertarget{opuxe9rateurs-logiques}{%
\subsubsection{Opérateurs logiques}\label{opuxe9rateurs-logiques}}

Les opérateurs logiques opèrent sur un ou deux objets de type logique. Les opérateurs \texttt{ET} et \texttt{OU} existent en R sous deux formes : la forme simple (\texttt{\&} et \texttt{\textbar{}}) et la forme double (\texttt{\&\&} et \texttt{\textbar{}\textbar{}}). La forme simple opère sur chaque élément des objets, et retourne le résultat de l'opération pour chaque élément. La forme double, quant à elle, opère uniquement sur le premier élément des objets.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\NormalTok{y \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\OperatorTok{!}\NormalTok{x  }\CommentTok{\# \textquotesingle{}Non\textquotesingle{} logique}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{\&}\NormalTok{y }\CommentTok{\# \textquotesingle{}Et\textquotesingle{} logique}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{\&\&}\NormalTok{y    }\CommentTok{\# \textquotesingle{}Et\textquotesingle{} logique (revient à faire x[1] \& y[1])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{|}\NormalTok{y }\CommentTok{\# \textquotesingle{}Ou\textquotesingle{} logique}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{||}\NormalTok{y    }\CommentTok{\# \textquotesingle{}Ou\textquotesingle{} logique (revient à faire x[1] | y[1])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{xor}\NormalTok{(x, y)   }\CommentTok{\# \textquotesingle{}Ou\textquotesingle{} exlusif}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE FALSE
\end{lstlisting}

Il existe deux fonctions importantes pour les vecteurs de type \texttt{logical} : \texttt{any()} et \texttt{all()} qui indiquent respectivement, si au moins un des éléments du vecteur vaut \texttt{TRUE} et si tous les éléments du vecteur valent \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\KeywordTok{any}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\KeywordTok{any}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{all}\NormalTok{(}\OperatorTok{!}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\hypertarget{attention-au-recyclage}{%
\subsubsection{Attention au recyclage}\label{attention-au-recyclage}}

Jusqu'ici, les exemples fournis au sujet des opérateurs ne concernaient que des objets de même longueur. Dans le cas des \emph{vecteurs}, si un des deux objets concernés par l'opération est de taille inférieure à celle de l'autre, R effectue un recyclage, c'est à dire qu'il va compléter le vecteur le plus court à l'aide des valeurs de ce même vecteur, afin d'obtenir deux objets de même taille. On peut voir que R affiche un message d'avertissement lors d'une telle opération.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{y \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2 4 6 5 7 9 8
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# R a ajouté le vecteur c(1, 2, 3, 1, 2, 3, 1) à y}
\end{Highlighting}
\end{Shaded}

\hypertarget{manip-acces}{%
\subsection{Accès aux valeurs, modifications}\label{manip-acces}}

Pour accéder aux éléments d'un objet, R propose plusieurs méthodes, qui peuvent varier selon le type d'objet.

\hypertarget{accuxe8s-par-indices}{%
\subsubsection{Accès par indices}\label{accuxe8s-par-indices}}

Un moyen simple d'accéder aux éléments d'un objet est d'utiliser le système d'indexation. Cette indexation peut être de type numérique ou logique. Dans le cas d'un vecteur, on extrait une composante en utilisant la fonction \texttt{"{[}"()}, dont les arguments en dehors du vecteur pour lequel on souhaite réaliser une extraction peuvent être un vecteur d'indices d'éléments à extraire ou ne pas extraire, un vecteur d'éléments de type logique indiquant si l'élément doit être extrait ou non.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\StringTok{"["}\NormalTok{(x, }\DecValTok{2}\NormalTok{)  }\CommentTok{\# Extraire le second élément de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 7
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{2}\NormalTok{]    }\CommentTok{\# Une écriture plus commode pour extraire le second élément de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 7
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\OperatorTok{{-}}\DecValTok{2}\NormalTok{]   }\CommentTok{\# Tous les éléments de x sauf le second}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4 3 5 0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{3}\OperatorTok{:}\DecValTok{4}\NormalTok{]  }\CommentTok{\# Les troisième et quatrième éléments de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3 5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i \textless{}{-}}\StringTok{ }\DecValTok{3}\OperatorTok{:}\DecValTok{4}
\NormalTok{x[i] }\CommentTok{\# On peut utiliser une variable contenant un vecteur d\textquotesingle{}indices}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3 5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(F, T, F, F, F)] }\CommentTok{\# Le second élément de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 7
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[x}\OperatorTok{\textless{}}\DecValTok{1}\NormalTok{]  }\CommentTok{\# Les éléments de x inférieurs à 1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{\textless{}}\DecValTok{1} \CommentTok{\# Il s\textquotesingle{}agit bien d\textquotesingle{}un vecteur de logiques}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE FALSE FALSE  TRUE
\end{lstlisting}

La fonction \texttt{which()} retourne les positions des éléments d'un vecteur logique pour lesquels la valeur vaut \texttt{TRUE}. Les fonctions \texttt{which.min()} et \texttt{which.max()} retournent respectivement la position du (premier) minimum et du premier maximum d'un vecteur numérique ou logique.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\KeywordTok{which}\NormalTok{(x }\OperatorTok{\textless{}}\StringTok{ }\DecValTok{7} \OperatorTok{\&}\StringTok{ }\NormalTok{x }\OperatorTok{\textgreater{}}\StringTok{ }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2 3 6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which.min}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which.max}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{which.max}\NormalTok{(x)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 7
\end{lstlisting}

Le remplacement d'un élément s'effectue simplement en utilisant la flèche d'assignation. On peut modifir plusieurs éléments à la fois.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{seq\_len}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\NormalTok{x[}\DecValTok{2}\NormalTok{] \textless{}{-}}\StringTok{ }\DecValTok{3}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 3 3 4 5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{2}\NormalTok{] \textless{}{-}}\StringTok{ }\NormalTok{x[}\DecValTok{3}\NormalTok{] \textless{}{-}}\StringTok{ }\DecValTok{0}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 0 0 4 5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{which}\NormalTok{(x }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)] \textless{}{-}}\StringTok{ }\DecValTok{10}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  1 10 10  4  5
\end{lstlisting}

Pour les \emph{matrices} ou les \emph{tableaux de données}, l'extraction par indice se fait dans le même esprit, mais il faut indiquer un vecteur d'indices (\texttt{i}) pour les lignes et un pour les colonnes (\texttt{j}), de la manière suivante : \texttt{x{[}i,\ j{]}}, avec \texttt{x} la matrice ou le tableau de donnée. En omettant le vecteur d'indices pour les lignes ou les colonnes, R retourne toutes les lignes ou les colonnes respectivement. Enfin, en ajoutant le symbole ``moins'' (\texttt{-}) devant le vecteur d'indices de lignes ou de colonnes, on demande à R de ne pas retourner les éléments dont les indices sont mentionnés.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]  }\CommentTok{\# Élément de la ligne 1 et de la colonne 2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{) ; j \textless{}{-}}\StringTok{ }\DecValTok{3}
\NormalTok{x[i,j]  }\CommentTok{\# Éléments des lignes 1 et 3 de la troisième colonne}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 7 9
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[, }\DecValTok{2}\NormalTok{]  }\CommentTok{\# Éléments de la seconde colonne}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4 5 6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{1}\NormalTok{ ,]  }\CommentTok{\# Éléments de la première ligne}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 4 7
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[, }\OperatorTok{{-}}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]    }\CommentTok{\# x sans les colonnes 1 et 3}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4 5 6
\end{lstlisting}

Avec le dernier exemple, on voit que R retourne un vecteur et non une matrice. Si on souhaite obtenir une matrice à une seule colonne, il suffit d'ajouter l'argument \texttt{drop} auquel on donne la valeur \texttt{FALSE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[, }\OperatorTok{{-}}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{), drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1]
## [1,]    4
## [2,]    5
## [3,]    6
\end{lstlisting}

Pour modifier une valeur, c'est à nouveau avec la flèche d'assignation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{x[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{] \textless{}{-}}\StringTok{ }\DecValTok{0}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    1    0    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{lstlisting}

On peut noter qu'en utilisant \texttt{which()} sur une matrice, on peut demander à R de retourner les indices sous forme de couples :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which}\NormalTok{(x }\OperatorTok{\textgreater{}}\StringTok{ }\DecValTok{5}\NormalTok{, }\DataTypeTok{arr.ind =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      row col
## [1,]   3   2
## [2,]   1   3
## [3,]   2   3
## [4,]   3   3
\end{lstlisting}

Il est également possible d'utiliser des vecteurs logiques.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x\_logique \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{), }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       [,1]  [,2]  [,3]
## [1,]  TRUE FALSE  TRUE
## [2,] FALSE  TRUE FALSE
## [3,]  TRUE FALSE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[x\_logique]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 3 5 7 9
\end{lstlisting}

Comme indiqué dans la Section~\ref{structures-base-matrices}, les matrices et les tableaux sont des vecteurs, qui correspondent à un empilement des vecteurs colonnes. Ainsi, on peut extraire les éléments de la matrice à l'aide d'un vecteur d'indices ou de valeurs logiques.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{7}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 3 7
\end{lstlisting}

Pour les \emph{tableaux de dimension supérieure à 2}, il suffit juste d'ajouter un argument par dimension supplémentaire. Voici un exemple avec un tableau de dimension 3 :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z \textless{}{-}}\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{24}\NormalTok{, }\DataTypeTok{dim =}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\NormalTok{z[}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{]  }\CommentTok{\# Élément de la ligne 2, colonne 4 de la dimension 3}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 24
\end{lstlisting}

Enfin, pour les \emph{listes}, l'emploi de la fonction \texttt{"{[}"()} retourne une liste, puisque les listes sont constituées de listes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\StringTok{"Piketty"}\NormalTok{, }\StringTok{"Thomas"}\NormalTok{, }\StringTok{"1971"}\NormalTok{)}
\NormalTok{personne[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "Piketty"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(personne[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "list"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "Piketty"
## 
## [[2]]
## [1] "1971"
\end{lstlisting}

Pour obtenir le contenu d'un ou plusieurs éléments de la liste, on fait donc appel à une autre fonction : \texttt{"{[}{[}"()}. Comme pour la fonction avec les crochets simples, on peut l'employer d'une manière plus commode en l'accolant au nom de la liste contenant les éléments que l'on souhaite extraire.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"[["}\NormalTok{(personne, }\DecValTok{1}\NormalTok{)  }\CommentTok{\# Premier élément de la liste}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Piketty"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne[[}\DecValTok{1}\NormalTok{]]   }\CommentTok{\# idem}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Piketty"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne[[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{]] }\CommentTok{\# Ne fonctionne pas}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in personne[[1, 2]]: nombre d'indices incorrect
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne[[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)]]  }\CommentTok{\# Ne fonctionne pas non plus ici}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in personne[[c(1, 2)]]: indice hors limites
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{] }\CommentTok{\# Ne fonctionne pas}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in personne[1, 2]: nombre de dimensions incorrect
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)]    }\CommentTok{\# Retourne une liste de dim 2 contenant :}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "Piketty"
## 
## [[2]]
## [1] "Thomas"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# {-} le premier élément de la liste}
    \CommentTok{\# {-} le second élément de la liste}
\end{Highlighting}
\end{Shaded}

Grâce à la propriété d'indexation récursive, il est possible d'accéder aux éléments des objets de la liste. Par exemple, si le troisième élément de la liste \texttt{l} est un vecteur, et que l'on souhaite récupérer son premier élément, on peut écrire procéder de deux manières :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(l \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\StringTok{"foo\_1"}\NormalTok{, }\StringTok{"foo\_2"}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"foo\_3"}\NormalTok{, }\StringTok{"foo\_4"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "foo_1"
## 
## [[2]]
## [1] "foo_2"
## 
## [[3]]
## [1] "foo_3" "foo_4"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l[[}\DecValTok{3}\NormalTok{]]  }\CommentTok{\# Troisième élément de la liste}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "foo_3" "foo_4"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l[[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{)]] }\CommentTok{\# Premier élément du troisième élément}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "foo_3"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l[[}\DecValTok{3}\NormalTok{]][}\DecValTok{1}\NormalTok{]   }\CommentTok{\# Premier élément du troisième élément}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "foo_3"
\end{lstlisting}

Pour modifier l'élément d'une liste ou son contenu, on utilise encore la flèche d'assignation. Attention, ceci peut être destructif. En effet, si on indique à R que l'on souhaite modifier le contenu d'un élément, en utilisant la fonction \texttt{"{[}{[}"()}, le résultat sera le même qu'en utilisant la fonction \texttt{"{[}"()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\StringTok{"foo"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{), }\StringTok{"foo\_2"}\NormalTok{))}
\NormalTok{l[[}\DecValTok{4}\NormalTok{]] \textless{}{-}}\StringTok{ }\DecValTok{2}
\NormalTok{l  }\CommentTok{\# La liste en position 4 a été remplacée par un vecteur de longueur 1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] TRUE
## 
## [[3]]
## [1] "foo"
## 
## [[4]]
## [1] 2
\end{lstlisting}

\hypertarget{accuxe8s-par-noms}{%
\subsubsection{Accès par noms}\label{accuxe8s-par-noms}}

Comme précisé dans la Section~\ref{structures}, les éléments d'un \emph{vecteur} peuvent posséder un nom. Il est alors possible d'accéder à un élément par son nom.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{nom =} \StringTok{"Piketty"}\NormalTok{, }\DataTypeTok{prenom =} \StringTok{"Thomas"}\NormalTok{, }\StringTok{"annee de naissance"}\NormalTok{ =}\StringTok{ "1971"}\NormalTok{)}
\NormalTok{personne[}\StringTok{"nom"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       nom 
## "Piketty"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(personne)  }\CommentTok{\# Accès aux noms des éléments du vecteur}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "nom"                "prenom"             "annee de naissance"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(personne) \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"nom"}\NormalTok{, }\StringTok{"prenom"}\NormalTok{, }\StringTok{"naissance"}\NormalTok{)  }\CommentTok{\# Modification des noms}
\NormalTok{personne}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       nom    prenom naissance 
## "Piketty"  "Thomas"    "1971"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(personne) \textless{}{-}}\StringTok{ }\OtherTok{NULL} \CommentTok{\# Suppression des noms}
\NormalTok{personne}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Piketty" "Thomas"  "1971"
\end{lstlisting}

Si l'objet est une \emph{liste} ou un \emph{tableau de données}, on peut aussi utiliser le symbole dollar (\texttt{\$}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne\_liste \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{list}\NormalTok{(}\StringTok{\textquotesingle{}nom de famille\textquotesingle{}}\NormalTok{ =}\StringTok{ "Piketty"}\NormalTok{, }\DataTypeTok{prenom =} \StringTok{"Thomas"}\NormalTok{, }\DataTypeTok{annee =} \DecValTok{1971}\NormalTok{)}
\NormalTok{personne\_liste[[}\StringTok{"nom de famille"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Piketty"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personne\_liste}\OperatorTok{$}\StringTok{"nom de famille"}  \CommentTok{\# Le nom contenant au moins une espace,}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Piketty"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# Il est nécessaire d\textquotesingle{}employer des guillemets}
\NormalTok{personne\_liste}\OperatorTok{$}\NormalTok{prenom}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Thomas"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(personne\_liste)  }\CommentTok{\# Accès aux noms des éléments de la liste}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "nom de famille" "prenom"         "annee"
\end{lstlisting}

Dans le cas des \emph{matrices} et des \emph{tableaux de données}, il est possible de donner un nom aux lignes (pas avec les \emph{tibbles}) et aux colonnes, avec les fonctions \texttt{rownames()} et \texttt{colnames()} respectivement. La fonction \texttt{dimnames()} retourne une liste dont le premier élément est une liste contenant le vecteur des noms de lignes, et le second élément une liste contenant le vecteur des noms de colonnes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{femmes \textless{}{-}}
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{height =}\KeywordTok{c}\NormalTok{(}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{, }\DecValTok{63}\NormalTok{, }\DecValTok{64}\NormalTok{, }\DecValTok{65}\NormalTok{, }\DecValTok{66}\NormalTok{,}
                   \DecValTok{67}\NormalTok{, }\DecValTok{68}\NormalTok{,}\DecValTok{69}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{72}\NormalTok{),}
         \DataTypeTok{weight =}\KeywordTok{c}\NormalTok{(}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{, }\DecValTok{129}\NormalTok{, }\DecValTok{132}\NormalTok{, }
                   \DecValTok{135}\NormalTok{, }\DecValTok{139}\NormalTok{,}\DecValTok{142}\NormalTok{, }\DecValTok{146}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{154}\NormalTok{, }\DecValTok{159}\NormalTok{, }\DecValTok{164}\NormalTok{))}
\KeywordTok{colnames}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "height" "weight"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rownames}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dimnames}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15"
## 
## [[2]]
## [1] "height" "weight"
\end{lstlisting}

\begin{remarque}
Lorsqu'on extrait des éléments d'un objet à l'aide des noms, les attributs de l'objet d'origine ne sont pas altérés.
\end{remarque}

Pour remplacer des valeurs, on utilise encore la flèche d'assignation. R produit un message d'erreur si l'élément de remplacement n'est pas de la bonne longueur pour le \emph{tibble} ou le \emph{data frame}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{seq\_len}\NormalTok{(}\DecValTok{3}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{rep}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{), }\DataTypeTok{z =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\NormalTok{tb}\OperatorTok{$}\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{tb}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 3
##   x         y     z
##   <lgl> <dbl> <dbl>
## 1 NA        2     1
## 2 NA        2     4
## 3 NA        2     3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb}\OperatorTok{$}\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error: Assigned data `rep(1, 4)` must be compatible with existing data.
## x Existing data has 3 rows.
## x Assigned data has 4 rows.
## i Only vectors of size 1 are recycled.
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb  }\CommentTok{\# La modification n\textquotesingle{}a pas été faite}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 3
##   x         y     z
##   <lgl> <dbl> <dbl>
## 1 NA        2     1
## 2 NA        2     4
## 3 NA        2     3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Attention}
\KeywordTok{is.list}\NormalTok{(tb}\OperatorTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb}\OperatorTok{$}\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\NormalTok{tb}\OperatorTok{$}\NormalTok{x    }\CommentTok{\# La colonne "x" a changé de structure !}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] 4
## 
## [[2]]
## [1] 3
## 
## [[3]]
## [1] 2
\end{lstlisting}

\hypertarget{chauxeenes-de-caractuxe8res}{%
\subsection{Chaînes de caractères}\label{chauxeenes-de-caractuxe8res}}

Savoir manipuler les chaînes de caractères permet de gagner énormément de temps dans le traitement de données texte, mais permet également de produire des sorties, graphiques ou non, plus lisibles et compréhensibles que les affichages par défaut proposés par R. Le lecteur ou la lectrice intéressé•e par la manipulation avancée des chaînes de caractères en R est invité à consulter l'\emph{ebook} de Gaston Sanchez (Sanchez \protect\hyperlink{ref-Sanchez_2013_Handling}{2013}).

\hypertarget{concatuxe9nation}{%
\subsubsection{Concaténation}\label{concatuxe9nation}}

La fonction \texttt{cat()} concatène et affiche à l'écran des objets. Les arguments qui sont fournis sont convertis en vecteurs de chaînes de caractères, qui sont ensuite concaténés en un seul vecteur de caractères. Les éléments de ce vecteur sont ensuite joints entre eux, et éventuellement séparés par un caractère différent de l'espace, si l'argument \texttt{sep} est modifié.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"World"}\NormalTok{, }\StringTok{"!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello World !
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En ajoutant un passage à la ligne entre chaque élément}
\KeywordTok{cat}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"World"}\NormalTok{, }\StringTok{"!"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello
## World
## !
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1 2 3 4 5 6
\end{lstlisting}

\begin{remarque}
Le caractère \texttt{\textbackslash{}} (barre oblique inversée, ou \emph{backslash}) est le caractère d'échappement en R. Il permet d'afficher certains caractères, comme les guillemets dans une chaîne elle-même définie à l'aide de guillemets, ou bien les caractères de contrôle, comme la tabulation, le saut de ligne, etc. Le fichier d'aide \texttt{?Quotes} de R fournir de plus amples détails. Le tableau ci-dessous fournit quelques exemple courants.

\begin{longtable}[]{@{}llll@{}}
\toprule
Caractère & Description & Caractère & Description\tabularnewline
\midrule
\endhead
\texttt{\textbackslash{}n} & Nouvelle ligne & \texttt{\textbackslash{}r} & Retour à la ligne\tabularnewline
\texttt{\textbackslash{}t} & Tabulation & \texttt{\textbackslash{}b} & Retour arrière\tabularnewline
\texttt{\textbackslash{}\textbackslash{}} & Barre olbique inversée & \texttt{\textbackslash{}\textquotesingle{}} & Apostrophe\tabularnewline
\texttt{\textbackslash{}"} & Apostrophe double & \texttt{\textbackslash{}‘} & Accent grave\tabularnewline
\bottomrule
\end{longtable}
\end{remarque}

La fonction \texttt{str\_c()} du \emph{package} \{\texttt{stringr}\} convertit en chaîne de caractères les éléments passés en argument puis les concatène. Il est tout à fait possible de stocker le résultat dans un objet, dans la mesure où le résultat de l'évaluation de \texttt{str\_c()}, contrairement à celui de l'évaluation de \texttt{cat()} est une chaîne de caractères. L'argument \texttt{sep} permet de définir la chaîne de caractères séparant les termes (rien par défaut).

Il est nécessaire de charger le \emph{package} avant d'appeler les fonctions qu'il contient (et de l'installer lors de la première utilisation).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(stringr)}
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{str\_c}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"World"}\NormalTok{, }\StringTok{"!"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{" "}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Hello World !"
\end{lstlisting}

La fonction \texttt{str\_c()} dispose aussi de l'argument \texttt{collapse}, qui est utile pour joindre les éléments d'un vecteur dans une même chaîne de caractères.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_c}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Bouches{-}du{-}Rhône"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Marseille"        "Bouches-du-Rhône"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Il n\textquotesingle{}y a qu\textquotesingle{}un argument, donc le séparateur est inutile !}
\KeywordTok{str\_c}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Bouches{-}du{-}Rhône"}\NormalTok{), }\DataTypeTok{sep =} \StringTok{", "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Marseille"        "Bouches-du-Rhône"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En ajoutant l\textquotesingle{}argument collapse}
\KeywordTok{str\_c}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Bouches{-}du{-}Rhône"}\NormalTok{), }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Marseille, Bouches-du-Rhône"
\end{lstlisting}

\begin{remarque}
La fonction \texttt{str\_c()} s'appuie en fait sur la fonction \texttt{paste()} du \emph{package} \{\texttt{base}\}. Par défaut, la chaîne de séparation utilisée dans \texttt{paste()} est une espace. La fonction \texttt{paste0()} permet quant à elle de concaténer les chaînes sans séparateur.
Il existe cependant de légères différences entre les deux fonctions, comme la festion des éléments \texttt{NULL} et \texttt{character(0)} :
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(}\StringTok{"You"}\NormalTok{, }\StringTok{"shall"}\NormalTok{, }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{), }\StringTok{"not"}\NormalTok{, }\OtherTok{NULL}\NormalTok{, }\StringTok{"pass"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "You shall  not  pass"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_c}\NormalTok{(}\StringTok{"You"}\NormalTok{, }\StringTok{"shall"}\NormalTok{, }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{), }\StringTok{"not"}\NormalTok{, }\OtherTok{NULL}\NormalTok{, }\StringTok{"pass"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{" "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "You shall not pass"
\end{lstlisting}

Si les objets donnés en argument à la fonction \texttt{str\_c()} sont de tailles différentes, un recyclage est effectué par R.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_c}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"Julien{-}Yacine"}\NormalTok{, }\StringTok{"Sonia"}\NormalTok{, }\StringTok{"Victor"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "HelloJulien-Yacine" "HelloSonia"         "HelloVictor"
\end{lstlisting}

Attention, R convertit les valeurs manquantes (\texttt{NA}) en chaînes de caractères \texttt{"NA"}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_c}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, }\OtherTok{NA}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] NA
\end{lstlisting}

\begin{remarque}
Quand on souhaite accéder à une variable en renseignant son nom en utilisant la fonction \texttt{str\_c()}, il faut faire appel à la fonction \texttt{get()}.
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{variable\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\DecValTok{5}
\CommentTok{\# Affiche la chaîne "variable\_1"}
\KeywordTok{str\_c}\NormalTok{(}\StringTok{"variable\_"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "variable_1"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Affiche le contenu de la variable nommée "variable\_1"}
\KeywordTok{get}\NormalTok{(}\KeywordTok{str\_c}\NormalTok{(}\StringTok{"variable\_"}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 5
\end{lstlisting}

\hypertarget{conversion-en-majuscules-ou-minuscules}{%
\subsubsection{Conversion en majuscules ou minuscules}\label{conversion-en-majuscules-ou-minuscules}}

Afin de passer une chaîne de caractères en majuscules ou en minuscules, le \emph{package} \{\texttt{stringr}\} propose les fonctions \texttt{str\_to\_upper()} et \texttt{str\_to\_lower()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ "Bonjour !"}
\KeywordTok{str\_to\_upper}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "BONJOUR !"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_to\_lower}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "bonjour !"
\end{lstlisting}

\hypertarget{compter-le-nombre-de-caractuxe8res-dune-chauxeene}{%
\subsubsection{Compter le nombre de caractères d'une chaîne}\label{compter-le-nombre-de-caractuxe8res-dune-chauxeene}}

La fonction \texttt{str\_length()} du \emph{package} \{\texttt{stringr}\} indique le nombre de caractères contenus dans une chaîne.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_length}\NormalTok{(}\StringTok{"Bonjour"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 7
\end{lstlisting}

La fonction \texttt{str\_length()} s'appuie sur la fonction \texttt{nchar()} du \emph{package} \{\texttt{base}\}. On peut noter que la longueur de \texttt{NA} vaut NA avec \texttt{str\_length()} et \texttt{2} avec la fonction native \texttt{nchar()}.

\begin{lstlisting}
texte <- c("Mais enfin", "c'est quoi", "un gigowatt ?", NA)
str_length(string = texte)
nchar(x = texte)
\end{lstlisting}

\hypertarget{extraction-de-sous-chauxeenes}{%
\subsubsection{Extraction de sous-chaînes}\label{extraction-de-sous-chauxeenes}}

Pour extraire une sous-chaîne, on peut utiliser la fonction \texttt{str\_sub()} du \emph{package} \{\texttt{stringr}\}, qui prend en arguments une chaîne de caractères, la position du début et celle de la fin de l'élément à extraire. Attention, l'indice du premier élément, tout comme pour les vecteurs, est 1 en R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ "Debt is one person\textquotesingle{}s liability, but another person\textquotesingle{}s asset."}
\KeywordTok{str\_sub}\NormalTok{(x, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Debt"
\end{lstlisting}

Il est possible d'utiliser la flèche d'assignation après la fonction \texttt{str\_sub()} pour remplacer la sous-chaîne extraite par une autre. Si la chaîne de remplacement est trop longue, elle n'est pas tronquée pour avoir la même longueur que celle qui est extraite.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_sub}\NormalTok{(x, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{) \textless{}{-}}\StringTok{ "Remplacement"}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Remplacement is one person's liability, but another person's asset."
\end{lstlisting}

L'argument \texttt{string} de la fonction \texttt{str\_sub()} peut être un vecteur. Dans ce cas, la fonction est appliquée à chaque élément du vecteur.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_sub}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Rouge"}\NormalTok{, }\StringTok{"Vert"}\NormalTok{, }\StringTok{"Bleu"}\NormalTok{), }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "ou" "er" "le"
\end{lstlisting}

Lors du remplacement, R peut avoir recours au recyclage.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Rouge"}\NormalTok{, }\StringTok{"Vert"}\NormalTok{, }\StringTok{"Bleu"}\NormalTok{)}
\KeywordTok{str\_sub}\NormalTok{(x, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{) \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"!!"}\NormalTok{, }\StringTok{"@@"}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "R!!ge" "V@@t"  "B!!u"
\end{lstlisting}

En fournissant aux arguments \texttt{start} et \texttt{end} des valeurs négatives, on indique à R de lire la chaîne à l'envers :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{texte \textless{}{-}}\StringTok{ "le train de tes injures roule sur le rail de mon indifférence"}
\KeywordTok{str\_sub}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ texte, }\DataTypeTok{start =} \DecValTok{4}\NormalTok{, }\DataTypeTok{end =} \DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "train"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Compter à partir du dernier caractère}
\KeywordTok{str\_sub}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ texte, }\DataTypeTok{start =} \DecValTok{{-}12}\NormalTok{, }\DataTypeTok{end =} \DecValTok{{-}1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "indifférence"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_sub}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ texte, }\DataTypeTok{start =} \DecValTok{{-}16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "mon indifférence"
\end{lstlisting}

La fonction \texttt{str\_sub()} s'appuie sur la fonction \texttt{substr()} du \emph{package} \{\texttt{base}\}, mais propose quelques améliorations.

Dans le cas du remplacement d'une chaîne extraitre par une autre, on distingue trois cas :

\begin{itemize}
\tightlist
\item
  la chaîne de remplacement est de même longueur que celle extraite : \texttt{str\_sub()} et \texttt{substr()} se comportent de la même manière ;
\item
  a chaîne de remplacement est plus courte que celle extraite : avec \texttt{substr()}, la chaîne de remplacement est complétée par la fin de celle extraite, tandis qu'avec \texttt{str\_sub()}, la chaîne extraite est retirée et remplacée par celle de remplacement ;
\item
  la chaîne de remplacement est plus longue que celle extraite : avec \texttt{substr()}, la chaîne de remplacement est tronquée, tandis qu'elle ne l'est pas avec \texttt{str\_sub()}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{texte \textless{}{-}}\StringTok{ "le train de tes injures roule sur le rail de mon indifférence"}
\CommentTok{\# On copie le contenu de texte dans une nouvelle variable}
\NormalTok{texte\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\NormalTok{texte}

\CommentTok{\# Remplacement plus court que la chaîne extraite}
\KeywordTok{str\_sub}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ texte, }\DataTypeTok{start =} \DecValTok{17}\NormalTok{, }\DataTypeTok{end =} \DecValTok{23}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "injures"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_sub}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ texte, }\DataTypeTok{start =} \DecValTok{17}\NormalTok{, }\DataTypeTok{end =} \DecValTok{23}\NormalTok{) \textless{}{-}}\StringTok{ "jurons"}
\KeywordTok{substr}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ texte\_}\DecValTok{2}\NormalTok{, }\DataTypeTok{start =} \DecValTok{17}\NormalTok{, }\DataTypeTok{stop =} \DecValTok{23}\NormalTok{) \textless{}{-}}\StringTok{ "jurons"}
\NormalTok{texte ; texte\_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "le train de tes jurons roule sur le rail de mon indifférence"
\end{lstlisting}

\begin{lstlisting}
## [1] "le train de tes juronss roule sur le rail de mon indifférence"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Remplacement plus long que la chaîne extraite}
\KeywordTok{str\_sub}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ texte, }\DataTypeTok{start =} \DecValTok{1}\NormalTok{, }\DataTypeTok{end =} \DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "le train"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_sub}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ texte, }\DataTypeTok{start =} \DecValTok{1}\NormalTok{, }\DataTypeTok{end =} \DecValTok{8}\NormalTok{) \textless{}{-}}\StringTok{ "la locomotive"}
\KeywordTok{substr}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ texte\_}\DecValTok{2}\NormalTok{, }\DataTypeTok{start =} \DecValTok{1}\NormalTok{, }\DataTypeTok{stop =} \DecValTok{8}\NormalTok{) \textless{}{-}}\StringTok{ "la locomotive"}
\NormalTok{texte ; texte\_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "la locomotive de tes jurons roule sur le rail de mon indifférence"
\end{lstlisting}

\begin{lstlisting}
## [1] "la locom de tes juronss roule sur le rail de mon indifférence"
\end{lstlisting}

\hypertarget{manip-strings-regex}{%
\subsubsection{Recherche de chaînes de caractères}\label{manip-strings-regex}}

Quand on souhaite trouver un motif (\emph{pattern}) dans un vecteur de chaînes de caractères, on peut utiliser la fonction \texttt{str\_detect()} du \emph{package} \texttt{stringr}. Elle retourne les indices des éléments du vecteur dans lesquels le motif a été trouvé.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =} \KeywordTok{c}\NormalTok{(}\StringTok{"Pomme"}\NormalTok{, }\StringTok{"Poire"}\NormalTok{, }\StringTok{"Ananas"}\NormalTok{), }\DataTypeTok{pattern =} \StringTok{"o"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE FALSE
\end{lstlisting}

Pour remplacer la première occurrence du motif trouvé par une autre chaîne (qui n'est pas tenue d'être de la même longueur de caractères), on peut utiliser la fonction \texttt{str\_replace()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_replace}\NormalTok{(}\DataTypeTok{string =} \KeywordTok{c}\NormalTok{(}\StringTok{"Pomme"}\NormalTok{, }\StringTok{"Poire"}\NormalTok{, }\StringTok{"Ananas"}\NormalTok{), }\DataTypeTok{pattern =} \StringTok{"a"}\NormalTok{, }\DataTypeTok{replacement =} \StringTok{"@@"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Pomme"   "Poire"   "An@@nas"
\end{lstlisting}

Si on désire remplacer toutes les occurrences trouvées, il faut alors utiliser la fonction \texttt{str\_replace\_all()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_replace\_all}\NormalTok{(}\DataTypeTok{string =} \KeywordTok{c}\NormalTok{(}\StringTok{"Pomme"}\NormalTok{, }\StringTok{"Poire"}\NormalTok{, }\StringTok{"Ananas"}\NormalTok{), }\DataTypeTok{pattern =} \StringTok{"a"}\NormalTok{, }\DataTypeTok{replacement =} \StringTok{"@@"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Pomme"    "Poire"    "An@@n@@s"
\end{lstlisting}

Si on souhaite ignorer la casse, il suffit de faire appel à la fonction \texttt{regex()} en précisant à l'aide de l'argument \texttt{ignore\_case} que l'on souhaite ne pas prendre en compte la casse :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =} \KeywordTok{c}\NormalTok{(}\StringTok{"Obi{-}Wan Kenobi"}\NormalTok{, }\StringTok{"Darth Vader"}\NormalTok{), }\DataTypeTok{pattern =} \StringTok{"w"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =} \KeywordTok{c}\NormalTok{(}\StringTok{"Obi{-}Wan Kenobi"}\NormalTok{, }\StringTok{"Darth Vader"}\NormalTok{), }
           \DataTypeTok{pattern =} \KeywordTok{regex}\NormalTok{(}\StringTok{"w"}\NormalTok{, }\DataTypeTok{ignore\_case =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE
\end{lstlisting}

Pour briser une chaîne en fonction d'un motif, le \emph{package} \{\texttt{stringr}\} propose la fonction \texttt{str\_split()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x =}\StringTok{ "Criquette ! Vous, ici ? Dans votre propre salle de bain ? Quelle surprise !"}
\KeywordTok{str\_split}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ x, }\DataTypeTok{pattern =} \StringTok{" "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
##  [1] "Criquette" "!"         "Vous,"     "ici"       "?"         "Dans"     
##  [7] "votre"     "propre"    "salle"     "de"        "bain"      "?"        
## [13] "Quelle"    "surprise"  "!"
\end{lstlisting}

Une des rares fonctions du \emph{package} \texttt{stringr} ne commençant pas par le préfixe \texttt{str} est la fonction \texttt{word()}. Comme son nom le laisse présager, elle permet d'extraire des mots dans une phrase. Les mots sont repérés par défaut par une espace, mais il est possible de préciser un séparateur différent avec l'argument \texttt{sep}. L'argument \texttt{start} attend une valeur entière donnant la position du premier mot à extraire (celle du premier mot de la phrase, par défaut). Si la valeur est négative, le comptage s'effectue de la droite vers la gauche. L'argument \texttt{end} attend l'entier donnant la position du dernier mot à extraire (vaut la valeur de \texttt{start} s'il est omis). Encore une fois, si la valeur est négative, le comptage s'effectue de la droite vers la gauche.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phrase \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Mademoiselle Deray, il est interdit de manger de la choucroute ici."}\NormalTok{,}
            \StringTok{"Oh si si, prenez un chewing{-}gum, Émile."}\NormalTok{)}
\KeywordTok{word}\NormalTok{(phrase) }\CommentTok{\# Extraction du premier mot}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Mademoiselle" "Oh"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{word}\NormalTok{(phrase, }\DecValTok{2}\NormalTok{) }\CommentTok{\# Extraction du second mot}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Deray," "si"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{word}\NormalTok{(phrase, }\DecValTok{{-}1}\NormalTok{) }\CommentTok{\# Extraction du dernier mot}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "ici."   "Émile."
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{word}\NormalTok{(phrase, }\DecValTok{2}\NormalTok{, }\DecValTok{{-}1}\NormalTok{) }\CommentTok{\# Extraction du second au dernier mot}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Deray, il est interdit de manger de la choucroute ici."
## [2] "si si, prenez un chewing-gum, Émile."
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Du premier au dernier mot, du second au dernier, et du troisième au dernier}
\CommentTok{\# pour le premier élément de phrase}
\KeywordTok{word}\NormalTok{(phrase[}\DecValTok{1}\NormalTok{], }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{{-}1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Mademoiselle Deray, il est interdit de manger de la choucroute ici."
## [2] "Deray, il est interdit de manger de la choucroute ici."             
## [3] "il est interdit de manger de la choucroute ici."
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Premier mot, Premier et second mot, Premier et troisième mot}
\CommentTok{\# pour le second élément de phrase}
\KeywordTok{word}\NormalTok{(phrase[}\DecValTok{2}\NormalTok{], }\DecValTok{1}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Oh"        "Oh si"     "Oh si si,"
\end{lstlisting}

\begin{remarque}
La fonction \texttt{str\_detect()} s'appuie sur la fonction \texttt{grepl()} du \emph{package} \{base\} ; les fonctions \texttt{str\_replace()} et \texttt{str\_replace\_all()} sur la fonction \texttt{sub()} du \emph{package} \{\texttt{base}\}. La fonction \texttt{str\_split()} correspond à la fonction \texttt{strsplit()} du \emph{package} \{\texttt{base}\}.
\end{remarque}

Des recherches bien plus complèxes et puissantes peuvent être effectuées avec R, et sont présentées dans la Section~\ref{regex}.

\hypertarget{nettoyage-compluxe9tion}{%
\subsubsection{Nettoyage, complétion}\label{nettoyage-compluxe9tion}}

\hypertarget{la-fonction-str_dup}{%
\paragraph{\texorpdfstring{La fonction \texttt{str\_dup()}}{La fonction str\_dup()}}\label{la-fonction-str_dup}}

La fonction \texttt{str\_dup()} du \emph{package} \{\texttt{stringr}\} permet de dupliquer du texte. Elle est vectorisée à la fois pour le vecteur de texte à fournir à l'argument \texttt{string} et au vecteur d'entiers à fournir à l'argument \texttt{times}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{texte \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"bla"}\NormalTok{, }\StringTok{"ah"}\NormalTok{, }\StringTok{"eh"}\NormalTok{)}
\KeywordTok{str\_dup}\NormalTok{(texte, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "blabla" "ahah"   "eheh"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_dup}\NormalTok{(texte, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "bla"    "ahah"   "eheheh"
\end{lstlisting}

\hypertarget{la-fonction-str_pad}{%
\paragraph{\texorpdfstring{La fonction \texttt{str\_pad()}}{La fonction str\_pad()}}\label{la-fonction-str_pad}}

Certains fichiers de données ont des largeurs fixes pour chaque colonne. Si on désire créer facilement ce genre de fichiers, la fonction \texttt{str\_pad()} du \emph{package} \texttt{stringr} peut se révéler très pratique. En effet, elle permet de définir un caractère à insérer avant ou après une chaîne, ou bien avant et après, et de le répéter un nombre donné de fois. On précise la longueur des chaînes retournées avec l'argument \texttt{width}, le caractère à insérer pour éventuellement compléter la chaîne avec l'argument \texttt{pad} et le côté sur lequel insérer ce caractère avec l'argument \texttt{side} pouvant prendre les valeurs \texttt{"left"}, \texttt{"right"} ou \texttt{"both"}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{coords \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{lat =} \StringTok{"48.11"}\NormalTok{, }\DataTypeTok{long =} \StringTok{"{-}1.6794"}\NormalTok{)}
\KeywordTok{str\_pad}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ coords, }\DataTypeTok{width =} \DecValTok{7}\NormalTok{, }\DataTypeTok{side =} \StringTok{"left"}\NormalTok{, }\DataTypeTok{pad =} \StringTok{" "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "  48.11" "-1.6794"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Les chaînes plus longues que la valeur fournie à width sont inchangées}
\KeywordTok{str\_pad}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Gauthier"}\NormalTok{, }\StringTok{"Pascaline"}\NormalTok{), }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Gauthier"  "Pascaline"
\end{lstlisting}

Cette fonction est également utile lorsque l'on veut créer des noms de fichiers préfixés par un nombre, de manière à permettre leur rangement par ordre croissant dans l'explorateur de fichier (\texttt{10.txt} viendra avant \texttt{9.txt} tandis que \texttt{09.txt} viendra avant \texttt{10.txt}).

\hypertarget{la-fonction-str_trim}{%
\paragraph{\texorpdfstring{La fonction \texttt{str\_trim()}}{La fonction str\_trim()}}\label{la-fonction-str_trim}}

Pour retirer des caractères blancs (e.g., espaces, sauts de ligne, retours à la ligne, quadratins, etc.), on peut utiliser des méthodes abordées dans la Section~@ref(manip\_strings\_regex), ou bien la fonction \texttt{str\_trim()} du \emph{package} \{\texttt{stringr}\}. Elle retire tous les caractères blancs à gauche et à droite d'une chaîne de caractères. L'argument \texttt{side} permet de choisir le côté pour lequel on désire retirer les caractères blancs. Il peut prendre les valeurs \texttt{both} (par défaut), \texttt{left} ou \texttt{right}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{texte \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{Pardon, du sucre ?"}\NormalTok{, }\StringTok{"Oui, seize   }\CharTok{\textbackslash{}n}\StringTok{ "}\NormalTok{, }\StringTok{"...}\CharTok{\textbackslash{}t\textbackslash{}t}\StringTok{...}\CharTok{\textbackslash{}t}\StringTok{"}\NormalTok{)}
\KeywordTok{str\_trim}\NormalTok{(texte, }\DataTypeTok{side =} \StringTok{"both"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Pardon, du sucre ?" "Oui, seize"         "...\t\t..."
\end{lstlisting}

\hypertarget{dates-1}{%
\subsection{Dates}\label{dates-1}}

Comme indiqué dans la Section~\ref{structure-dates}, les dates en R peuvent être de trois classes différentes, \texttt{Date}, \texttt{POSIXct} et \texttt{POSIXlt}. Dans cette Section, nous allons voir comment manipuler ces dates, à l'aide des fonctions du \emph{package} \{\texttt{lubridate}\}.

\hypertarget{extraction}{%
\subsubsection{Extraction}\label{extraction}}

Le \emph{package} \{\texttt{lubridate}\} propose quelques fonctions pour accéder aux éléments d'une date.

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.43\columnwidth}\raggedright
Fonction\strut
\end{minipage} & \begin{minipage}[b]{0.51\columnwidth}\raggedright
Extraction\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{second()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
secondes (0--59)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{minute()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
minutes (0--59)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{hour()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
heures (0--23)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{day()}, \texttt{mday()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
jour du mois (1--31)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{wday()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
jour de la semaine (1--7), le dimanche étant le 1\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{yday()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
jour de l'année (1--366)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{week()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
numéro de la semaine dans l'année. Les semaines sont définies comme les pé- riodes complètes de 7 jours s'étant déroulées depuis le premier janvier, plus 1\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{isoweek()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
Semaine de l'année (00-53). Si la semaine (qui commence un lundi) qui contient le 1er janvier a 4 jours ou plus dans la nouvelle année, alors elle est considérée comme la semaine 1. Sinon, elle est considérée comme la dernière de l'année précédente, et la suivante est considérée comme semaine 1\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{month()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
mois (1--12)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{year()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
année, uniquement celles après l'an 1\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.43\columnwidth}\raggedright
\texttt{tz()}\strut
\end{minipage} & \begin{minipage}[t]{0.51\columnwidth}\raggedright
fuseau horraire\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Les fonctions \texttt{wday()} et \texttt{month()} permettent aussi d'afficher le jour de la semaine et le mois, respectivement, en chaîne de caractères, en donnant leur nom dans le langage par défaut de votre session R. Pour cela, il faut attribuer la valeur \texttt{TRUE} a l'argument \texttt{label}. Si on souhaite les abréviations, il faut donner la valeur \texttt{TRUE} à l'argument \texttt{abbr} en sus.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(lubridate)}
\NormalTok{(d \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}03{-}17 23:59:59"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-03-17 23:59:59 UTC"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{wday}\NormalTok{(d, }\DataTypeTok{label =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] Mar
## Levels: Dim < Lun < Mar < Mer < Jeu < Ven < Sam
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{wday}\NormalTok{(d, }\DataTypeTok{label =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{abbr =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] Mar
## Levels: Dim < Lun < Mar < Mer < Jeu < Ven < Sam
\end{lstlisting}

Il arrive que l'on préfère obtenir ces noms dans une autre langue (lorsque l'on doit réaliser des graphiques en anglais, par exemple). Deux options simples peuvent être mises en place : la traduction ``à la main'', en créant un tableau de correspondande entre la langue par défaut de la session R et celle désirée. La seconde solution est plus pratique. Elle consiste à faire appel à l'argument \texttt{locale} des fonctions de \{\texttt{lubridate}\}. Il suffit de fournir à cet argument le nom du local à utiliser. Le seul hic, est que ce nom est dépendant du système\ldots{} Il faut donc le prendre en compte lors de la rédaction de codes, pour que le script puisse être lancé sur un système Unix ou Windows.

Sous Unix, on peut afficher l'ensemble des noms disponibles avec la commande système suivante (évaluée directement depuis la console R) :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system}\NormalTok{(}\StringTok{"locale {-}a"}\NormalTok{, }\DataTypeTok{intern =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pour Windows, il faut consulter la liste des noms est disponible sur la documentation en ligne de Microsoft : il faut chercher dans un moteur de recherche l'expression : \texttt{"MSDN\ Language\ Strings"}{[}\^{}comme indiqué sur \href{https://stackoverflow.com/a/26604195}{cette réponse} sur StakOverflow.{]}.

Ainsi, pour obtenir l'affichage du nom du jour de la semaine en anglais, on écrira :

\begin{itemize}
\tightlist
\item
  Sous Unix :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{wday}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}03{-}17"}\NormalTok{), }\DataTypeTok{label =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{abbr =} \OtherTok{FALSE}\NormalTok{,}
     \DataTypeTok{locale =} \StringTok{"en\_US"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Sous Windows:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{wday}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}03{-}17"}\NormalTok{), }\DataTypeTok{label =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{abbr =} \OtherTok{FALSE}\NormalTok{,}
     \DataTypeTok{locale =} \StringTok{"english\_us"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si on désire que le script soit exportable sur différents systèmes d'exploitation, on peut prévoir, à l'aide d'une instruction conditionnelle (ces aspects seront abordés dans un autre chapitre), les deux cas de figure : Unix ou Windows. En effet, l'expression \texttt{.Platform\$OS.type} permet d'afficher le type de système d'exploitation :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{.Platform}\OperatorTok{$}\NormalTok{OS.type}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "unix"
\end{lstlisting}

Aussi, pour que le code soit exportable, on peut écrire :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{(.Platform}\OperatorTok{$}\NormalTok{OS.type }\OperatorTok{==}\StringTok{ "unix"}\NormalTok{)\{}
  \KeywordTok{wday}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}03{-}17"}\NormalTok{), }\DataTypeTok{label =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{abbr =} \OtherTok{FALSE}\NormalTok{,}
     \DataTypeTok{locale =} \StringTok{"en\_US"}\NormalTok{)}
\NormalTok{\}}\ControlFlowTok{else}\NormalTok{\{}
  \KeywordTok{wday}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}03{-}17"}\NormalTok{), }\DataTypeTok{label =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{abbr =} \OtherTok{FALSE}\NormalTok{,}
     \DataTypeTok{locale =} \StringTok{"english\_us"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Lorsque les formats de dates ne respectent pas les standards habituels (c'est le cas par exemple avec des dates que l'on peut obtenir \emph{via} l'API de Twitter), les fonctions du type \texttt{ymd\_hms()} ne parviendront pas à reconnaître le format. Le \emph{package} \{\texttt{lubridate}\} dispose d'une fonction qui permettra de définir soi-même le format de la date : \texttt{parse\_date\_time()}

Admettons que nous ayons une date sous forme de chaîne de caractères écrite de la sorte :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ "Fri Dec 25 20:12:00 +0001 2020"}
\end{Highlighting}
\end{Shaded}

Il faut indiquer à l'argument \texttt{orders} l'ordre dans lequel les différents éléments composant la date apparaissent. La Section~\ref(dates-POSIXct) recense tous les éléments de dates dans un tableau. Ces éléments sont utiles ici. On comprend que la date contient le jour de la semaine abrégé (\texttt{\%a}), le mois abrégé (\texttt{\%b}), puis le numéro du jour dans le mois (\texttt{\%d}) etc. De plus, les abréviations correspondent au local anglais, il faut dont indquer à l'argument \texttt{locale} que la date est rédigée en anglais.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{parse\_date\_time}\NormalTok{(x, }\DataTypeTok{orders =} \StringTok{"\%a \%b \%d \%H:\%M:\%S \%z \%Y"}\NormalTok{, }\DataTypeTok{locale =} \StringTok{"en\_US"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-12-25 20:11:24 UTC"
\end{lstlisting}

\hypertarget{opuxe9rations}{%
\subsubsection{Opérations}\label{opuxe9rations}}

Avant de présenter quelques exemples, créons quelques variables de dates. Rappelons-nous qu'avec les fonctions ne prenant pas en compte l'heure, la minute et la seconde, les objets créés avec les fonctions du \emph{package} \{\texttt{lubridate}\} sont de classe \texttt{Date}. Si ces éléments sont pris en compte, les objets sont de type \texttt{POSIXct}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Quelques dates}
\NormalTok{d\_date\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ymd}\NormalTok{(}\StringTok{"2019{-}09{-}01"}\NormalTok{)}
\NormalTok{d\_date\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}10{-}21"}\NormalTok{)}
\KeywordTok{class}\NormalTok{(d\_date\_}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Date"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_posix\_ct\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}03{-}17 12:32:28"}\NormalTok{)}
\NormalTok{d\_posix\_ct\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}05{-}11 13:55:44"}\NormalTok{)}
\KeywordTok{class}\NormalTok{(d\_posix\_ct\_}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "POSIXct" "POSIXt"
\end{lstlisting}

Pour ajouter ou retirer des durées de temps, il faut se rappeler comment sont stockées les dates. Avec les objets de mode \texttt{Date}, il s'agit d'un nombre de jours. Aussi, additioner un nombre \(n\) à un objet de type \texttt{date} retourne la date \(n\) jours plus tard. Pour les objets de classe \texttt{POSIXct} ou \texttt{POSIXlt}, comme R stock la date en secondes, l'ajout d'un nombre \(n\) retourne la date augmentée de \(n\) secondes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_date\_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-21"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_date\_}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-31"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_date\_}\DecValTok{2} \OperatorTok{{-}}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-11"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_posix\_ct\_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-05-11 13:55:44 UTC"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_posix\_ct\_}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-05-11 13:55:54 UTC"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_posix\_ct\_}\DecValTok{2} \OperatorTok{{-}}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-05-11 13:55:34 UTC"
\end{lstlisting}

Toujours dû à ce stockage interne en jours ou secondes, il est possible de comparer facilement deux dates entre-elles, avec les opérateurs classiques.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_date\_}\DecValTok{1} \OperatorTok{\textgreater{}}\StringTok{ }\NormalTok{d\_date\_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_posix\_ct\_}\DecValTok{2} \OperatorTok{\textgreater{}}\StringTok{ }\NormalTok{d\_posix\_ct\_}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_posix\_ct\_}\DecValTok{2} \OperatorTok{==}\StringTok{ }\NormalTok{d\_posix\_ct\_}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\hypertarget{intervalles-de-dates}{%
\subsubsection{Intervalles de dates}\label{intervalles-de-dates}}

La fonction \texttt{interval()} du \emph{package} \texttt{lubridate} crée un intervalle de temps entre deux dates. On peut également utiliser l'opérateur \texttt{\%-\/-\%}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{debut \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}03{-}17 07:00:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Australia/Perth"}\NormalTok{)}
\NormalTok{fin \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}05{-}11 23:00:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Australia/Perth"}\NormalTok{)}

\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{interval}\NormalTok{(debut, fin))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-03-17 07:00:00 AWST--2020-05-11 23:00:00 AWST
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{debut }\OperatorTok{\%{-}{-}\%}\StringTok{ }\NormalTok{fin}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-03-17 07:00:00 AWST--2020-05-11 23:00:00 AWST
\end{lstlisting}

La durée d'un intervalle s'obtient avec la fonction \texttt{int\_length()}. Le résultat est exprimé en secondes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{int\_length}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4809600
\end{lstlisting}

Pour exprimer cette différence de dates dans un format plus compréhensible pour un humain, \{\texttt{lubridate}\} propose deux approches : les durées (\emph{durations}) et les époques (\emph{periods}). La différence entre les deux est que les \emph{durations} ne tiennent pas en compte des fluctuations de la ligne du temps, comme les années bissextiles, tandis que les \emph{periods} le font.

Les fonctions qui crééent les durées possèdent le nom au pluriel de ces durées précédé du préfixe \texttt{d} ; les fonctions qui créent les époques laissent quant à elle tomber le préxixe.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{minutes}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "10M 0S"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dminutes}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "600s (~10 minutes)"
\end{lstlisting}

Pour illustrer la différence entre les \emph{durations} et les \emph{periods}, regardons un exemple avec la fonction \texttt{leap\_year()} qui retourne un logique indiquant si l'année passée en argument est bissextile.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{leap\_year}\NormalTok{(}\DecValTok{2000}\NormalTok{) }\CommentTok{\# 2000 était une année bissextile}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ajout d\textquotesingle{}une durée d\textquotesingle{}un an, soit 365 jours}
\KeywordTok{ymd}\NormalTok{(}\StringTok{"2000{-}01{-}01"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{dyears}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2000-12-31 06:00:00 UTC"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ajout d\textquotesingle{}une période d\textquotesingle{}un an, soit 366 jours dans ce cas}
\KeywordTok{ymd}\NormalTok{(}\StringTok{"2000{-}01{-}01"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{years}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2001-01-01"
\end{lstlisting}

Après ce détour, nous pouvons revenir à ce qui nous intéresse à l'origine : obtenir la durée d'un intervalle entre deux dates exprimée dans un format plus compréhensible pour un humain. On peut obtenir la durée d'un intervalle exprimée en jours, en mois, en semaines, etc. en le divisant par une durée.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{intervalle \textless{}{-}}\StringTok{ }\KeywordTok{interval}\NormalTok{(}\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}03{-}17 10:00:00"}\NormalTok{),}
                           \KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}05{-}11 08:00:00"}\NormalTok{))}
\CommentTok{\# Nombre de jours de confinement durant la pandémie de Covid{-}19}
\NormalTok{intervalle }\OperatorTok{/}\StringTok{ }\KeywordTok{ddays}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 54.91667
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Nombre de durées de 2 jours}
\NormalTok{intervalle }\OperatorTok{/}\StringTok{ }\KeywordTok{ddays}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 27.45833
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Nombre d\textquotesingle{}heures}
\NormalTok{intervalle }\OperatorTok{/}\StringTok{ }\KeywordTok{dhours}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1318
\end{lstlisting}

L'ensemble des \emph{durations} est donné dans le tableau ci-dessous.

\begin{longtable}[]{@{}ll@{}}
\toprule
Fonction & Description\tabularnewline
\midrule
\endhead
& dseconds()\tabularnewline
dminutes() & Minutes\tabularnewline
dhours() & Heures\tabularnewline
ddays() & Jours\tabularnewline
dweeks() & Semaines\tabularnewline
dmonths() & Mois\tabularnewline
dyears() & Années\tabularnewline
dmilliseconds() & Milisecondes\tabularnewline
dmicroseconds() & Microsecondes\tabularnewline
dnanoseconds() & Nanosecondes\tabularnewline
dpicoseconds() & Picosecondes\tabularnewline
\bottomrule
\end{longtable}

On peut chercher si deux intervalles se chevauchent, avec la fonction \texttt{int\_overlaps()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{debut\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}03{-}01 08:00:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Australia/Perth"}\NormalTok{)}
\NormalTok{fin\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}10{-}01 10:00:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Australia/Perth"}\NormalTok{)}

\NormalTok{debut\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}10{-}02 09:00:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Australia/Perth"}\NormalTok{)}
\NormalTok{fin\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}10{-}02 10:00:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Australia/Perth"}\NormalTok{)}

\NormalTok{intervalle\_}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-03-17 07:00:00 AWST--2020-05-11 23:00:00 AWST
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(intervalle\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{interval}\NormalTok{(debut\_}\DecValTok{2}\NormalTok{, fin\_}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-03-01 08:00:00 AWST--2020-10-01 10:00:00 AWST
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(intervalle\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{interval}\NormalTok{(debut\_}\DecValTok{3}\NormalTok{, fin\_}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-10-02 09:00:00 AWST--2020-10-02 10:00:00 AWST
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{int\_overlaps}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{, intervalle\_}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{int\_overlaps}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{, intervalle\_}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

On peut utiliser les fonctions ensemblistes sur des intervalles (\texttt{union()} (union), \texttt{intersect()} (intersection), \texttt{setdiff()} (différence), \texttt{setequal()} (égalité) et \texttt{\%within\%} (tester si une date est dans un intervalle)).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{union}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{, intervalle\_}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-03-01 08:00:00 AWST--2020-10-01 10:00:00 AWST
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{intersect}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{, intervalle\_}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] NA--NA
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{setdiff}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{, intervalle\_}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-03-17 07:00:00 AWST--2020-05-11 23:00:00 AWST
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{base}\OperatorTok{::}\KeywordTok{setequal}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{, intervalle\_}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{debut\_}\DecValTok{2} \OperatorTok{\%within\%}\StringTok{ }\NormalTok{intervalle\_}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

Après avoir utilisé ces fonctions ensemblistes, on peut être amené à vouloir extraire les bornes de l'intervalle. Il faut alors utiliser les fonctions \texttt{int\_start()} et \texttt{int\_end()} pour les bornes inférieures et supérieures respectivement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(intervalle \textless{}{-}}\StringTok{ }\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{setdiff}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{, intervalle\_}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-03-17 07:00:00 AWST--2020-05-11 23:00:00 AWST
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{int\_start}\NormalTok{(intervalle)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-03-17 07:00:00 AWST"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{int\_end}\NormalTok{(intervalle)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-05-11 23:00:00 AWST"
\end{lstlisting}

La fonction \texttt{int\_flip()} échange les bornes de l'intervalle. Le nouvel intervalle possède la même longueur, mais une direction opposée.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{int\_flip}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-05-11 23:00:00 AWST--2020-03-17 07:00:00 AWST
\end{lstlisting}

La fonction \texttt{int\_shift()} décale le début et la fin de l'intervalle, en fonction de la valeur fournie à l'argument \texttt{by}, qui doit être un objet de durée, que l'on peut obtenir avec la fonction \texttt{duration()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{int\_shift}\NormalTok{(intervalle\_}\DecValTok{1}\NormalTok{, }\KeywordTok{duration}\NormalTok{(}\DataTypeTok{days =} \DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2020-03-22 07:00:00 AWST--2020-05-16 23:00:00 AWST
\end{lstlisting}

La fonction \texttt{int\_aligns()} permet de tester si deux intervalles ont une borne commune, sans prendre en compte la direction de chaque intervalle. Ainsi, la fonction teste si les moments les plus anciens ou plus récents de chaque intervallent arrivent au même moment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{int\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{interval}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2019{-}10{-}01"}\NormalTok{), }\KeywordTok{ymd}\NormalTok{(}\StringTok{"2019{-}10{-}05"}\NormalTok{))}
\NormalTok{int\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{interval}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2019{-}10{-}04"}\NormalTok{), }\KeywordTok{ymd}\NormalTok{(}\StringTok{"2019{-}10{-}01"}\NormalTok{))}
\NormalTok{int\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{interval}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}10{-}01"}\NormalTok{), }\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}10{-}05"}\NormalTok{))}

\KeywordTok{int\_aligns}\NormalTok{(int\_}\DecValTok{1}\NormalTok{, int\_}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{int\_aligns}\NormalTok{(int\_}\DecValTok{1}\NormalTok{, int\_}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\hypertarget{suxe9quence-de-dates}{%
\subsubsection{Séquence de dates}\label{suxe9quence-de-dates}}

Il est possible d'utiliser la fonction \texttt{seq()} avec des dates, qu'elles soient stockées au format \texttt{date}, \texttt{POSIXct} ou \texttt{POSIXlt}. Le lecteur ou la lectrice s'asurera de bien comprendre les exemples suivants.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec des objets de class date}
\KeywordTok{seq}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}09{-}01"}\NormalTok{), }\DataTypeTok{length =} \DecValTok{4}\NormalTok{, }\DataTypeTok{by =} \StringTok{"day"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-09-01" "2020-09-02" "2020-09-03" "2020-09-04"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Tous les deux jours}
\KeywordTok{seq}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}09{-}01"}\NormalTok{), }\DataTypeTok{length =} \DecValTok{4}\NormalTok{, }\DataTypeTok{by =} \StringTok{"2 days"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-09-01" "2020-09-03" "2020-09-05" "2020-09-07"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En spécifiant le début et la date maximum}
\KeywordTok{seq}\NormalTok{(}\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}09{-}01"}\NormalTok{), }\KeywordTok{ymd}\NormalTok{(}\StringTok{"2020{-}09{-}08"}\NormalTok{) , }\DataTypeTok{by =} \StringTok{"2 days"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-09-01" "2020-09-03" "2020-09-05" "2020-09-07"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec des objets de classe POSIXct}
\KeywordTok{seq}\NormalTok{(}\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}03{-}17 12:32:28 "}\NormalTok{), }\DataTypeTok{by =} \StringTok{"9 months"}\NormalTok{, }\DataTypeTok{length =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-03-17 12:32:28 UTC" "2020-12-17 12:32:28 UTC"
\end{lstlisting}

\hypertarget{fuseaux-horaires}{%
\subsubsection{Fuseaux horaires}\label{fuseaux-horaires}}

Il peut être utile de faire des conversions d'heures, pour obtenir la valeur dans un autre fuseau horaire. La fonction \texttt{with\_tz()} le permet.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Une heure à Paris}
\NormalTok{(d \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}10{-}30 20:00:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Europe/Paris"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-30 20:00:00 CET"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# L\textquotesingle{}heure équivalente à New York City}
\KeywordTok{with\_tz}\NormalTok{(d, }\StringTok{"America/New\_York"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-30 15:00:00 EDT"
\end{lstlisting}

La fonction \texttt{force\_tz()} permet de remplacer le fuseau horaire d'une date.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(d \textless{}{-}}\StringTok{ }\KeywordTok{ymd\_hms}\NormalTok{(}\StringTok{"2020{-}10{-}30 20:00:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"Europe/Paris"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-30 20:00:00 CET"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{force\_tz}\NormalTok{(d, }\StringTok{"America/New\_York"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "2020-10-30 20:00:00 EDT"
\end{lstlisting}

\hypertarget{calculs-matriciels}{%
\subsection{Calculs matriciels}\label{calculs-matriciels}}

Cette section aborde les opérations effectuées sur des matrices.

\hypertarget{addition-soustraction}{%
\subsubsection{Addition, soustraction}\label{addition-soustraction}}

L'addition et la soustraction de deux matrices \(A\) et \(B\) de même type ou d'une matrice et d'un scalaire \(a\) se font avec les opérateurs \texttt{+} et \texttt{-} respectivement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(A \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{), }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    3    2    1
## [3,]    2    1    3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(B \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{), }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    4    5    6
## [2,]    6    5    4
## [3,]    4    6    5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(C \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{ncol =} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1]
## [1,]    0
## [2,]    3
## [3,]    1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a \textless{}{-}}\StringTok{ }\DecValTok{2}
\NormalTok{A}\OperatorTok{+}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    3    4    5
## [2,]    5    4    3
## [3,]    4    3    5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A}\OperatorTok{+}\NormalTok{B}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    5    7    9
## [2,]    9    7    5
## [3,]    6    7    8
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A}\OperatorTok{{-}}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]   -1    0    1
## [2,]    1    0   -1
## [3,]    0   -1    1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A}\OperatorTok{{-}}\NormalTok{B}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]   -3   -3   -3
## [2,]   -3   -3   -3
## [3,]   -2   -5   -2
\end{lstlisting}

\hypertarget{multiplication-division}{%
\subsubsection{Multiplication, division}\label{multiplication-division}}

La multiplication et la division par un scalaire (\(aA\) et \(A/a\)) se font en utilisant les opérateurs \texttt{*} et \texttt{/}respectivement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\OperatorTok{*}\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    2    4    6
## [2,]    6    4    2
## [3,]    4    2    6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A}\OperatorTok{/}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]  0.5  1.0  1.5
## [2,]  1.5  1.0  0.5
## [3,]  1.0  0.5  1.5
\end{lstlisting}

La transposée d'une matrice (\(A^\top\)) s'obtient grâce à la fonction \texttt{t()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{t}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    1    3    2
## [2,]    2    2    1
## [3,]    3    1    3
\end{lstlisting}

La conjuguée d'une matrice (\(\overline{A}\)) s'obtient avec \texttt{Conj()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Conj}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    3    2    1
## [3,]    2    1    3
\end{lstlisting}

Pour multiplier deux matrices (\(AB\)), l'opérateur en R est \texttt{\%*\%}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A}\OperatorTok{\%*\%}\NormalTok{C}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1]
## [1,]    9
## [2,]    7
## [3,]    6
\end{lstlisting}

Il ne faut pas confondre avec l'opérateur \texttt{*}, qui, lorsqu'il est employé entre deux matrices, effectue la multiplication terme à terme.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A}\OperatorTok{*}\NormalTok{B}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    4   10   18
## [2,]   18   10    4
## [3,]    8    6   15
\end{lstlisting}

L'inversion d'une matrice (\(A^{-1}\)) s'effectue avec la fonction \texttt{solve()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{solve}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##             [,1]  [,2]       [,3]
## [1,] -0.41666667  0.25  0.3333333
## [2,]  0.58333333  0.25 -0.6666667
## [3,]  0.08333333 -0.25  0.3333333
\end{lstlisting}

Ce qui permet d'effectuer une division matricielle (\(BA^{1}\)).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OperatorTok{\%/\%}\StringTok{ }\KeywordTok{solve}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]  -10   19   18
## [2,]   10   20   -7
## [3,]   48  -25   15
\end{lstlisting}

La fonction \texttt{crossprod()} effectue le produit avec transposition (\(A^\top B\)).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{crossprod}\NormalTok{(A,B)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]   30   32   28
## [2,]   24   26   25
## [3,]   30   38   37
\end{lstlisting}

Elle réalise l'opération plus rapidement que l'instruction suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{t}\NormalTok{(A) }\OperatorTok{\%*\%}\StringTok{ }\NormalTok{B}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]   30   32   28
## [2,]   24   26   25
## [3,]   30   38   37
\end{lstlisting}

\hypertarget{duxe9terminant-trace}{%
\subsubsection{Déterminant, trace}\label{duxe9terminant-trace}}

Le calcul du déterminant d'une matrice (\(\textrm{det}(A)\)) s'obtient avec la fonction \texttt{det()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{det}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -12
\end{lstlisting}

En utilisant la fonction \texttt{diag()}, qui donne les éléments de la diagonale de la matrice passée en argument, on peut facilement obtenir la trace de la matrice (\(tr(A)\)).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{diag}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{diag}\NormalTok{(A))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 6
\end{lstlisting}

\hypertarget{tableaux_de_donnees}{%
\subsection{Tableaux de données}\label{tableaux_de_donnees}}

Cette partie montre comment manipuler la structure de données la plus fréquemment rencontrée en économétrie : les tableaux de données. Il sera considéré que ces tableaux de données sont sous la forme de \emph{tibbles} plutôt que \emph{data frame}. Les manipulations sont principalement effectuées à l'aide de fonctions issues de l'environnement tidyverse, et plus particulièrement du \emph{package} \{\texttt{dplyr}\}. Les descriptionsdes fonctions du \emph{package} \{\texttt{dplyr}\} sont fortement inspirées de la \href{https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html}{vignette du \emph{package}}.

\hypertarget{lopuxe9rateur-pipe}{%
\subsubsection{L'opérateur Pipe}\label{lopuxe9rateur-pipe}}

Avant de commencer à présenter les manipulations de données, il peut être intéressant d'introduire un opérateur : Pipe (\texttt{\%\textgreater{}\%}). Cet opérateur provient du \emph{package} \{\texttt{magrittr}\}. Avant de présenter cet opérateur en soi, et afin de montrer son utilité, quelques exemples ne l'\emph{utilisant pas} sont présentés. Les explications sont issues de celles de Grolemund and Wickham (\protect\hyperlink{ref-grolemund_2018_r}{2018}).

Admettons qu'il soit nécessaire d'effectuer plusieurs opérations à la suite, sur un tableau de données. Par exemple, considérons un tableau dont chaque ligne contient les ventes mensuelles (en colonnes, une par mois) des bars du Cours Julien à Marseille (en lignes) et que l'on souhaite réaliser les opérations suivantes :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Calculer la moyenne du chiffre d'affaires (CA) à l'année pour chaque bar ;
\item
  Ordonner les observations par valeurs croissante des moyennes ;
\item
  Afficher le top 5 des bars avec le plus gros CA.
\end{enumerate}

Nous allons présenter trois manières différentes de procéder, puis nous regarderons la solution avec le fameux opérateur pipe dont on tait encore ici l'utilité (quel suspens !).

\emph{Première méthode}

La première méthode consiste à *sauvegarder un nouvel objet à chaque étape (inutile de tenter d'évaluer le code qui suit, il ne fonctionnera pas : il s'agit d'un exemple totalement fictif) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{calcul}\NormalTok{(ca\_bars\_cours\_ju, }\DataTypeTok{type =} \StringTok{"moyenne"}\NormalTok{)}
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ordonner}\NormalTok{(top\_ca\_bars\_anuel\_}\DecValTok{2}\NormalTok{,}
                            \DataTypeTok{type =} \StringTok{"decroissantes"}\NormalTok{, }\DataTypeTok{variable =} \StringTok{"ca\_annuel"}\NormalTok{)}
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{head}\NormalTok{(top\_ca\_bars\_anuel\_}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Cette manière de faire requière de créer de nombreux objets intermédiaires avant d'arriver au résultat. On peut noter que le nom de ces objets intermédiaires peut ne pas être facile à trouver/comprendre. Toutefois, s'il est possible de trouver des noms sensés, cette méthode peut être adaptée à la situation. On note également que le code devient plus difficile à lire du fait des nombreux noms de variables inintéressantes.

\begin{remarque}
Si le tableau initial contient un volume de données importantes, la création des objets intermédiaire n'occupera pas un espace en mémoire important (R gère cela plutôt bien).
\end{remarque}

\emph{Deuxième méthode}

La deuxième méthode consiste à écraser l'objet original à chaque étape :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{calcul}\NormalTok{(ca\_bars\_cours\_ju, }\DataTypeTok{type =} \StringTok{"moyenne"}\NormalTok{)}
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ordonner}\NormalTok{(top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{,}
                            \DataTypeTok{type =} \StringTok{"decroissantes"}\NormalTok{, }\DataTypeTok{variable =} \StringTok{"ca\_annuel"}\NormalTok{)}
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{head}\NormalTok{(top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si cette solution est moins pénible à rédiger que la précédente, on peut noter qu'elle ne facilite toutefois pas le debogage et que le nom de l'objet modifié a été inscrit 5 fois (et vient donc perturber la lecture rapide du code).

\emph{Troisième méthode}

La troisième méthode, absolument hideuse à mes yeux (celle par laquelle j'ai commencé il y a quelques années, \emph{mea culpa}), consiste à rédiger une composition de fonction :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{head}\NormalTok{(}
    \KeywordTok{ordonner}\NormalTok{(}
      \KeywordTok{calcul}\NormalTok{(}
\NormalTok{        ca\_bars\_cours\_ju, }\DataTypeTok{type =} \StringTok{"moyenne"}\NormalTok{),}
      \DataTypeTok{type =} \StringTok{"decroissantes"}\NormalTok{, }\DataTypeTok{variable =} \StringTok{"ca\_annuel"}
\NormalTok{    ), }
    \DecValTok{5}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

Non seulement le temps de rédaction de ce type de code peut être long, mais la lecture du code produit est de surcroît ardue : il faut lire de l'intérieur vers l'extérieur, ce qui est d'autant plus difficile que les arguments de chaque fonction sont éloignés du nom de la fonction.

\emph{Roulements de tambour : l'opérateur Pipe}

L'opérateur permet de réaliser l'opération chaînée de la manière suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{ca\_bars\_cours\_ju }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{calcul}\NormalTok{(}\DataTypeTok{type =} \StringTok{"moyenne"}\NormalTok{) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{ordonner}\NormalTok{(}\DataTypeTok{type =} \StringTok{"decroissantes"}\NormalTok{, }\DataTypeTok{variable =} \StringTok{"ca\_annuel"}\NormalTok{) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{head}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Le membre à gauche de l'opérateur est donné comme premier argument de la fonction à droite de l'opérateur.

Avec cette solution, la lecture est rapide pour une personne humaine et le débogage est facilité. Attention à veiller à ne pas enchaîner de trop nombreuses opérations qui feraient perdre ces avantages.

Si on souhaite appeler explicitement le membre de gauche, on peut utiliser le point \texttt{.} comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{top\_ca\_bars\_anuel\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{ca\_bars\_cours\_ju }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{calcul}\NormalTok{(}\DataTypeTok{donnes =}\NormalTok{ ., }\DataTypeTok{type =} \StringTok{"moyenne"}\NormalTok{) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{ordonner}\NormalTok{(}\DataTypeTok{donnees =}\NormalTok{ ., }\DataTypeTok{type =} \StringTok{"decroissantes"}\NormalTok{, }\DataTypeTok{variable =} \StringTok{"ca\_annuel"}\NormalTok{) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{head}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ ., }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Comme cet opérateur fait partie de l'environnement \texttt{tidyverse} et que la majorité des fonctions admettent en premier argument les données, il n'est pas nécessaire de rajouter le point au premier argument de la fonction à droite de l'opérateur.

Il convient de préciser que si la fonction à droite du Pipe n'admet pas pour premier argument les données, il est nécessaire de préciser l'argument de la fonction qui recevra les données, comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{donnees }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{fonction}\NormalTok{(}\DataTypeTok{premier\_argument =} \StringTok{"foo"}\NormalTok{, }\DataTypeTok{donnees =}\NormalTok{ .)}
\end{Highlighting}
\end{Shaded}

\hypertarget{suxe9lection}{%
\subsubsection{Sélection}\label{suxe9lection}}

Dans la Section~\ref{manip-acces}, il a été vu que l'accès aux données d'un \emph{tibble} peut se faire à l'aide du système d'indexation ou bien par celui de nommage, en utilisant la fonction \texttt{{[}()}. Le \emph{package} \texttt{dplyr} propose une autre manière de procéder pour sélectionner des colonnes, ou pour filtrer les données. Ces méthodes ont le mérite d'être faciles à lire. Reprenons le \emph{tibble} donné en exemple dans la Section~\ref{manip-acces}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{femmes \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{height =}\KeywordTok{c}\NormalTok{(}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{, }\DecValTok{63}\NormalTok{, }\DecValTok{64}\NormalTok{, }\DecValTok{65}\NormalTok{, }\DecValTok{66}\NormalTok{,}
            \DecValTok{67}\NormalTok{, }\DecValTok{68}\NormalTok{,}\DecValTok{69}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{72}\NormalTok{),}
  \DataTypeTok{weight =}\KeywordTok{c}\NormalTok{(}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{, }\DecValTok{129}\NormalTok{, }\DecValTok{132}\NormalTok{, }\DecValTok{135}\NormalTok{,}
            \DecValTok{139}\NormalTok{,}\DecValTok{142}\NormalTok{, }\DecValTok{146}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{154}\NormalTok{, }\DecValTok{159}\NormalTok{, }\DecValTok{164}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

La sélection des colonnes se fait en utilisant la fonction \texttt{select()}. On peut noter que le nom des colonnes ne doit pas être entouré de guillemets. Le premier argument correspond au \emph{tibble}, le second et les suivants à la ou les colonnes désirées. L'odre d'apparition des colonnes correspond à celui fourni à la fonction \texttt{select()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{select}\NormalTok{(femmes, height)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 15 x 1
##    height
##     <dbl>
##  1     58
##  2     59
##  3     60
##  4     61
##  5     62
##  6     63
##  7     64
##  8     65
##  9     66
## 10     67
## 11     68
## 12     69
## 13     70
## 14     71
## 15     72
\end{lstlisting}

Si le nom d'une colonne ne respecte pas les conventions de nommage, il est possible d'y accéder avec \texttt{select()} en entourant le nom de la colonne d'accents graves :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\StringTok{\textasciigrave{}}\DataTypeTok{Un nom}\StringTok{\textasciigrave{}}\NormalTok{ =}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\StringTok{\textasciigrave{}}\DataTypeTok{Un autre}\StringTok{\textasciigrave{}}\NormalTok{ =}\StringTok{ }\NormalTok{LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}
\KeywordTok{select}\NormalTok{(tb\_}\DecValTok{2}\NormalTok{, }\StringTok{\textasciigrave{}}\DataTypeTok{Un nom}\StringTok{\textasciigrave{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 1
##   `Un nom`
##      <int>
## 1        1
## 2        2
## 3        3
\end{lstlisting}

Il arrive de vouloir extraire une variable par son nom, ce dernier étant le contenu d'une variable externe (dans une boucle par exemple). La pratique suivante n'est pas recommandée, car ambigüe :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nom\_variable \textless{}{-}}\StringTok{ "x"}
\KeywordTok{select}\NormalTok{(tb, nom\_variable)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 1
##   x        
##   <list>   
## 1 <dbl [1]>
## 2 <dbl [1]>
## 3 <dbl [1]>
\end{lstlisting}

On peut aussi noter, à travers l'exemple suivant, que le résultats obtenu n'est pas nécessairement celui attendu (le nom de la colonne et le nom de la variable qui contient la chaîne de caractères sont identiques) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nom\_variable \textless{}{-}}\StringTok{ "x"}
\NormalTok{tb\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{nom\_variable =} \KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{,}\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{), }\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\KeywordTok{select}\NormalTok{(tb\_}\DecValTok{2}\NormalTok{, nom\_variable)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 1
##   nom_variable
##   <chr>       
## 1 A           
## 2 B           
## 3 C
\end{lstlisting}

Une solution consiste à faire précéder le nom de la variable qui contient le nom de la (ou les) colonne(s) que l'on souhaite sélectionner :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{select}\NormalTok{(tb\_}\DecValTok{2}\NormalTok{, }\OperatorTok{!!}\NormalTok{nom\_variable)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 1
##       x
##   <int>
## 1     1
## 2     2
## 3     3
\end{lstlisting}

Pour \emph{retirer une colonne}, il suffit de faire précéder le nom de la colonne par le signe moins :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{), }\DataTypeTok{y =}\NormalTok{ x}\OperatorTok{\^{}}\DecValTok{2}\NormalTok{, }\DataTypeTok{z =}\NormalTok{ LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{], }\DataTypeTok{t =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{])}
\KeywordTok{select}\NormalTok{(tb, }\OperatorTok{{-}}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 3
##       y z     t    
##   <dbl> <chr> <chr>
## 1     1 A     a    
## 2     4 B     b    
## 3     9 C     c    
## 4    16 D     d
\end{lstlisting}

Pour \emph{retirer plusieurs colonnes}, il suffit de placer les noms de colonnes dans un vecteur à l'aide de la fonction c() et de faire précéder l'appel de cette fonction du signe moins :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{select}\NormalTok{(tb, }\OperatorTok{{-}}\KeywordTok{c}\NormalTok{(x, z))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 2
##       y t    
##   <dbl> <chr>
## 1     1 a    
## 2     4 b    
## 3     9 c    
## 4    16 d
\end{lstlisting}

ou de manière équivalente, en listant chaque variable à retirer et en les faisant précéder du signe moins :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{select}\NormalTok{(tb, }\OperatorTok{{-}}\NormalTok{x, }\OperatorTok{{-}}\NormalTok{z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 2
##       y t    
##   <dbl> <chr>
## 1     1 a    
## 2     4 b    
## 3     9 c    
## 4    16 d
\end{lstlisting}

Pour \emph{sélectionner des lignes}, la fonction \texttt{slice()} du \emph{package} \{\texttt{dplyr}\} attend de recevoir les indices des lignes à extraire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{), }\DataTypeTok{z =}\NormalTok{ LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{], }\DataTypeTok{t =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{])}
\KeywordTok{slice}\NormalTok{(tb, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 3
##       x z     t    
##   <int> <chr> <chr>
## 1     1 A     a    
## 2     3 C     c    
## 3     4 D     d
\end{lstlisting}

\begin{remarque}
La numérotation des lignes a été changée, elle a été recommencée à zéro.
\end{remarque}
Si la fonction \texttt{slice()} reçoit des entiers négatifs, les lignes dont l'indice est donné par la valeur absolue de ces entiers seront retirées :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{), }\DataTypeTok{z =}\NormalTok{ LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{], }\DataTypeTok{t =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{])}
\KeywordTok{slice}\NormalTok{(tb, }\OperatorTok{{-}}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 1 x 3
##       x z     t    
##   <int> <chr> <chr>
## 1     2 B     b
\end{lstlisting}

\hypertarget{filtrage}{%
\subsubsection{Filtrage}\label{filtrage}}

Le filtrage par masque a été abordé dans la Section~\ref{manip-acces}. Encore une fois, le \emph{package} \{\texttt{dplyr}\} propose une fonction très simple d'emploi pour sélectionner des lignes : \texttt{filter()}. Le premier argument est le nom du \emph{tibble}, le second et les suivants correspondent aux expressions à évaluer à l'intérieur du \texttt{tibble}. Il est possible de fournir une expression logique complèxe au deuxième argument ou aux suivants. S'il y a plus de deux arguments, une expression logique sera constuite avec les arguments à partir du deuxième, en les liant par un ET logique.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Les femmes dont la taille vaut exactement 60 pouces}
\NormalTok{femmes }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(height }\OperatorTok{==}\StringTok{ }\DecValTok{60}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 1 x 2
##   height weight
##    <dbl>  <dbl>
## 1     60    120
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Les femmes dont la masse vaut plus de 120 libres}
\CommentTok{\# et dont la taille est inférieure ou égale à 62 pouces}
\NormalTok{femmes }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(weight }\OperatorTok{\textgreater{}}\StringTok{ }\DecValTok{120}\NormalTok{, height }\OperatorTok{\textless{}=}\StringTok{ }\DecValTok{62}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 2
##   height weight
##    <dbl>  <dbl>
## 1     61    123
## 2     62    126
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# De manière équivalente :}
\NormalTok{femmes }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(weight }\OperatorTok{\textgreater{}}\StringTok{ }\DecValTok{120} \OperatorTok{\&}\StringTok{ }\NormalTok{height }\OperatorTok{\textless{}=}\StringTok{ }\DecValTok{62}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 2
##   height weight
##    <dbl>  <dbl>
## 1     61    123
## 2     62    126
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Les femmes dont la masse vaut 150 ou 159 livres}
\CommentTok{\# ou dont la taille est égale à 62 pouces}
\NormalTok{femmes }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(weight }\OperatorTok{\%in\%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{150}\NormalTok{,}\DecValTok{159}\NormalTok{) }\OperatorTok{|}\StringTok{ }\NormalTok{height }\OperatorTok{==}\StringTok{ }\DecValTok{62}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 2
##   height weight
##    <dbl>  <dbl>
## 1     62    126
## 2     69    150
## 3     71    159
\end{lstlisting}

\hypertarget{retirer-les-valeurs-dupliquuxe9es}{%
\subsubsection{Retirer les valeurs dupliquées}\label{retirer-les-valeurs-dupliquuxe9es}}

Pour se séparer des observations contenues plusieurs fois dans un \emph{tibble}, on utilise la fonction \texttt{unique()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Les observations 1 et 7, ainsi que 3 et 6 sont dupliquées}
\NormalTok{df \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ letters[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{)],}
                 \DataTypeTok{y =}\NormalTok{ letters[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{)])}

\KeywordTok{unique}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 2
##   x     y    
##   <chr> <chr>
## 1 a     a    
## 2 b     e    
## 3 c     b    
## 4 a     d    
## 5 d     c
\end{lstlisting}

\hypertarget{modification-des-colonnes}{%
\subsubsection{Modification des colonnes}\label{modification-des-colonnes}}

La Section~\ref{manip-acces} a posé les bases au sujet de la modification d'objets. Cette section apporte quelques informations supplémentaires.

Une des premières modifications que l'on peut apporter à un \emph{tibble} est de renommer ses colonnes. On peut s'en sortir sans fournir trop d'efforts à l'aide de la fonction \texttt{colnames()} et de la flèche d'assignation :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{colnames}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "height" "weight"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{colnames}\NormalTok{(femmes)[}\KeywordTok{which}\NormalTok{(}\KeywordTok{colnames}\NormalTok{(femmes) }\OperatorTok{==}\StringTok{ "height"}\NormalTok{)] \textless{}{-}}\StringTok{ "taille"}
\KeywordTok{colnames}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "taille" "weight"
\end{lstlisting}

Cependant, cette syntaxe est assez lourde. La fonction \texttt{rename()} du \emph{package} \{\texttt{dplyr}\} propose de réaliser la même tâche de manière plus lisible :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{femmes \textless{}{-}}
\StringTok{  }\NormalTok{femmes }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{rename}\NormalTok{(}\DataTypeTok{masse =}\NormalTok{ weight)}
\KeywordTok{colnames}\NormalTok{(femmes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "taille" "masse"
\end{lstlisting}

Pour renommer plusieurs colonnes avec la fonction \texttt{rename()}, il suffit d'ajouter des arguments :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rename}\NormalTok{(femmes, }\DataTypeTok{poids =}\NormalTok{ masse, }\DataTypeTok{hauteur =}\NormalTok{ taille)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 15 x 2
##    hauteur poids
##      <dbl> <dbl>
##  1      58   115
##  2      59   117
##  3      60   120
##  4      61   123
##  5      62   126
##  6      63   129
##  7      64   132
##  8      65   135
##  9      66   139
## 10      67   142
## 11      68   146
## 12      69   150
## 13      70   154
## 14      71   159
## 15      72   164
\end{lstlisting}

On peut noter qu'avec la fonction \texttt{select()}, il est possible de sélectionner une variable et de la renommer directement :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{femmes }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{select}\NormalTok{(}\DataTypeTok{poids =}\NormalTok{ masse, }\DataTypeTok{hauteur =}\NormalTok{ taille) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{head}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 2
##   poids hauteur
##   <dbl>   <dbl>
## 1   115      58
## 2   117      59
\end{lstlisting}

Pour ajouter une colonne, ou pour appliquer des changements à tous les éléments d'une colonne, on peut utiliser la flèche d'assignation :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Nombre de chomeurs et d\textquotesingle{}actifs en millions de personnes}
\NormalTok{chomeurs \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{annee =} \DecValTok{2012}\OperatorTok{:}\DecValTok{2008}\NormalTok{,}
\DataTypeTok{nb\_chomeurs =} \KeywordTok{c}\NormalTok{(}\FloatTok{2.811}\NormalTok{, }\FloatTok{2.604}\NormalTok{, }\FloatTok{2.635}\NormalTok{, }\FloatTok{2.573}\NormalTok{, }\FloatTok{2.064}\NormalTok{),}
\DataTypeTok{pop\_active =} \KeywordTok{c}\NormalTok{(}\FloatTok{28.328}\NormalTok{, }\FloatTok{28.147}\NormalTok{, }\FloatTok{28.157}\NormalTok{, }\FloatTok{28.074}\NormalTok{, }\FloatTok{27.813}\NormalTok{))}

\NormalTok{chomeurs}\OperatorTok{$}\NormalTok{taux\_chomage\_}\DecValTok{0}\NormalTok{ \textless{}{-}}\StringTok{ }\NormalTok{chomeurs}\OperatorTok{$}\NormalTok{nb\_chomeurs }\OperatorTok{/}\StringTok{ }\NormalTok{chomeurs}\OperatorTok{$}\NormalTok{pop\_active }\OperatorTok{*}\StringTok{ }\DecValTok{100}
\end{Highlighting}
\end{Shaded}

Comme on peut le voir, il est assez laborieux de devoir réécrire le nom du \emph{tibble} pour accéder à ses colonnes afin de faire des modifications ou des créations de variables (bien qu'avec uniquement deux variables à utiliser, cela reste encore faisable sans trop de pénibilité). Le \emph{package} \{\texttt{dplyr}\} propose la fonction \texttt{mutate()} pour créer ou modifier une ou plusieurs colonnes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomeurs \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{chomeurs }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{tx\_chomage\_1 =}\NormalTok{ nb\_chomeurs}\OperatorTok{/}\NormalTok{pop\_active}\OperatorTok{*}\DecValTok{100}\NormalTok{,}
         \DataTypeTok{log\_nb\_chomeurs =} \KeywordTok{log}\NormalTok{(nb\_chomeurs))}
\NormalTok{chomeurs}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 6
##   annee nb_chomeurs pop_active taux_chomage_0 tx_chomage_1 log_nb_chomeurs
##   <int>       <dbl>      <dbl>          <dbl>        <dbl>           <dbl>
## 1  2012        2.81       28.3           9.92         9.92           1.03 
## 2  2011        2.60       28.1           9.25         9.25           0.957
## 3  2010        2.64       28.2           9.36         9.36           0.969
## 4  2009        2.57       28.1           9.17         9.17           0.945
## 5  2008        2.06       27.8           7.42         7.42           0.725
\end{lstlisting}

Avec la fonction \texttt{mutate()}, il est possible de faire référence directement à la variable créé :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomeurs \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{chomeurs }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{tx\_chomage\_2 =}\NormalTok{ nb\_chomeurs}\OperatorTok{/}\NormalTok{pop\_active}\OperatorTok{*}\DecValTok{100}\NormalTok{,}
         \DataTypeTok{log\_tx\_chomage =} \KeywordTok{log}\NormalTok{(tx\_chomage\_}\DecValTok{2}\NormalTok{))}
\NormalTok{chomeurs}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 8
##   annee nb_chomeurs pop_active taux_chomage_0 tx_chomage_1 log_nb_chomeurs
##   <int>       <dbl>      <dbl>          <dbl>        <dbl>           <dbl>
## 1  2012        2.81       28.3           9.92         9.92           1.03 
## 2  2011        2.60       28.1           9.25         9.25           0.957
## 3  2010        2.64       28.2           9.36         9.36           0.969
## 4  2009        2.57       28.1           9.17         9.17           0.945
## 5  2008        2.06       27.8           7.42         7.42           0.725
## # ... with 2 more variables: tx_chomage_2 <dbl>, log_tx_chomage <dbl>
\end{lstlisting}

Pour modifier une colonne, il suffit de créer une colonne portant le même nom :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomeurs }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{annee =}\NormalTok{ annee }\OperatorTok{/}\StringTok{ }\DecValTok{1000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 8
##   annee nb_chomeurs pop_active taux_chomage_0 tx_chomage_1 log_nb_chomeurs
##   <dbl>       <dbl>      <dbl>          <dbl>        <dbl>           <dbl>
## 1  2.01        2.81       28.3           9.92         9.92           1.03 
## 2  2.01        2.60       28.1           9.25         9.25           0.957
## 3  2.01        2.64       28.2           9.36         9.36           0.969
## 4  2.01        2.57       28.1           9.17         9.17           0.945
## 5  2.01        2.06       27.8           7.42         7.42           0.725
## # ... with 2 more variables: tx_chomage_2 <dbl>, log_tx_chomage <dbl>
\end{lstlisting}

Pour conserver uniquement les variables nouvellement créées, on peut utiliser la fonction \texttt{transmute()} du \emph{package} \{\texttt{dplyr}\} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomeurs }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{transmute}\NormalTok{(}\DataTypeTok{annee =}\NormalTok{ annee }\OperatorTok{/}\StringTok{ }\DecValTok{1000}\NormalTok{,}
            \DataTypeTok{tx\_chomage =}\NormalTok{ nb\_chomeurs}\OperatorTok{/}\NormalTok{pop\_active}\OperatorTok{*}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 2
##   annee tx_chomage
##   <dbl>      <dbl>
## 1  2.01       9.92
## 2  2.01       9.25
## 3  2.01       9.36
## 4  2.01       9.17
## 5  2.01       7.42
\end{lstlisting}

Il existe une méthode qui à première vue semble agréable à utiliser : la fonction \texttt{attach()}, qui comme son nom l'indique, détache le tableau de données, c'est-à-dire rend les colonnes qui le composent visibles dans l'espace de travail. La fonction \texttt{detach()} produit l'effet inverse, et masque alors de l'espace de travail les colonnes du tableau de données indiqué en argument.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(quakes)}
\NormalTok{quakes \textless{}{-}}\StringTok{ }\NormalTok{quakes[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{,]  }\CommentTok{\# On ne prend que quelques observations pour l\textquotesingle{}exemple}
\NormalTok{quakes \textless{}{-}}\StringTok{ }\KeywordTok{as\_tibble}\NormalTok{(quakes)}
\NormalTok{lat  }\CommentTok{\# lat n\textquotesingle{}est pas dans l\textquotesingle{}espace de travail}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in eval(expr, envir, enclos): objet 'lat' introuvable
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attach}\NormalTok{(quakes)}
\NormalTok{lat }\CommentTok{\# maintenant il l\textquotesingle{}est}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -20.42 -20.62 -26.00 -17.97
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{detach}\NormalTok{(quakes)}
\NormalTok{lat }\CommentTok{\# il est à nouveau masqué}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in eval(expr, envir, enclos): objet 'lat' introuvable
\end{lstlisting}

Cependant, l'utilisation de la fonction \texttt{attach()} cause bien souvent des confusions et problèmes lors de l'emploi d'autres fonctions. À éviter.

\hypertarget{tri}{%
\subsubsection{Tri}\label{tri}}

Il existe plusieurs manières de trier un tableau. Une ancienne méthode consiste à utiliser la fonction \texttt{order()}. Le \emph{package} \{\texttt{dplyr}\} propose également une solution qui s'intègre bien dans les opérations chaînées, avec la fonction \texttt{arrange()}.

Il ne semble pas inutile de présenter \texttt{order()}, dans la mesure où cette fonction peut parfois être utile sur des vecteurs en dehors des tableaux de données.

Il est aisé de trier un \emph{tibble} par ordre croissant ou décroissant d'une ou plusieurs de ses colonnes. Pour ce faire, on peut utiliser la fonction \texttt{order()}, qui retourne les rangs de classement des éléments du ou des arguments. En cas d'\_ex æquo, les rangs sont classés par ordre d'apparition dans le \emph{tibble}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{nom =} \KeywordTok{c}\NormalTok{(}\StringTok{"Durand"}\NormalTok{, }\StringTok{"Martin"}\NormalTok{, }\StringTok{"Martin"}\NormalTok{, }\StringTok{"Martin"}\NormalTok{, }\StringTok{"Durand"}\NormalTok{),}
  \DataTypeTok{prenom =} \KeywordTok{c}\NormalTok{(}\StringTok{"Sonia"}\NormalTok{, }\StringTok{"Serge"}\NormalTok{, }\StringTok{"Julien{-}Yacine"}\NormalTok{, }\StringTok{"Victor"}\NormalTok{, }\StringTok{"Emma"}\NormalTok{),}
  \DataTypeTok{note =} \KeywordTok{c}\NormalTok{(}\DecValTok{23}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{19}\NormalTok{))}
\CommentTok{\# Ordonner par notes décroissantes}
\KeywordTok{order}\NormalTok{(tb}\OperatorTok{$}\NormalTok{note, }\DataTypeTok{decreasing =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 5 2 3 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tb[}\KeywordTok{order}\NormalTok{(tb}\OperatorTok{$}\NormalTok{note), ]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 3
##   nom    prenom         note
##   <chr>  <chr>         <dbl>
## 1 Martin Julien-Yacine    17
## 2 Martin Victor           17
## 3 Martin Serge            18
## 4 Durand Emma             19
## 5 Durand Sonia            23
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ordonner par ordre alphabétique des noms puis des prénoms}
\NormalTok{tb[}\KeywordTok{with}\NormalTok{(tb, }\KeywordTok{order}\NormalTok{(nom, prenom)), ]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 3
##   nom    prenom         note
##   <chr>  <chr>         <dbl>
## 1 Durand Emma             19
## 2 Durand Sonia            23
## 3 Martin Julien-Yacine    17
## 4 Martin Serge            18
## 5 Martin Victor           17
\end{lstlisting}

\begin{remarque}
La fonction \texttt{sort()} retourne un vecteur trié par valeurs croissantes ou décroissantes. La fonction \texttt{order()} retourne les rangs du classement.
\end{remarque}

La fonction \texttt{arrange()} du \emph{package} \{\texttt{dplyr}\} permet aussi de trier un tableau de données. Son utilisation semble plus aisée pour certains, surtout lorsque le tri s'effectue en fonction de plusieurs colonnes. Comme il n'y a pas de l'argument \texttt{decreasing} deux méthodes sont possibles :

\begin{itemize}
\tightlist
\item
  faire appel à la fonction \texttt{desc()}, elle aussi contenue dans le \emph{package} \{\texttt{dplyr}\}, qui permet de trier le vecteur donné en argument par ordre de valeurs décroissantes ;
\item
  faire préceder le nom de la colonne par le signe \texttt{-} si les valeurs de la colonne sont numériques.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ordonner par notes décroissantes}
\NormalTok{tb }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{arrange}\NormalTok{(}\OperatorTok{{-}}\NormalTok{note)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 3
##   nom    prenom         note
##   <chr>  <chr>         <dbl>
## 1 Durand Sonia            23
## 2 Durand Emma             19
## 3 Martin Serge            18
## 4 Martin Julien-Yacine    17
## 5 Martin Victor           17
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ordonner par ordre alphabétique des noms puis inverse des prénoms}
\NormalTok{tb }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{arrange}\NormalTok{(nom, }\KeywordTok{desc}\NormalTok{(prenom))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 5 x 3
##   nom    prenom         note
##   <chr>  <chr>         <dbl>
## 1 Durand Sonia            23
## 2 Durand Emma             19
## 3 Martin Victor           17
## 4 Martin Serge            18
## 5 Martin Julien-Yacine    17
\end{lstlisting}

\hypertarget{jointures}{%
\subsubsection{Jointures}\label{jointures}}

Deux fonctions permettent de juxtaposer deuxtableaux de données ou plus entre-eux (cela fonctionne aussi avec des matrices) : \texttt{cbind()} et \texttt{rbind()}. La première fusionne les colonnes (place les tableaux côte-à-côte) tandis que la seconde fusionne les lignes (empile les tableaux les uns sur les autres). Il faut toutefois veiller à ce que le nombre de lignes des éléments passés en argument de \texttt{cbind()} correspondent, et que le nombre de colonnes de ceux passés en argument de \texttt{rbind()} correspondent aussi. De plus, lors de l'utilisation de \texttt{rbind()}, le nom des colonnes doit correspondre.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(A \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x1 =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{{-}1}\NormalTok{), }\DataTypeTok{x2 =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 2
##      x1    x2
##   <dbl> <dbl>
## 1     1     0
## 2    -1     3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(B \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x1 =} \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{), }\DataTypeTok{x2 =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 2
##      x1    x2
##   <dbl> <dbl>
## 1     3     1
## 2     2     1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(C \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x3 =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 1
##      x3
##   <dbl>
## 1     0
## 2     3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rbind}\NormalTok{(A,B)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 2
##      x1    x2
##   <dbl> <dbl>
## 1     1     0
## 2    -1     3
## 3     3     1
## 4     2     1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cbind}\NormalTok{(A,B)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   x1 x2 x1 x2
## 1  1  0  3  1
## 2 -1  3  2  1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cbind}\NormalTok{(A,B,C)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   x1 x2 x1 x2 x3
## 1  1  0  3  1  0
## 2 -1  3  2  1  3
\end{lstlisting}

Toutefois, lors de la fusion de tableaux de données, l'emploi de la fonction \texttt{cbind()} n'est pas très pratique, puisque s'il existe une colonne identique aux tableaux de données à fusionner, elle sera dupliquée dans le résultat de la fusion.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(pib \textless{}{-}}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{annee =} \DecValTok{2010}\OperatorTok{:}\DecValTok{2013}\NormalTok{, }\DataTypeTok{pib =} \KeywordTok{c}\NormalTok{(}\FloatTok{1998.5}\NormalTok{, }\FloatTok{2059.3}\NormalTok{, }\FloatTok{2091.1}\NormalTok{, }\FloatTok{2113.7}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   annee    pib
## 1  2010 1998.5
## 2  2011 2059.3
## 3  2012 2091.1
## 4  2013 2113.7
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(importations \textless{}{-}}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{annee =} \DecValTok{2010}\OperatorTok{:}\DecValTok{2013}\NormalTok{, }\DataTypeTok{importations =} \KeywordTok{c}\NormalTok{(}\FloatTok{558.1}\NormalTok{, }\FloatTok{625.3}\NormalTok{, }\FloatTok{628.5}\NormalTok{, }\FloatTok{629.1}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   annee importations
## 1  2010        558.1
## 2  2011        625.3
## 3  2012        628.5
## 4  2013        629.1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cbind}\NormalTok{(pib, importations)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   annee    pib annee importations
## 1  2010 1998.5  2010        558.1
## 2  2011 2059.3  2011        625.3
## 3  2012 2091.1  2012        628.5
## 4  2013 2113.7  2013        629.1
\end{lstlisting}

De plus, le but d'une telle opération de juxtaposition se révèle utile en économétrie surtout lorsque l'on désire apparier des données de sources différentes. Il faut donc, avec \texttt{cbind()}, s'assurer au préalable que les individus du premier tableau apparaissent dans le même ordre que ceux du second. Cette étape est assez pénible à réaliser, et peut être évitée à l'aide des fonctions du \emph{package} \{\texttt{dplyr}\}. Ce \emph{package} propose des fonctions pour joindre deux tableaux de données. Ces fonctions partagent une syntaxe commune : \texttt{xx\_join(x,\ y,\ by\ =\ NULL,\ copy\ =\ FALSE,\ ...)}, où \texttt{x} et \texttt{y} sont les tableaux à joindre, \texttt{by} est un vecteur de chaînes de caractères contenant le nom des variables permettant la jointure (si la valeur est \texttt{NULL}, ce qui est le cas par défaut, la jointure se fera à l'aide des variables portant le même nom dans les deux tables).

Les différentes fonctions de jointure sont les suivantes :

---\texttt{inner\_join()} : toutes les lignes de \texttt{x} pour lesquelles il y a des valeurs correspondantes dans \texttt{y}, et toutes les colonnes de \texttt{x} et \texttt{y}. S'il y a plusieurs correspondances dans les noms entre \texttt{x} et \texttt{y}, toutes les combinaisons possibles sont retournées ;

---\texttt{left\_join()}: toutes les lignes de \texttt{x}, et toutes les colonnes de \texttt{x} et \texttt{y}. Les lignes dans \texttt{x} pour lesquelles il n'y a pas de correspondance dans \texttt{y} auront des valeurs \texttt{NA} dans les nouvelles colonnes. S'il y a plusieurs correspondances dans les noms entre \texttt{x} et \texttt{y}, toutesles combinaisons sont retournées ;

---\texttt{right\_join()}: toutes les lignes de \texttt{y}, et toutes les colonnes de \texttt{x} et \texttt{y}. Les lignes dans \texttt{y} pour lesquelles il n'y a pas de correspondance dansxauront des valeurs \texttt{NA} dans les nouvelles colonnes. S'il y a plusieurs correspondances dans les noms entre \texttt{x} et \texttt{y}, toutesles combinaisons sont retournées ;

---\texttt{semi\_join()}: toutes les lignes de \texttt{x} pour lesquelles il y a des valeurs correspondantes dans \texttt{y}, en ne conservant uniquement les colonnes de \texttt{x};

---\texttt{anti\_join()}: toutes les lignes dexpour lesquelles il n'y a pas de correspondances dans \texttt{y}, en ne conservant que les colonnes de \texttt{x}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exportations \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{year =} \DecValTok{2011}\OperatorTok{:}\DecValTok{2013}\NormalTok{, }
  \DataTypeTok{exportations =} \KeywordTok{c}\NormalTok{(}\FloatTok{572.6}\NormalTok{, }\FloatTok{587.3}\NormalTok{, }\FloatTok{597.8}\NormalTok{))}
\NormalTok{importations \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{annee =} \DecValTok{2010}\OperatorTok{:}\DecValTok{2012}\NormalTok{,}
  \DataTypeTok{importations =} \KeywordTok{c}\NormalTok{(}\FloatTok{558.1}\NormalTok{, }\FloatTok{625.3}\NormalTok{, }\FloatTok{628.5}\NormalTok{))}

\NormalTok{exportations ; importations}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 2
##    year exportations
##   <int>        <dbl>
## 1  2011         573.
## 2  2012         587.
## 3  2013         598.
\end{lstlisting}

\begin{lstlisting}
## # A tibble: 3 x 2
##   annee importations
##   <int>        <dbl>
## 1  2010         558.
## 2  2011         625.
## 3  2012         628.
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exportations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{inner\_join}\NormalTok{(importations, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{ =}\StringTok{ "annee"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 3
##    year exportations importations
##   <int>        <dbl>        <dbl>
## 1  2011         573.         625.
## 2  2012         587.         628.
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exportations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{left\_join}\NormalTok{(importations, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{ =}\StringTok{ "annee"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 3
##    year exportations importations
##   <int>        <dbl>        <dbl>
## 1  2011         573.         625.
## 2  2012         587.         628.
## 3  2013         598.          NA
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exportations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{right\_join}\NormalTok{(importations, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{ =}\StringTok{ "annee"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 3
##    year exportations importations
##   <int>        <dbl>        <dbl>
## 1  2011         573.         625.
## 2  2012         587.         628.
## 3  2010          NA          558.
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exportations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{semi\_join}\NormalTok{(importations, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{ =}\StringTok{ "annee"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 2
##    year exportations
##   <int>        <dbl>
## 1  2011         573.
## 2  2012         587.
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exportations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{anti\_join}\NormalTok{(importations, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{ =}\StringTok{ "annee"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 1 x 2
##    year exportations
##   <int>        <dbl>
## 1  2013         598.
\end{lstlisting}

\hypertarget{agruxe9gation}{%
\subsubsection{Agrégation}\label{agruxe9gation}}

Il arrive de vouloir agréger les valeurs d'une variable, pour passer par exemple d'une dimension trimestrielle à annuelle. Avec des observations spatiales, cela peut aussi être le cas, comme par exemple lorsque l'on dispose de données à l'échelle des départements et que l'on souhaite connaître les valeurs agrégées à l'échelle des régions.

Le \emph{package} \{\texttt{dplyr}\} propose une fonction simple d'utilisation : \texttt{summarise()}. Elle permet de réduire une colonne d'un tableau de données à une seule observation. On lui fournit un tableau de données en premier argument, et une ou plusieurs opérations à réaliser sur le tableau en arguments suivants.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Nombre d\textquotesingle{}ingenieurs et cadres au chômage}
\NormalTok{chomage \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{region =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\StringTok{"Bretagne"}\NormalTok{, }\DecValTok{4}\NormalTok{), }\KeywordTok{rep}\NormalTok{(}\StringTok{"Corse"}\NormalTok{, }\DecValTok{2}\NormalTok{)), }\DecValTok{2}\NormalTok{),}
  \DataTypeTok{departement =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Cotes{-}d\textquotesingle{}Armor"}\NormalTok{, }\StringTok{"Finistere"}\NormalTok{,}
                      \StringTok{"Ille{-}et{-}Vilaine"}\NormalTok{, }\StringTok{"Morbihan"}\NormalTok{,}
                      \StringTok{"Corse{-}du{-}Sud"}\NormalTok{, }\StringTok{"Haute{-}Corse"}\NormalTok{), }\DecValTok{2}\NormalTok{), }
  \DataTypeTok{annee =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2011}\NormalTok{, }\DecValTok{2010}\NormalTok{), }\DataTypeTok{each =} \DecValTok{6}\NormalTok{),}
  \DataTypeTok{ouvriers =} \KeywordTok{c}\NormalTok{(}\DecValTok{8738}\NormalTok{, }\DecValTok{12701}\NormalTok{, }\DecValTok{11390}\NormalTok{, }\DecValTok{10228}\NormalTok{, }\DecValTok{975}\NormalTok{, }\DecValTok{1297}\NormalTok{,}
               \DecValTok{8113}\NormalTok{, }\DecValTok{12258}\NormalTok{, }\DecValTok{10897}\NormalTok{, }\DecValTok{9617}\NormalTok{, }\DecValTok{936}\NormalTok{, }\DecValTok{1220}\NormalTok{), }
  \DataTypeTok{ingenieurs =} \KeywordTok{c}\NormalTok{(}\DecValTok{1420}\NormalTok{, }\DecValTok{2530}\NormalTok{, }\DecValTok{3986}\NormalTok{, }\DecValTok{2025}\NormalTok{, }\DecValTok{259}\NormalTok{, }\DecValTok{254}\NormalTok{,}
                 \DecValTok{1334}\NormalTok{, }\DecValTok{2401}\NormalTok{, }\DecValTok{3776}\NormalTok{, }\DecValTok{1979}\NormalTok{, }\DecValTok{253}\NormalTok{, }\DecValTok{241}\NormalTok{))}
\NormalTok{chomage}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 12 x 5
##    region   departement     annee ouvriers ingenieurs
##    <chr>    <chr>           <dbl>    <dbl>      <dbl>
##  1 Bretagne Cotes-d'Armor    2011     8738       1420
##  2 Bretagne Finistere        2011    12701       2530
##  3 Bretagne Ille-et-Vilaine  2011    11390       3986
##  4 Bretagne Morbihan         2011    10228       2025
##  5 Corse    Corse-du-Sud     2011      975        259
##  6 Corse    Haute-Corse      2011     1297        254
##  7 Bretagne Cotes-d'Armor    2010     8113       1334
##  8 Bretagne Finistere        2010    12258       2401
##  9 Bretagne Ille-et-Vilaine  2010    10897       3776
## 10 Bretagne Morbihan         2010     9617       1979
## 11 Corse    Corse-du-Sud     2010      936        253
## 12 Corse    Haute-Corse      2010     1220        241
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Moyenne de la colonne ouvriers}
\NormalTok{chomage }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{moy\_ouvriers =} \KeywordTok{mean}\NormalTok{(ouvriers),}
            \DataTypeTok{sd\_ouvriers =} \KeywordTok{sd}\NormalTok{(ouvriers),}
            \DataTypeTok{moy\_ingenieurs =} \KeywordTok{mean}\NormalTok{(ingenieurs),}
            \DataTypeTok{sd\_ingenieurs =} \KeywordTok{sd}\NormalTok{(ingenieurs))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 1 x 4
##   moy_ouvriers sd_ouvriers moy_ingenieurs sd_ingenieurs
##          <dbl>       <dbl>          <dbl>         <dbl>
## 1        7364.       4801.          1705.         1331.
\end{lstlisting}

Couplée à la fonction \texttt{group\_by()} du même \emph{package}, elle prend toute sa puissance. La fonction \texttt{group\_by()} permet de regrouper les observations d'un tableau de données en sous-groupes, qui sont créés en fonction des variables données en arguments.

Par exemple, si on désire obtenir la somme par année des colonnes \texttt{ouvriers} et \texttt{ingenieurs} du tableau \texttt{chomage} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{group\_by}\NormalTok{(annee) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{ouvriers =} \KeywordTok{sum}\NormalTok{(ouvriers),}
            \DataTypeTok{ingenieurs =} \KeywordTok{sum}\NormalTok{(ingenieurs))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 2 x 3
##   annee ouvriers ingenieurs
##   <dbl>    <dbl>      <dbl>
## 1  2010    43041       9984
## 2  2011    45329      10474
\end{lstlisting}

Si on désire que les calculs soient effectués sur les sous-groupes définis à la fois par les années et les régions, il suffit de fournir les noms de ces deux colonnes du tableau en arguments à la fonction \texttt{group\_by()} avant d'appliquer la fonction \texttt{sum()} aux colonnes contenant les valeurs numériques :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{group\_by}\NormalTok{(annee, region) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{ouvriers =} \KeywordTok{sum}\NormalTok{(ouvriers),}
            \DataTypeTok{ingenieurs =} \KeywordTok{sum}\NormalTok{(ingenieurs))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 4
## # Groups:   annee [2]
##   annee region   ouvriers ingenieurs
##   <dbl> <chr>       <dbl>      <dbl>
## 1  2010 Bretagne    40885       9490
## 2  2010 Corse        2156        494
## 3  2011 Bretagne    43057       9961
## 4  2011 Corse        2272        513
\end{lstlisting}

Attention, si des calculs sur les résultats obtenus sur des sous-groupes doivent être effectués par la suite, il faut penser à dégrouper le tableau obtenu, avec la fonction \texttt{degroup()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage }\OperatorTok{\%\textgreater{}\%}
\StringTok{  }\KeywordTok{group\_by}\NormalTok{(annee, region) }\OperatorTok{\%\textgreater{}\%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{ouvriers =} \KeywordTok{sum}\NormalTok{(ouvriers),}
            \DataTypeTok{ingenieurs =}\KeywordTok{sum}\NormalTok{(ingenieurs)) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{ungroup}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 4
##   annee region   ouvriers ingenieurs
##   <dbl> <chr>       <dbl>      <dbl>
## 1  2010 Bretagne    40885       9490
## 2  2010 Corse        2156        494
## 3  2011 Bretagne    43057       9961
## 4  2011 Corse        2272        513
\end{lstlisting}

\hypertarget{faire-pivoter-un-tableau}{%
\subsubsection{Faire pivoter un tableau}\label{faire-pivoter-un-tableau}}

Devoir faire pivoter un tableau arrive fréquemment en R, principalement pour préparer les données avant de les fournir aux fonctions permettant de réaliser des graphiques. Deux fonctions dans le \emph{package} \{\texttt{tidyr}\} sont en cours de maturation à la rédaction de ces diapositives :

\begin{itemize}
\tightlist
\item
  \texttt{pivot\_longer()} : pivoter des données d'un tableau large vers un tableau long,
\item
  \texttt{pivot\_wider()} : pivoter des données d'un tableau long vers un tableau en largeur.
\end{itemize}

Voici un tableau large :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop \textless{}{-}}
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{ville =}\KeywordTok{c}\NormalTok{ (}\StringTok{"Paris"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Lyon"}\NormalTok{, }\StringTok{"Lyon"}\NormalTok{),}
         \DataTypeTok{arrondissement =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{),}
         \DataTypeTok{pop\_municipale =}\KeywordTok{c}\NormalTok{ (}\DecValTok{17443}\NormalTok{, }\DecValTok{22927}\NormalTok{, }\DecValTok{28932}\NormalTok{, }\DecValTok{30575}\NormalTok{),}
         \DataTypeTok{pop\_totale =}\KeywordTok{c}\NormalTok{(}\DecValTok{17620}\NormalTok{, }\DecValTok{23102}\NormalTok{, }\DecValTok{29874}\NormalTok{, }\DecValTok{31131}\NormalTok{))}

\NormalTok{pop}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 4
##   ville arrondissement pop_municipale pop_totale
##   <chr>          <dbl>          <dbl>      <dbl>
## 1 Paris              1          17443      17620
## 2 Paris              2          22927      23102
## 3 Lyon               1          28932      29874
## 4 Lyon               2          30575      31131
\end{lstlisting}

Comment faire pour obtenir un tableau dans lequel chaque ligne donne la population, pour une ville, un arrondissement et indique si la valeur de la population concerne la population municipale ou totale ?

Il suffit d'utiliser \texttt{pivot\_longer()} en précisant : pour l'argument \texttt{cols}, les variables contenant les valeurs que l'on veut avoir dans la colonne unique. Eventuellement, il est possible de préciser le nom de la colonne qui indiquera le nom des colonnes d'où viennent initialement les données, en le passant à l'argument \texttt{names\_to} (par defaut : \texttt{name}). Il est également possible de préciser le nom de la colonne dans lesquelles les valeurs se trouveront en le passant à l'argument \texttt{values\_to} (par defaut : \texttt{value})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop\_long \textless{}{-}}\StringTok{ }\NormalTok{pop }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{pivot\_longer}\NormalTok{(}\DataTypeTok{cols =} \KeywordTok{c}\NormalTok{(pop\_municipale, pop\_totale),}
               \DataTypeTok{values\_to =} \StringTok{"population"}\NormalTok{,}
               \DataTypeTok{names\_to =} \StringTok{"type\_pop"}\NormalTok{)}
\NormalTok{pop\_long}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 8 x 4
##   ville arrondissement type_pop       population
##   <chr>          <dbl> <chr>               <dbl>
## 1 Paris              1 pop_municipale      17443
## 2 Paris              1 pop_totale          17620
## 3 Paris              2 pop_municipale      22927
## 4 Paris              2 pop_totale          23102
## 5 Lyon               1 pop_municipale      28932
## 6 Lyon               1 pop_totale          29874
## 7 Lyon               2 pop_municipale      30575
## 8 Lyon               2 pop_totale          31131
\end{lstlisting}

La fonction \texttt{pivot\_wider()} permet d'effectuer l'opération dans l'autre sens. Les arguments \texttt{names\_from} et \texttt{values\_from} permettent de désigner où sont les noms qui définiront les colonnes du tableau large et les valeurs associées, respectivement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop\_long }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{pivot\_wider}\NormalTok{(}\DataTypeTok{names\_from =}\NormalTok{ type\_pop, }\DataTypeTok{values\_from =}\NormalTok{ population)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 4
##   ville arrondissement pop_municipale pop_totale
##   <chr>          <dbl>          <dbl>      <dbl>
## 1 Paris              1          17443      17620
## 2 Paris              2          22927      23102
## 3 Lyon               1          28932      29874
## 4 Lyon               2          30575      31131
\end{lstlisting}

\hypertarget{stacking-et-unstacking}{%
\subsubsection{Stacking et unstacking}\label{stacking-et-unstacking}}

Pour empiler (stack) les contenus des colonnes d'un tableau de données dans un seul vecteur, R propose la fonction \texttt{stack()}. Le tableau de données retourné est composé de deux colonnes, dont la première contient les valeurs et la seconde le nom de la colonne dans le tableau de données initial. Pour réaliser l'opération inverse, on peut utiliser la fonction \texttt{unstack()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{patients \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{traitement\_1 =} \KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{7}\NormalTok{),}
         \DataTypeTok{traitement\_2 =} \KeywordTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{),}
         \DataTypeTok{traitement\_3 =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{patients}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 3 x 3
##   traitement_1 traitement_2 traitement_3
##          <dbl>        <dbl>        <dbl>
## 1            4            8            0
## 2            2            5            5
## 3            7            0            6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stack}\NormalTok{(patients)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   values          ind
## 1      4 traitement_1
## 2      2 traitement_1
## 3      7 traitement_1
## 4      8 traitement_2
## 5      5 traitement_2
## 6      0 traitement_2
## 7      0 traitement_3
## 8      5 traitement_3
## 9      6 traitement_3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unstack}\NormalTok{(}\KeywordTok{stack}\NormalTok{(patients))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   traitement_1 traitement_2 traitement_3
## 1            4            8            0
## 2            2            5            5
## 3            7            0            6
\end{lstlisting}

Le \emph{package} \texttt{tidyr} propose des fonctions intéressantes pour convertir des tableaux en longueur en tableaux en hauteur, et \texttt{vice\ versa}.

\hypertarget{data-tables}{%
\subsection{Data tables}\label{data-tables}}

Comme brièvement indiqué précédemment (à la Section~\ref{structures}), le \emph{package} \{\texttt{data.table}\} propose une autre structure de données, appelée \emph{data.table}, qui se veut être une alternative aux objets \emph{tibbles} ou \emph{data frames}. L'idée est de réduire la longueur du code, de proposer une syntatxe plus facile à écrire et lire, mais aussi (et surtout) de réduire les temps de calculs. La syntaxe se rapproche un peu du \texttt{SQL}, mais évite pas mal de lourdeurs de ce langage.

Il est plus pratique de charger le package\_:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(data.table)}
\end{Highlighting}
\end{Shaded}

\hypertarget{cruxe9ation-conversion}{%
\subsubsection{Création, conversion}\label{cruxe9ation-conversion}}

La création d'un \emph{data.table} se fait de manière analogue à ce que l'on utilise pour un \emph{tibble}, en faisant appel à la fonction \texttt{data.table()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{data.table}\NormalTok{(}\DataTypeTok{region =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\StringTok{"Bretagne"}\NormalTok{, }\DecValTok{4}\NormalTok{), }\KeywordTok{rep}\NormalTok{(}\StringTok{"Corse"}\NormalTok{, }\DecValTok{2}\NormalTok{)), }\DecValTok{2}\NormalTok{),}
             \DataTypeTok{departement =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Cotes{-}d\textquotesingle{}Armor"}\NormalTok{, }\StringTok{"Finistere"}\NormalTok{,}
                                 \StringTok{"Ille{-}et{-}Vilaine"}\NormalTok{, }\StringTok{"Morbihan"}\NormalTok{,}
                                 \StringTok{"Corse{-}du{-}Sud"}\NormalTok{, }\StringTok{"Haute{-}Corse"}\NormalTok{), }\DecValTok{2}\NormalTok{), }
             \DataTypeTok{annee =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2011}\NormalTok{, }\DecValTok{2010}\NormalTok{), }\DataTypeTok{each =} \DecValTok{6}\NormalTok{),}
             \DataTypeTok{ouvriers =} \KeywordTok{c}\NormalTok{(}\DecValTok{8738}\NormalTok{, }\DecValTok{12701}\NormalTok{, }\DecValTok{11390}\NormalTok{, }\DecValTok{10228}\NormalTok{, }\DecValTok{975}\NormalTok{, }\DecValTok{1297}\NormalTok{,}
                          \DecValTok{8113}\NormalTok{, }\DecValTok{12258}\NormalTok{, }\DecValTok{10897}\NormalTok{, }\DecValTok{9617}\NormalTok{, }\DecValTok{936}\NormalTok{, }\DecValTok{1220}\NormalTok{), }
             \DataTypeTok{ingenieurs =} \KeywordTok{c}\NormalTok{(}\DecValTok{1420}\NormalTok{, }\DecValTok{2530}\NormalTok{, }\DecValTok{3986}\NormalTok{, }\DecValTok{2025}\NormalTok{, }\DecValTok{259}\NormalTok{, }\DecValTok{254}\NormalTok{,}
                            \DecValTok{1334}\NormalTok{, }\DecValTok{2401}\NormalTok{, }\DecValTok{3776}\NormalTok{, }\DecValTok{1979}\NormalTok{, }\DecValTok{253}\NormalTok{, }\DecValTok{241}\NormalTok{))}
\NormalTok{chomage}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       region     departement annee ouvriers ingenieurs
##  1: Bretagne   Cotes-d'Armor  2011     8738       1420
##  2: Bretagne       Finistere  2011    12701       2530
##  3: Bretagne Ille-et-Vilaine  2011    11390       3986
##  4: Bretagne        Morbihan  2011    10228       2025
##  5:    Corse    Corse-du-Sud  2011      975        259
##  6:    Corse     Haute-Corse  2011     1297        254
##  7: Bretagne   Cotes-d'Armor  2010     8113       1334
##  8: Bretagne       Finistere  2010    12258       2401
##  9: Bretagne Ille-et-Vilaine  2010    10897       3776
## 10: Bretagne        Morbihan  2010     9617       1979
## 11:    Corse    Corse-du-Sud  2010      936        253
## 12:    Corse     Haute-Corse  2010     1220        241
\end{lstlisting}

Il est facile de convertir un \emph{tibble} en \texttt{data.table}, en faiant appel à la même fonction.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{region =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Bretagne"}\NormalTok{, }\StringTok{"Alsace"}\NormalTok{), }\DataTypeTok{each =} \DecValTok{2}\NormalTok{),}
             \DataTypeTok{annee =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2010}\NormalTok{, }\DecValTok{2011}\NormalTok{), }\DecValTok{2}\NormalTok{),}
             \DataTypeTok{population =} \KeywordTok{c}\NormalTok{(}\DecValTok{3199066}\NormalTok{, }\DecValTok{3217767}\NormalTok{, }\DecValTok{1845687}\NormalTok{, }\DecValTok{1852325}\NormalTok{))}

\NormalTok{population \textless{}{-}}\StringTok{ }\KeywordTok{data.table}\NormalTok{(pop)}
\NormalTok{population}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region annee population
## 1: Bretagne  2010    3199066
## 2: Bretagne  2011    3217767
## 3:   Alsace  2010    1845687
## 4:   Alsace  2011    1852325
\end{lstlisting}

La fonction \texttt{tables()} donne un aperçu des \emph{data.tables} en mémoire.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tables}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##          NAME NROW NCOL MB                                         COLS KEY
## 1:    chomage   12    5  0 region,departement,annee,ouvriers,ingenieurs    
## 2: population    4    3  0                      region,annee,population    
## Total: 0MB
\end{lstlisting}

La fonction \texttt{as\_tibble()} convertit les \emph{data.table} en \emph{tibble}, ce qui est essentiel, dans la mesure où certaines fonctions ne prennent en compte qu'un objet \emph{tibble} ou \emph{data.frame} en argument, et excluent toute autre structure.

\hypertarget{suxe9lection-1}{%
\subsubsection{Sélection}\label{suxe9lection-1}}

Comme pour un \emph{tibble}, on peut accéder aux éléments par leur numéro de ligne. En revanche, l'accès par le numéro de colonne ne fonctionne pas comme avec une matrice ou un \emph{tibble}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\DecValTok{1}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region   departement annee ouvriers ingenieurs
## 1: Bretagne Cotes-d'Armor  2011     8738       1420
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Retourne un résultat pas forcément attendu}
\NormalTok{chomage[,}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       region
##  1: Bretagne
##  2: Bretagne
##  3: Bretagne
##  4: Bretagne
##  5:    Corse
##  6:    Corse
##  7: Bretagne
##  8: Bretagne
##  9: Bretagne
## 10: Bretagne
## 11:    Corse
## 12:    Corse
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region
## 1: Bretagne
\end{lstlisting}

Pour accéder aux valeurs dans les colonnes, il faut fournir le nom de la colonne, sans guillemets en second argument à la fonction \texttt{"{[}.data.table"()}. Pour choisir plusieurs colonnes, il faut placer le nom des variables, sans guillemets, dans une liste, et le fournir en second argument de la fonction \texttt{"{[}.data.table"()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\DecValTok{1}\NormalTok{,ouvriers]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 8738
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\DecValTok{1}\NormalTok{, }\KeywordTok{list}\NormalTok{(ouvriers, ingenieurs)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    ouvriers ingenieurs
## 1:     8738       1420
\end{lstlisting}

\hypertarget{filtrage-1}{%
\subsubsection{Filtrage}\label{filtrage-1}}

On peut extraire des sous parties du \emph{data.table} à l'aide des opérateurs logiques qui scannent la totalité des données. Cependant, la Section~\ref{manip-datatable-cles} propose un moyen beaucoup plus rapide, surtout avec des gros volumes de données, pour effectuer des recherches dans un \emph{data.table}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[annee }\OperatorTok{==}\StringTok{ }\DecValTok{2010} \OperatorTok{\&}\StringTok{ }\NormalTok{departement }\OperatorTok{\%in\%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Finistere"}\NormalTok{, }\StringTok{"Morbihan"}\NormalTok{),}
        \KeywordTok{list}\NormalTok{(departement, ouvriers, annee)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    departement ouvriers annee
## 1:   Finistere    12258  2010
## 2:    Morbihan     9617  2010
\end{lstlisting}

\hypertarget{retirer-les-valeurs-dupliquuxe9es-1}{%
\subsubsection{Retirer les valeurs dupliquées}\label{retirer-les-valeurs-dupliquuxe9es-1}}

Il arrive parfois, après avoir effectué des opérations sur les tables, d'obtenir des duplications d'enregistrement. Comme pour les \emph{data.frames} ou les \emph{tibbles}, il faut se servir de la fonction \texttt{unique()} pour retirer les doublons. Attention, si le \emph{data.table} possède une clé, il est nécessaire de la retirer avant d'appeler la fonction \texttt{unique()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Les observations 1 et 7, ainsi que 3 et 6 sont dupliquées}
\NormalTok{dt \textless{}{-}}\StringTok{ }\KeywordTok{data.table}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ letters[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{)],}
                 \DataTypeTok{y =}\NormalTok{ letters[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{)])}

\CommentTok{\# setkey(dt, NULL)}
\KeywordTok{unique}\NormalTok{(dt)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    x y
## 1: a a
## 2: b e
## 3: c b
## 4: a d
## 5: d c
\end{lstlisting}

\hypertarget{manip-datatable-cles}{%
\subsubsection{Clés}\label{manip-datatable-cles}}

Dans les bases de données relationnelles, la présence d'une clé primaire permet d'identifier chaque observation de la base. Celle-ci peut être composée d'un seul ou de plusieurs champs. Ici, avec les \emph{data.table}, il en est à peu près de même. Une clé (\texttt{key}) peut être composée d'une seule ou de plusieurs variables (colonnes) du \emph{data.table}, qui peuvent être de mode \texttt{factor}, \texttt{numeric}, \texttt{integer}, \texttt{character}, etc. Les lignes sont ordonnées en fonction de la clé, ce qui implique l'impossibilité d'avoir plusieurs clés. Les clés dupliquées sont autorisées.

Pour définir une clé, on peut utiliser la fonction \texttt{setkey()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setkey}\NormalTok{(chomage, departement)}
\KeywordTok{tables}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##          NAME NROW NCOL MB                                         COLS
## 1:    chomage   12    5  0 region,departement,annee,ouvriers,ingenieurs
## 2:         dt    7    2  0                                          x,y
## 3: population    4    3  0                      region,annee,population
##            KEY
## 1: departement
## 2:            
## 3:            
## Total: 0MB
\end{lstlisting}

Comme précisé plus haut, on peut voir à présent que le \emph{data.table} a été ordonné en fonction de la clé.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       region     departement annee ouvriers ingenieurs
##  1:    Corse    Corse-du-Sud  2011      975        259
##  2:    Corse    Corse-du-Sud  2010      936        253
##  3: Bretagne   Cotes-d'Armor  2011     8738       1420
##  4: Bretagne   Cotes-d'Armor  2010     8113       1334
##  5: Bretagne       Finistere  2011    12701       2530
##  6: Bretagne       Finistere  2010    12258       2401
##  7:    Corse     Haute-Corse  2011     1297        254
##  8:    Corse     Haute-Corse  2010     1220        241
##  9: Bretagne Ille-et-Vilaine  2011    11390       3986
## 10: Bretagne Ille-et-Vilaine  2010    10897       3776
## 11: Bretagne        Morbihan  2011    10228       2025
## 12: Bretagne        Morbihan  2010     9617       1979
\end{lstlisting}

On peut à présent faire référence à une valeur de la clé pour accéder à une information

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\StringTok{"Finistere"}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region departement annee ouvriers ingenieurs
## 1: Bretagne   Finistere  2011    12701       2530
## 2: Bretagne   Finistere  2010    12258       2401
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# On n\textquotesingle{}est pas obligé de mettre la virgule}
\NormalTok{chomage[}\StringTok{"Finistere"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region departement annee ouvriers ingenieurs
## 1: Bretagne   Finistere  2011    12701       2530
## 2: Bretagne   Finistere  2010    12258       2401
\end{lstlisting}

Comme on peut le voir, la clé \texttt{"departement"} est dupliqueée pour la valeur \texttt{"Finistere"}. De fait, deux observations sont retournées. Si on souhaite obtenir uniquement la première ou la dernière, on peut utiliser l'argument \texttt{mult}, en lui donnant respectivement la valeur \texttt{"first"} ou \texttt{"last"}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\StringTok{"Finistere"}\NormalTok{, mult =}\StringTok{ "first"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region departement annee ouvriers ingenieurs
## 1: Bretagne   Finistere  2011    12701       2530
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\StringTok{"Finistere"}\NormalTok{, mult =}\StringTok{ "last"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region departement annee ouvriers ingenieurs
## 1: Bretagne   Finistere  2010    12258       2401
\end{lstlisting}

La clé peut être composée de plusieurs variables, il faut utiliser la fonction \texttt{J()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setkey}\NormalTok{(chomage, region, departement)}
\KeywordTok{tables}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##          NAME NROW NCOL MB                                         COLS
## 1:    chomage   12    5  0 region,departement,annee,ouvriers,ingenieurs
## 2:         dt    7    2  0                                          x,y
## 3: population    4    3  0                      region,annee,population
##                   KEY
## 1: region,departement
## 2:                   
## 3:                   
## Total: 0MB
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\StringTok{"Corse"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    region  departement annee ouvriers ingenieurs
## 1:  Corse Corse-du-Sud  2011      975        259
## 2:  Corse Corse-du-Sud  2010      936        253
## 3:  Corse  Haute-Corse  2011     1297        254
## 4:  Corse  Haute-Corse  2010     1220        241
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[}\KeywordTok{J}\NormalTok{(}\StringTok{"Bretagne"}\NormalTok{, }\StringTok{"Finistere"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region departement annee ouvriers ingenieurs
## 1: Bretagne   Finistere  2011    12701       2530
## 2: Bretagne   Finistere  2010    12258       2401
\end{lstlisting}

À l'heure de la rédaction de la première version de ces notes, il n'existait pas encore de moyen de faire une recherche par clé secondaire (cela semble être à présent possible, comme le montre \href{https://cran.r-project.org/web/packages/data.table/vignettes/datatable-secondary-indices-and-auto-indexing.html}{cette vignette du \emph{package}}). Il était cependant possible de contourner le problème en effectuant de nouveau l'opération de définition de clé.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Pour rechercher les observations pour lesquelles le département}
\CommentTok{\# est le Finistere, sans savoir que c\textquotesingle{}est en Bretagne}

\CommentTok{\# Ne fonctionne pas}
\NormalTok{chomage[}\StringTok{"Finistere"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       region departement annee ouvriers ingenieurs
## 1: Finistere        <NA>    NA       NA         NA
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setkey}\NormalTok{(chomage, departement)}
\NormalTok{chomage[}\StringTok{"Finistere"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region departement annee ouvriers ingenieurs
## 1: Bretagne   Finistere  2011    12701       2530
## 2: Bretagne   Finistere  2010    12258       2401
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Retour à la clé précédente}
\KeywordTok{setkey}\NormalTok{(chomage, region, departement)}
\end{Highlighting}
\end{Shaded}

\hypertarget{modification-des-colonne}{%
\subsubsection{Modification des colonne}\label{modification-des-colonne}}

Dans l'application de la fonction \texttt{"{[}.data.table"()} à un \emph{data.table}, le deuxième argument peut être une ou plusieurs expressions dont les arguments sont les noms des colonnes du \emph{data.table}, sans les guillemets.

Si on souhaite ajouter une nouvelle variable dans le \emph{data.table}, on peut le faire avec le symbole d'assignation, ou bien en utilisant le symbole \texttt{:=}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[, a }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\NormalTok{letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{]]}
\CommentTok{\# Equivalent de }
\CommentTok{\# chomage$temp \textless{}{-} letters[1:12]}
\end{Highlighting}
\end{Shaded}

L'ajout d'une nouvelle variable à partir des valeurs contenues dans le \emph{data.table} est un peu plus subtil. Il faut utiliser le symbole \texttt{:=} et il n'est plus possible d'utiliser la flèche \texttt{\textless{}-}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[, b }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\NormalTok{ouvriers }\OperatorTok{+}\StringTok{ }\NormalTok{ingenieurs]}
\end{Highlighting}
\end{Shaded}

L'ajout de plusieurs variables possède un syntaxe un peu moins intuitive.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[, }\StringTok{":="}\NormalTok{ (}\DataTypeTok{c =}\NormalTok{ ouvriers}\OperatorTok{/}\DecValTok{100}\NormalTok{, }\DataTypeTok{d =} \KeywordTok{paste0}\NormalTok{(a,b))]}
\end{Highlighting}
\end{Shaded}

Une fonctionnalité pratique est qu'il est possible de définir une variable et de la réutiliser directement après sa définition.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[, }\KeywordTok{c}\NormalTok{(}\StringTok{"e"}\NormalTok{, }\StringTok{"f"}\NormalTok{) }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\KeywordTok{list}\NormalTok{(tmp \textless{}{-}}\StringTok{ }\NormalTok{ouvriers }\OperatorTok{+}\StringTok{ }\NormalTok{ingenieurs,}
                              \KeywordTok{round}\NormalTok{(}\KeywordTok{sqrt}\NormalTok{(tmp)))]}
\end{Highlighting}
\end{Shaded}

La suppression se fait avec \texttt{NULL}, et il faut placer le nom des variables entouré de guillemets dans un vecteur.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Suppression de plusieurs colonnes}
\NormalTok{chomage[, }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"e"}\NormalTok{) }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\OtherTok{NULL}\NormalTok{]}

\CommentTok{\# Suppression d\textquotesingle{}une seule colonne}
\NormalTok{chomage[, f }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\OtherTok{NULL}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\hypertarget{tri-1}{%
\subsubsection{Tri}\label{tri-1}}

Lorsqu'une clé est définie, les enregistrement du \emph{data.table} sont triés en fonction de cette clé. Si la clé contient plusieurs noms de colonnes, par exemple \texttt{var\_1,\ var\_2,} etc., le tri s'effectue d'abord par la première variable (\texttt{var\_1}), puis la seconde (\texttt{var\_2}), etc.

Il est possible de forcer le tri sur une autre variable, ou plusieurs autres.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(chomage[}\KeywordTok{order}\NormalTok{(annee)])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region     departement annee ouvriers ingenieurs
## 1: Bretagne   Cotes-d'Armor  2010     8113       1334
## 2: Bretagne       Finistere  2010    12258       2401
## 3: Bretagne Ille-et-Vilaine  2010    10897       3776
## 4: Bretagne        Morbihan  2010     9617       1979
## 5:    Corse    Corse-du-Sud  2010      936        253
## 6:    Corse     Haute-Corse  2010     1220        241
\end{lstlisting}

\hypertarget{copie-de-data.tables}{%
\subsubsection{\texorpdfstring{Copie de \emph{data.tables}}{Copie de data.tables}}\label{copie-de-data.tables}}

Attention, pour copier un \emph{data.table}, il faut utiliser la fonction \texttt{copy()} ! En effet, la flèche d'assignation ne réalise pas la création d'une nouvelle variable dont le contenu est désigné par le bout de la flèche, elle réalise une référence.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt \textless{}{-}}\StringTok{ }\KeywordTok{data.table}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{], }\DataTypeTok{y =} \DecValTok{4}\OperatorTok{:}\DecValTok{6}\NormalTok{)}
\NormalTok{dt}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    x y
## 1: a 4
## 2: b 5
## 3: c 6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Référence}
\NormalTok{dt\_ref \textless{}{-}}\StringTok{ }\NormalTok{dt}

\CommentTok{\# Copie}
\NormalTok{dt\_copie \textless{}{-}}\StringTok{ }\KeywordTok{copy}\NormalTok{(dt)}

\CommentTok{\# Ajoutons une variable}
\NormalTok{dt[, a }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\NormalTok{dt\_ref[, z }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\KeywordTok{paste0}\NormalTok{(x,y)]}
\NormalTok{dt\_copie[, t }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\KeywordTok{paste0}\NormalTok{(y,x)]}

\CommentTok{\# Les variables "a" et "z" ont été ajoutées à dt et dt\_ref}
\CommentTok{\# sans impacter dt\_copie}
\CommentTok{\# La variable "t" n\textquotesingle{}a été ajoutée qu\textquotesingle{}à dt\_copie}
\NormalTok{dt}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    x y a  z
## 1: a 4 1 a4
## 2: b 5 1 b5
## 3: c 6 1 c6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt\_ref}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    x y a  z
## 1: a 4 1 a4
## 2: b 5 1 b5
## 3: c 6 1 c6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt\_copie}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    x y  t
## 1: a 4 4a
## 2: b 5 5b
## 3: c 6 6c
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En revanche, la suppression de dt\_ref ne supprime pas dt}
\KeywordTok{rm}\NormalTok{(dt\_ref)}
\NormalTok{dt}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    x y a  z
## 1: a 4 1 a4
## 2: b 5 1 b5
## 3: c 6 1 c6
\end{lstlisting}

\hypertarget{jointures-1}{%
\subsubsection{Jointures}\label{jointures-1}}

Pour réaliser une jointure, on peut utiliser la fonction \texttt{merge()} (bien que non présentée dans ces notes, cette fonction s'applique aussi aux \emph{tibbles}). Le \emph{package} \{\texttt{data.table}\} fournit d'autres méthodes, plus rapides, en passant, encore une fois, par la fonction \texttt{"{[}.data.frame"()}. La manière la plus simple, pour ne pas faire d'erreur lors de la jointure, est de définir en clé les variables communes aux deux tables.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setkey}\NormalTok{(chomage, region, annee)}
\KeywordTok{setkey}\NormalTok{(population, region, annee)}
\NormalTok{chomage[population]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       region     departement annee ouvriers ingenieurs population
##  1:   Alsace            <NA>  2010       NA         NA    1845687
##  2:   Alsace            <NA>  2011       NA         NA    1852325
##  3: Bretagne   Cotes-d'Armor  2010     8113       1334    3199066
##  4: Bretagne       Finistere  2010    12258       2401    3199066
##  5: Bretagne Ille-et-Vilaine  2010    10897       3776    3199066
##  6: Bretagne        Morbihan  2010     9617       1979    3199066
##  7: Bretagne   Cotes-d'Armor  2011     8738       1420    3217767
##  8: Bretagne       Finistere  2011    12701       2530    3217767
##  9: Bretagne Ille-et-Vilaine  2011    11390       3986    3217767
## 10: Bretagne        Morbihan  2011    10228       2025    3217767
\end{lstlisting}

On peut le voir, la jointure réalisée est de type \emph{Right Join}, c'est à dire que tous les éléments de la seconde table sont présents, mais que seuls ceux de la première à l'intersection avec la seconde sont conservés (on note que les observations concernant la Corse ont disparues). Les diagrammes suivants donnent les autres fusions possibles. On peut remarquer que le \emph{Full Outer Join} n'est pas possible avec la fonction \texttt{"{[}.data.frame"()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/unnamed-chunk-73-1} \end{center}

L'avantage, outre le temps gagné lorsqu'on a de gros volumes de données, d'utiliser \texttt{"{[}.data.frame"()} plutôt que \texttt{merge()}, est aussi qu'il est possible de faire une opération juste après la jointure. On gagne à la fois en temps d'exécution, et en lignes de codes, ainsi qu'en clarté de lecture.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[population][,}\KeywordTok{round}\NormalTok{((ouvriers }\OperatorTok{+}\StringTok{ }\NormalTok{ingenieurs)}\OperatorTok{/}\NormalTok{population}\OperatorTok{*}\DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1]   NA   NA 0.30 0.46 0.46 0.36 0.32 0.47 0.48 0.38
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[population,}
        \KeywordTok{list}\NormalTok{(}\DataTypeTok{tmp =} \KeywordTok{round}\NormalTok{((ouvriers }\OperatorTok{+}\StringTok{ }\NormalTok{ingenieurs)}\OperatorTok{/}\NormalTok{population}\OperatorTok{*}\DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{), departement)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      tmp     departement
##  1:   NA            <NA>
##  2:   NA            <NA>
##  3: 0.30   Cotes-d'Armor
##  4: 0.46       Finistere
##  5: 0.46 Ille-et-Vilaine
##  6: 0.36        Morbihan
##  7: 0.32   Cotes-d'Armor
##  8: 0.47       Finistere
##  9: 0.48 Ille-et-Vilaine
## 10: 0.38        Morbihan
\end{lstlisting}

Il arrive d'avoir à joindre des \emph{data.table} en les empilant, par lignes. Une manière de faire passe par un simple appel à la fonction \texttt{do.call()}, avec en premier argument la fonction \texttt{rbind()}. Cela dit, cette méthode peut s'avérer prendre beaucoup de temps. La fonction \texttt{rbindlist()} propose de joindre par les lignes des tables de manière très rapide, à condition d'avoir les différentes parties à coller placées dans une liste.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l \textless{}{-}}\StringTok{ }\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{data.table}\NormalTok{(}\DataTypeTok{valeur =}\NormalTok{ x, }\DataTypeTok{lettre =}\NormalTok{ LETTERS[x]))}
\NormalTok{res1 \textless{}{-}}\StringTok{ }\KeywordTok{do.call}\NormalTok{(}\StringTok{"rbind"}\NormalTok{, l)}
\NormalTok{res2 \textless{}{-}}\StringTok{ }\KeywordTok{rbindlist}\NormalTok{(l)}

\NormalTok{res2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    valeur lettre
## 1:      1      A
## 2:      2      B
## 3:      3      C
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{all.equal}\NormalTok{(res1, res2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

\hypertarget{agruxe9gation-1}{%
\subsubsection{Agrégation}\label{agruxe9gation-1}}

Pour obtenir le résultat d'une fonction appliquée à toute une colonne, il faut travailler avec le second argument de la fonction \texttt{"{[}.data.table"()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[, }\KeywordTok{mean}\NormalTok{(ouvriers)]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 7364.167
\end{lstlisting}

Si on souhaite effectuer des regroupements, il faut rajouter l'argument \texttt{by} et lui atribuer le nom de la colonne (sans guillemets). Si le regroupement doit s'effectuer selon plusieurs colonnes, il faut alors envelopper les noms séparés par des virgules (mais sans espace) par des guillemets. On peut également fournir la liste des noms dans une liste, ce qui est un peu plus souple.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[, }\KeywordTok{mean}\NormalTok{(ouvriers), by =}\StringTok{ }\NormalTok{region]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region       V1
## 1: Bretagne 10492.75
## 2:    Corse  1107.00
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[, }\KeywordTok{mean}\NormalTok{(ouvriers), by =}\StringTok{ "region,departement"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region     departement      V1
## 1: Bretagne   Cotes-d'Armor  8425.5
## 2: Bretagne       Finistere 12479.5
## 3: Bretagne Ille-et-Vilaine 11143.5
## 4: Bretagne        Morbihan  9922.5
## 5:    Corse    Corse-du-Sud   955.5
## 6:    Corse     Haute-Corse  1258.5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Fournit le même résultat}
\CommentTok{\# chomage[, mean(ouvriers), by = list(region, departement)]}
\end{Highlighting}
\end{Shaded}

Il est possible d'effectuer des calculs sur plusieurs des colonnes du \emph{data.table}. Pour ce faire, il faut placer le second argument de la fonction \texttt{"{[}.data.table"()} dans une liste. Si on souhaite donner des noms aux variables issues du calcul, c'est possible. Attention, il faut bien être dans une liste pour attribuer le nom !

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage[, }\KeywordTok{list}\NormalTok{(}\KeywordTok{mean}\NormalTok{(ouvriers), }\KeywordTok{sd}\NormalTok{(ouvriers)), by =}\StringTok{ }\NormalTok{region]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region       V1        V2
## 1: Bretagne 10492.75 1627.4581
## 2:    Corse  1107.00  178.4507
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ne permet pas d\textquotesingle{}attribuer le nom "moyenne" au calcul}
\NormalTok{chomage[, moyenne =}\StringTok{ }\KeywordTok{mean}\NormalTok{(ouvriers), by =}\StringTok{ }\NormalTok{region]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in `[.data.table`(chomage, , moyenne = mean(ouvriers), by = region): argument inutilisé (moyenne = mean(ouvriers))
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Il faut être dans une liste}
\NormalTok{chomage[, }\KeywordTok{list}\NormalTok{(}\DataTypeTok{moyenne =} \KeywordTok{mean}\NormalTok{(ouvriers)), by =}\StringTok{ }\NormalTok{region]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      region  moyenne
## 1: Bretagne 10492.75
## 2:    Corse  1107.00
\end{lstlisting}

Les opérations de regroupement sont beaucoup plus rapides qu'avec les \emph{tibbles} ou les \emph{data.frames} (à condition d'avoir des volumes de données larges).

Par ailleurs, on peut effectuer plusieurs opérations d'un coup, qui dépendent des résultats précédents, en utilisant à nouveau la fonction \texttt{"{[}.data.table"()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Créons un data.table immense (presque 7 millions d\textquotesingle{}obs.)}
\NormalTok{n \textless{}{-}}\StringTok{ }\DecValTok{10000}
\NormalTok{dt \textless{}{-}}\StringTok{ }\KeywordTok{data.table}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{rep}\NormalTok{(letters, }\DataTypeTok{each =} \DecValTok{26}\OperatorTok{*}\NormalTok{n),}
                 \DataTypeTok{y =} \KeywordTok{rep}\NormalTok{(LETTERS, }\DataTypeTok{each =}\NormalTok{ n),}
                 \DataTypeTok{z =} \KeywordTok{runif}\NormalTok{(n}\OperatorTok{*}\DecValTok{26}\OperatorTok{\^{}}\DecValTok{2}\NormalTok{))}

\KeywordTok{nrow}\NormalTok{(dt)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 6760000
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Après avoir calculé la moyenne de z pour chaque groupe}
\CommentTok{\# défini par les valeurs de x et y,}
\CommentTok{\# on ne conserve que les observations pour lesquelles la moyenne}
\CommentTok{\# fraîchement créée est supérieure à 0.5}
\NormalTok{dt[, }\KeywordTok{list}\NormalTok{(}\DataTypeTok{moy =} \KeywordTok{mean}\NormalTok{(z)), by =}\StringTok{ "x,y"}\NormalTok{][moy }\OperatorTok{\textgreater{}}\StringTok{ }\FloatTok{0.5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      x y       moy
##   1: a A 0.5027694
##   2: a B 0.5038667
##   3: a C 0.5018392
##   4: a E 0.5032293
##   5: a F 0.5061663
##  ---              
## 356: z O 0.5030591
## 357: z Q 0.5022006
## 358: z T 0.5029839
## 359: z Y 0.5015812
## 360: z Z 0.5035244
\end{lstlisting}

\hypertarget{quelques-fonctions-utiles}{%
\subsection{Quelques fonctions utiles}\label{quelques-fonctions-utiles}}

Le tableau ci-dessous répertorie quelques fonctions de base qu'il est bon de connaître pour manipuler les données dans R.

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.41\columnwidth}\raggedright
Fonction\strut
\end{minipage} & \begin{minipage}[b]{0.53\columnwidth}\raggedright
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{x\%\%y}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Modulo\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{x\%/\%y}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Division entière\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{ceiling(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Plus petits entier supérieur ou égal à \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{floor(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Plus petits entier inférieur ou égal à \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{round(x,\ digits)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Arrondi de \texttt{x} à digits décimales près\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{signif(x,\ digits)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Arrondi de \texttt{x} à digits chiffres significatifs\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{trunc(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Partie entière de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{abs(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Valeur absolue de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cor(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Matrice de corrélations, si \texttt{x} est une matrice ou une data frame\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cor(x,\ y)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Corrélation linéaire entre \texttt{x} et \texttt{y}, ou matrice de corrélations si \texttt{x} et \texttt{y} sont des matrices ou des data frames\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cummax(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Vecteur dont le ie élément est le maximum des éléments de \texttt{x{[}1{]}} à \texttt{x{[}i{]}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cummin(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Vecteur dont le ie élément est le minimum des éléments de \texttt{x{[}1{]}} à \texttt{x{[}i{]}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cumprod(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Vecteur dont le ie élément est le produit des éléments \texttt{x{[}1{]}} à \texttt{x{[}i{]}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cumsum(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Vecteur dont le ie élément est la somme des éléments de \texttt{x{[}1{]}} à \texttt{x{[}i{]}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{exp(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Exponentielle de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{log(x,\ base)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Logarithme de \texttt{x}, avec \texttt{base=10} par défaut\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{max(...,\ na.rm)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Maximum du premier argument (peut être de type \texttt{numeric}, \texttt{logical} ou \texttt{character}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{mean(x,\ na.rm,\ trim)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Moyenne de \texttt{x}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles. L'argument \texttt{trim}, compris entre 0 (par défaut) et 0.5 indique la fraction d'observations à retirer de chaque côté de \texttt{x} avant de calculer la moyenne des observations restantes\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{median(x,\ na.rm)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Médiane de \texttt{x}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{min(...,\ na.rm)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Minimum du premier argument (peut être de type \texttt{numeric}, \texttt{logical} ou \texttt{character}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{prod(...,\ na.rm)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Produit des éléments du premier argument (peut être de type \texttt{numeric}, \texttt{logical} ou \texttt{complex}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{quantile(x,\ probs,\ na.rm)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Fractiles empiriques de \texttt{x} d'ordre \texttt{probs}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{range(...,\ na.rm,\ finite)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Étendue du premier argument (peut être de type \texttt{numeric}, \texttt{logical} ou \texttt{character}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles. Si \texttt{finite\ =\ TRUE}, les éléments non-finis sont omis.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{sd(x,\ na.rm)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Écart-type de \texttt{x}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{sign(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Signe de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{sqrt(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Racine carrée de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{sum(...,\ na.rm)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Somme du premier argument (peut être de type \texttt{numeric}, \texttt{logical} ou \texttt{complex}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{var(x,\ na.rm)} ou \texttt{cov(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Variance corrigée de \texttt{x} (division par \texttt{n\ -\ 1} et non \texttt{n}). Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles. Si \texttt{x} est une matrice ou un data frame, le résultat est la matrice de variance-covariance\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{var(x,\ y,\ na.rm)} ou \texttt{cov(x,\ y)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Covariance entre \texttt{x} et \texttt{y}, ou, dans le cas où \texttt{x} et \texttt{y} sont des matrices ou des data frames, entre les colonnes de \texttt{x} et \texttt{y}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{sin(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Sinus de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cos(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Cosinus de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{tan(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Tangente de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{asin(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Arc-sinus de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{acos(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Arc-cosinus de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{atan(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Arc-tangente de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{sinh(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Sinus hyperbolique de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cosh(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Cosinus hyperbolique de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{tanh(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Tangente hyperbolique de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{asinh(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Arc-sinus hyperbolique de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{acosh(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Arc-cosinus hyperbolique de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{atanh(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Arc-tangente hyperbolique de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{factorial(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Factorielle de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{choose(n,\ k)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Coeffcient binomial \(C_n^k\)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{any(x,\ na.rm)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Indique si au moins un élément de \texttt{x} vaut \texttt{TRUE}. Si \texttt{na.rm\ =\ TRUE}, omet les valeurs non disponibles\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{duplicated(x,\ fromLast)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Indique les éléments de \texttt{x} qui commencent à être dupliqués. Si \texttt{fromLast\ =\ TRUE}, le calcul est effectué de droite à gauche\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{head(x,\ n)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Vecteur des \texttt{n} premières valeurs de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{order(x,\ decreasing)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Vecteur des rangs de classement des éléments de \texttt{x}. Si ex æquo, les rangs sont classés par ordre croissant\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{rev(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Retourne \texttt{x} avec ses éléments dans l'ordre inversé\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{table(...)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Tableau de contingence\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{sample(x,\ size,\ replace,\ prob)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Ré-échantillonnage pseudo-aléatoire (avec remise si \texttt{replace\ =\ TRUE}) de \texttt{x} de taille \texttt{size}. L'argument optionnel \texttt{prob} permet d'attribuer des poids aux éléments\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{summary(object)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Retourne une table indiquant pour object : le minimum, le premier quartile, la médiane, la moyenne, le troisième quartile, le maximum et, s'il y en a, le nombre de valeurs manquantes. Les calculs sont effectués en omettant les valeurs manquantes.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{sort(x,\ decreasing)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
\texttt{x} trié par ordre de valeurs croissantes (décroissantes si \texttt{decreasing\ =\ TRUE)}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{tail(x,\ n)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Vecteur des \texttt{n} dernières valeurs de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{unique(x,\ fromLast)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Conserve uniquement les valeurs uniques de \texttt{x}, en retirant les doublons. Si \texttt{fromLast\ =\ TRUE}, le calcul indiquant si l'élément est dupliqué est effectué de droite vers la gauche\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{which.min(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Position du (premier) minimum de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{which.max(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Position du (premier) maximum de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{"{[}"()}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Fonction d'extraction ou de remplacement de parties d'un objet\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{"{[}{[}"()}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Fonction d'extraction ou de remplacement de parties d'un objet. Les noms sont perdus.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{dim(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Liste des tailles de la matrice ou data frame \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{nrow(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Nombre de lignes de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{ncol(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Nombre de colonnes de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{dimnames(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Liste des noms des lignes et des colonnes de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{names(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Vecteur du (des) nom(s) de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{colnames(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Nom des colonnes de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{rownames(x)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Nom des lignes de \texttt{x}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{c()}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Concaténation\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{cbind(x,\ y,\ ...)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Fusion des matrices ou data frames \texttt{x} et \texttt{y} par colonnes\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{merge(x,\ y)}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Fusion de deux data frames par noms de colonnes communs\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.41\columnwidth}\raggedright
\texttt{rbind()}\strut
\end{minipage} & \begin{minipage}[t]{0.53\columnwidth}\raggedright
Fusion des matrices ou data frames \texttt{x} et \texttt{y} par lignes\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{exercices}{%
\section{Exercices}\label{exercices}}

\begin{exframe}
\textbf{Exercice 1. Manipulation de vecteurs}

Considérons le vecteur suivant : \(x = \begin{bmatrix}1 & 2 & 3 & 4 & 5\end{bmatrix}\).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer ce vecteur dans R et le stocker dans un objet que l'on appellera \texttt{x}x
\item
  Afficher le mode de \texttt{x}, puis sa longueur ;
\item
  Extraire le premier élément, puis le dernier ;
\item
  Extraire les trois premier éléments et les stocker dans un vecteur que l'on nommera \texttt{a} ;
\item
  Extraire les éléments en position 1, 3, 5 ; les stocker dans un vecteur que l'on nommera \texttt{b} ;
\item
  Additionner le nombre \texttt{10} au vecteur \texttt{x}, puis multipliser le résultat par \texttt{2} ;
\item
  Effectuer l'addition de \texttt{a} et \texttt{b}, commenter le résultat ;
\item
  Effectuer l'addition suivante : \texttt{x+a}, commenter le résultat, puis regarder le résultat de \texttt{a+x} ;
\item
  Multiplier le vecteur par le scalaire \texttt{c} que l'on fixera à 2 ;
\item
  Effectuer la multiplication de \texttt{a} et \texttt{b}, commenter le résultat ;
\item
  Effectuer la multiplication suivante : \texttt{x*a}, commenter le résultat ;
\item
  Récupérer les positions des multiples de 2 et les stocker dans un vecteur que l'on nommera \texttt{ind}, puis conserver uniquement les multiples de 2 de \texttt{x} dans un vecteur que l'on nommera \texttt{mult\_2} ;
\item
  Afficher les éléments de \texttt{x} qui sont multiples de 3 \emph{et} multiples de 2 ;
\item
  Afficher les éléments de \texttt{x} qui sont multiples de 3 \emph{ou} multiples de 2 ;
\item
  Calculer la somme des éléments de \texttt{x} ;
\item
  Remplacer le premier élément de \texttt{x} par un \texttt{4} ;
\item
  Remplacer le premier élément de \texttt{x} par la valeur \texttt{NA}, puis calculer la somme des éléments de \texttt{x} ;
\item
  Lister les objets en mémoire dans la session R ;
\item
  Supprimer le vecteur ;
\item
  Supprimer la totalité des objets de la session.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 2. Manipulation de listes}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  évaluer le code suivant : \texttt{TRUE+FALSE+TRUE*4} et le commenter ;
\item
  évaluer les expressions suivantes : \texttt{c(1,\ 4,\ TRUE)}, et \texttt{c(1,\ 4,\ TRUE,\ "bonjour")}, commenter ;
\item
  Créer une liste que l'on appellera \texttt{l} et qui contient les éléments \texttt{1}, \texttt{4} et \texttt{TRUE} en première, deuxième et troisième positions, respectivement ;
\item
  Extraire le premier élément de la liste \texttt{l}, et afficher son mode. En faire de même avec le troisième élément, et commenter ;
\item
  Ajouter un quatrième élément à la liste \texttt{l} : \texttt{"bonjour"}, puis afficher la structure de \texttt{l} ;
\item
  Retirer le troisième élément de la liste \texttt{l} ;
\item
  Créer une liste de trois éléments : votre nom, votre prénom, et votre année de naissance. Ces trois éléments de la liste devront être nommés respectivement \texttt{"nom"}, \texttt{"prenom"} et \texttt{"année\ de\ naissance"}. Stocker la liste ainsi créée dans un objet nommé \texttt{moi} ;
\item
  Extraire le prénom de la liste \texttt{moi} de deux manières : en utilisant l'indice, et en utilisant le nommage ;
\item
  Créer une liste avec la même structure que celle de \texttt{moi}, en la remplissant avec les informations d'une autre personne et la nommer \texttt{toi}. Puis, créer la liste \texttt{personnes}, qui contiendra les listes \texttt{toi} et \texttt{moi} ;
  10 Extraire la liste \texttt{toi} de \texttt{personnes} (en première position) ;
  11 Extraire directement depuis \texttt{personne} le prénom de l'élément en première position.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 3. Manipulation de matrices}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer la matrice suivante : \(A = \begin{bmatrix} -3 & 5 & 6 \\ -1 & 2 & 2 \\ 1 & -1 & -1 \end{bmatrix}\) ;
\item
  Afficher la dimension de \texttt{A}, son nombre de colonnes, son nombre de lignes et sa longueur ;
\item
  Extraire la seconde colonne de \texttt{A}, puis la première ligne ;
\item
  Extraire l'élément en troisième position à la première ligne ;
\item
  Extraire la sous-matrice de dimension \(2\times 2\) du coin inférieur de \texttt{A}, c'est-à-dire \(\begin{bmatrix} 2 & 2 \\ -1 & -1 \end{bmatrix}\) ;
\item
  Calculer la somme des colonnes puis des lignes de \texttt{A} ;
\item
  Afficher la diagonale de \texttt{A} ;
\item
  Rajouter le vecteur \(\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top\) à droite de la matrice \texttt{A} et stocker le résultat dans un objet appelé \texttt{B} ;
\item
  Retirer le quatrième vecteur de \texttt{B} ;
\item
  Retirer la première et la troisième ligne de \texttt{B} ;
\item
  Ajouter le scalaire \texttt{10} à \texttt{A} ;
\item
  Ajouter le vecteur \(\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top\) à A ;
\item
  Ajouter la matrice identité \(I_3\) à \texttt{A} ;
\item
  Diviser tous les éléments de la matrice \texttt{A} par 2 ;
\item
  Multiplier la matrice \texttt{A} par le vecteur \(\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top\) ;
\item
  Afficher la transposée de \texttt{A} ;
\item
  Effectuer le produit avec transposition \(A^\top A\).
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 4. Manipulation de matrices}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Télécharger le fichier \texttt{csv} à l'adresse suivante : \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes.csv} et le placer dans le répertoire courant du projet. Importer son contenu dans R ;
\item
  Importer à nouveau les données dans R, mais en utilisant fournissant cette fois le l'url directement à la fonction d'importation ;
\item
  À présent, importer le contenu du fichier disponible à l'adresse \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes_decim.csv}. Le séparateur de champs est un point virgule et le séparateur décimal est une virgule ;
\item
  Importer le contenu du fichier \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes_h.csv}. Le nom des colonnes n'est pas présent ;
\item
  Importer le contenu du fichier \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes_h_s.csv}. La première ligne n'est pas à importer ;
\item
  Importer le contenu de la première feuille du fichier Excel \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes.xlsx} ;
\item
  Importer le contenu de la seconde feuille (`notes\_h\_s) du fichier Excel \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes.xlsx}. La première ligne est un commentaire à ne pas considérer durant l'importaiton ;
\item
  Importer le fichier \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes.rda} dans R ;
\item
  Exporter le contenu de l'objet \texttt{notes} de la question précédente au format \texttt{csv} (virgule en séparateur de champs, point en séparateur décimal, ne pas conserver le numéro des lignes).
\item
  Importer le contenu du fichier \texttt{notes\_2012.csv} contenu dans l'archive disponible à l'adresse suivante : \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes.zip}
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 5. Manipulation de tableaux de données}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  À l'aide de la fonction \texttt{read\_excel()} du \emph{package} \texttt{readr}, importer le contenu de la feuille intitulée \texttt{notes\_2012} du fichier Excel disponible à l'adresse suivante : \url{http://egallic.fr/Enseignement/R/Exercices/donnees/notes_etudiants.xlsx} et le stocker dans une variable que l'on nommera \texttt{notes\_2012} ;
\item
  Afficher les 6 premières lignes du jeu de données, puis les dimensions du tableau ;
\item
  Conserver uniquement la colonne \texttt{note\_stat} du tableau de données \texttt{notes\_2012} dans un objet que l'on appellera tmp ;
\item
  Conserver uniquement les colonnes \texttt{num\_etudiant}, \texttt{note\_stat} et \texttt{note\_macro} dans l'objet \texttt{tmp};
\item
  Remplacer le contenu de \texttt{tmp} par les observations de \texttt{notes\_2012} pour lesquelles l'individu a obtenu une note de stat supérieure (strictement) à 10 ;
\item
  Remplacer le contenu de \texttt{tmp} par les observations de \texttt{notes\_2012} pour lesquelles l'individu a obtenu une note comprise dans l'intervalle \((10,15)\);
\item
  Regarder s'il y a des doublons dans le tableau de données \texttt{notees\_2012} ; le cas échéant, les retirer du tableau ;
\item
  Afficher le type des données de la colonne \texttt{num\_etudiant}, puis afficher le type de toutes les colonnes de \texttt{notes\_2012} ;
\item
  Ajouter au tableau \texttt{notes\_2012} les colonnes suivantes :
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{note\_stat\_maj} : la note de stat (\texttt{note\_stat}) majorée d'un point,
\item
  \texttt{note\_macro\_maj} : la note de macro (\texttt{note\_macro}) majorée de trois points (le faire en deux étapes : d'abord deux points en plus, puis un point) ;
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{9}
\tightlist
\item
  Renommer la colonne \texttt{year} en \texttt{annee} ;
\item
  Depuis le fichier \texttt{notes\_etudiants.xlsx\}} (c.f. question 1), importer le contenu des feuilles \texttt{notes\_2013}, \texttt{notes\_2014} et \texttt{prenoms} et le stocker dans les objets \texttt{notes\_2013}, \texttt{notes\_2014} et \texttt{prenoms} respectivement ;
\item
  Empiler le contenu des tableaux de données \texttt{notes\_2012}, \texttt{notes\_2013} et \texttt{notes\_2014} dans un objet que l'on nommera \texttt{notes} ;
\item
  Fusionner les tableaux \texttt{notes} et \texttt{prenoms} à l'aide d'une jointure gauche, de manière à rajouter les informations contenues dans le tableau \texttt{prenoms} aux observations de \texttt{notes}. La jointure doit se faire par le numéro détudiant et l'année, l'objet final viendra remplacer le contenu de \texttt{notes} ;
\item
  Trier le tableau \texttt{notes} par années croissantes et notes de macro décroissantes ;
\item
  Changer le type des colonnes \texttt{annee} et \texttt{sexe} en facteur ;
\item
  Créer une colonne \texttt{apres\_2012} qui prend la valeur \texttt{TRUE} si l'observation concerne une note attribuée après 2012;
\item
  à l'aide de la fonction \texttt{summarize()} du \emph{package} \{\texttt{dplyr}\}, calculer :
\end{enumerate}

\begin{itemize}
\tightlist
\item
  la moyenne et l'écart-type annuels des notes pour chacune des deux matières,
\item
  la moyenne et l'écart-type annuels et par sexe des notes pour chacune des deux matières ;
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{16}
\tightlist
\item
  En utilisant la fonction \texttt{pivot\_longer()} du \emph{package} \{\texttt{tidyr}\}, créer un tableau dans lequel chaque ligne renseigne le numéro d'étudiant, l'année, le prénom, le sexe, l'enseignement (macro ou stat) et la note ;
\item
  En repartant de l'objet obtenu à la question précédente, utiliser la fonction \texttt{pivot\_wider()} du \emph{package} \{\texttt{tidyr}\} pour retomber sur le même tableau que \texttt{notes}.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 6. Manipulation de tableaux de chaînes de caractères}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer les objets \texttt{a} et \texttt{b} afin qu'il contiennent respectivement les chaînes de caractères suivantes : \texttt{23\ à\ 0} et \texttt{C\textquotesingle{}est\ la\ piquette,\ Jack\ !} ;
\item
  Créer le vecteur \texttt{phrases} de longueur 2, dont les deux éléments sont \texttt{a} et \texttt{b} ;
\item
  À l'aide de la fonction appropriée dans le \emph{package} \{\texttt{stringr}\}, afficher le nombre de caractètres de \texttt{a}, de \texttt{b}, puis appliquer la même fonction à l'objet \texttt{phrases} ;
\item
  En utilisant la fonction \texttt{str\_c()}, concaténer \texttt{a} et \texttt{b} dans une seule chaîne de caractères, en choisissant la virgule comme caractère de séparation ;
\item
  Concaténer les deux éléments du vecteur \texttt{phrases} en une seule chaîne de caractères, en les séparant par le caractère de retour à la ligne, puis utiliser la fonction \texttt{cat()} pour afficher le résultat dans la console ;
\item
  Appliquer la même fonction que dans la question précédente à l'objet suivant : \texttt{c(NA,\ phrases)} et commenter ;
\item
  Mettre en majuscules, puis en minuscules les chaînes du vecteur \texttt{phrases} (afficher le résultat, ne pas modifier \texttt{phrases});
\item
  À l'aide de la fonction \texttt{word()} du \emph{package} \{\texttt{stringr}\}, extraire le mot \texttt{la}, puis \texttt{Jack} de la chaîne \texttt{b} ;
\item
  Même question que la précédente, en utilisant la fonction \texttt{str\_sub()} ;
\item
  À l'aide de la fonction \texttt{str\_detect()}, rechercher si le motif \texttt{piqu} puis \texttt{mauvais} sont présents dans \texttt{b} ;
\item
  À l'aide de la fonction \texttt{str\_detect()}, rechercher si le motif \texttt{piqu} est présent dans les éléments du vecteur \texttt{phrases} ;
\item
  À l'aide de la fonction \texttt{str\_detect()}, rechercher si le motif \texttt{piqu} ou le motif \texttt{à} sont présents dans les éléments du vecteur \texttt{phrases} ;
\item
  En utilisant la fonction \texttt{str\_locate()}, retourner les positions de la première occurence du caractère \texttt{a} dans la chaîne \texttt{b}, puis essayer avec le caractère \texttt{w} pour observer le résultat retourné ;
\item
  Retourner toutes les positions du motif \texttt{a} dans la chaîne \texttt{b} ;
\item
  En utilisant la fonction \texttt{str\_replace()}, remplacer la première occurence du motif \texttt{a}, par le motif \texttt{Z} (afficher le résultat, ne pas modifier \texttt{phrases});
\item
  Remplacer toutes les occurences de \texttt{a} par \texttt{Z} dans la chaîne \texttt{b} (afficher le résultat, ne pas modifier \texttt{phrases}) ;
\item
  Utiliser la fonction \texttt{str\_split()} pour séparer la chaîne \texttt{b} en utilisant la virgule comme séparateur de sous-chaînes ;
\item
  Retirer tous les caractères de ponctuation de la chaîne \texttt{b}, puis utiliser la fonction \texttt{str\_trim()} sur le résultat pour retirer les caractères blancs du début et de la fin de la chaîne.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 7. Manipulation de tableaux de de dates}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  En utilisant la fonction \texttt{as.Date()}, stocker la date du 29 aoùt 2015 dans un objet que l'on appellera \texttt{d} puis afficher la classe de l'objet ;
\item
  À l'aide de la fonction appropriée, afficher la date du jour ;
\item
  À l'aide de la fonction \texttt{as.Date()}, stocker sous forme de date la chaîne de caractères suivante : \texttt{29-08-2015} ;
\item
  Utiliser les fonctions \texttt{as.POSIXct()} et \texttt{as.POSIXlt} pour stocker la chaîne de caractères \texttt{2015-08-29\ 20:30:56} sous forme de dates dans des objets nommés \texttt{d\_ct} et \texttt{d\_lt} respectivement ; utiliser ensuite la fonction \texttt{unclass()} sur les deux objets pour comparer la façon dont R a stocké l'information :
\item
  Utiliser la fonction appropriée du \emph{package} \{\texttt{lubridate}\} pour stocker la chaîne de caractères \texttt{2015-08-29} sous forme de date ;
\item
  Même question avec la chaîne \texttt{2015-08-29\ 20:30:56} ;
\item
  Utiliser la fonction \texttt{ymd\_hms()} pour stocker la date et l'heure actuelle, en précisant le fuseau horaire, puis afficher la date et l'heure correspondantes à New York City ;
\item
  Considérons le vecteur \texttt{x} :

  \texttt{x\ \textless{}-\ c(ymd\_hms("2015-08-29\ 20:30:56",\ tz\ =\ "Europe/Paris"),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ymd\_hms("2015-09-15\ 08:10:33",\ tz\ =\ "Europe/Paris"))}

  Extraire l'année, le mois, le jour, les heures, les minutes et les secondes du premier élément de \texttt{x} à l'aide des fonctions appropriées du \emph{package} \{\texttt{lubridate}\} ;
\item
  Appliquer les mêmes fonctions au vecteur \texttt{x} ;
\item
  Au premier élément de \texttt{x}, ajouter :
\end{enumerate}

\begin{itemize}
\tightlist
\item
  une seconde,
\item
  un jour,
\item
  un mois
\item
  deux années ;
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{10}
\tightlist
\item
  Tester si la date du premier élément de \texttt{x} vient avant celle du second élément ;
\item
  En utilisant la fonction \texttt{interval()} du \emph{package} \{\texttt{lubridate}\}, créer un intervalle de dates entre les deux éléments de \texttt{x}, puis afficher le nombre de jours, puis le nombre d'heures, puis le nombre d'années séparant les deux dates ;
\item
  En utilisant la fonction \texttt{seq()}, créer une séquence de dates avec un intervalle de 5 jours entre chaque date, commençant à la date du premier élément de \texttt{x} et se terminant à la date du second élément de \texttt{x} (la séquence sera tronquée avant) ;
\item
  Convertir en date les deux chaînes de caracères suivantes : \texttt{Sam\ 29\ Aoùt\ 2015} et \texttt{Sat\ 29\ Aug\ 2015}.
\end{enumerate}
\end{exframe}

\hypertarget{fonction}{%
\chapter{Fonction}\label{fonction}}

Jusqu'ici, nous avons utilisé des fonctions incluses dans les \emph{packages}, rédigées par d'autres personnes. Dans ce chapitre, nous allons voir comment créer ses propres fonctions.

\hypertarget{duxe9finition}{%
\section{Définition}\label{duxe9finition}}

La définition d'une nouvelle fonction suit la syntaxe suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(arguments) expression}
\end{Highlighting}
\end{Shaded}

avec \texttt{name} le nom que l'on décide de donner à la fonction, qui doit respecter les règles de nommage abordés en Section~\ref{introduction-espace-nommage}, \texttt{arguments} les arguments de la fonction, et \texttt{expression} le corps de la fonction. Comme on peut le remarquer, on utilise le symbole d'assignation : les fonctions sont des objets. L'appel de la fonction aura la syntaxe suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{name}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Il suffit donc de rajouter des parenthèses au nom de la fonction pour l'appeler. En effet, \texttt{name} désigne l'objet \texttt{R}\textasciitilde qui contient la fonction qui est appelée à l'aide de l'expression \texttt{name()}.

Par exemple, si on souhaite définir la fonction qui calcule le carré d'un nombre, voici ce que l'on peut écrire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{carre \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{\^{}}\DecValTok{2}
\CommentTok{\# Le carré de 2}
\KeywordTok{carre}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Le carré de {-}3}
\KeywordTok{carre}\NormalTok{(}\OperatorTok{{-}}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 9
\end{lstlisting}

\hypertarget{fonctions_structure}{%
\section{La structure d'une fonction}\label{fonctions_structure}}

Les fonctions en \texttt{R}, excepté les fonctions primitives du \emph{package} \{\texttt{base}\}, sont composées de trois parties :

\begin{itemize}
\tightlist
\item
  une liste d'arguments ;
\item
  un corps, contenant du code exécuté lors de l'appel à la fonction ;
\item
  un environnement, qui définit l'endroit où sont stockées les variables.
\end{itemize}

On peut accéder à ces trois parties (et les modifier) avec les fonctions \texttt{formals()} pour les arguments, \texttt{body()} pour le corps et \texttt{environment()} pour l'environnement.

\hypertarget{fonctions_structure_corps}{%
\subsection{Le corps d'une fonction}\label{fonctions_structure_corps}}

Dans le cas le plus simple, le corps d'une fonction est constitué d'une seule instruction. Si on désire en écrire plusieurs, il est nécessaire de les entourner par des accolades, pour réaliser un regroupement. Le résultat est la valeur de la dernière commande contenue dans le corps de la fonction.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x}\OperatorTok{\^{}}\DecValTok{2}
\NormalTok{  y \textless{}{-}}\StringTok{ }\NormalTok{x}
\NormalTok{  y}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2
\end{lstlisting}

Si on souhaite retourner une valeur autre part qu'à la dernière ligne, il faut utiliser la fonction \texttt{return()} (utile lorsque l'on emploie des conditions, comme nous le verrons par la suite, ou pour prévenir d'une erreur).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{return}\NormalTok{(x}\OperatorTok{\^{}}\DecValTok{2}\NormalTok{)}
  \CommentTok{\# Un commentaire de dernière ligne}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\begin{remarque}
Certains conseillent de ne pas utiliser la fonction \texttt{return()} en dernière ligne, dans la mesure où cela est d'une part inutile, et perturbe la lecture du code d'autre part.
\end{remarque}

Il est possible de retourner une liste, pouvant contenir autant d'objet que l'on souhaite.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Calculer la moyenne et l\textquotesingle{}écart{-}type pour un vecteur}
\NormalTok{stat\_des \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{moyenne =} \KeywordTok{mean}\NormalTok{(x), }\DataTypeTok{ecart\_type =} \KeywordTok{sd}\NormalTok{(x))}
\NormalTok{\}}
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{stat\_des}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $moyenne
## [1] 0.4406631
## 
## $ecart_type
## [1] 0.3486637
\end{lstlisting}

Il est également possible de ne pas afficher dans la console le résultat de l'appel à une fonction à l'aide de la fonction \texttt{invisible()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stat\_des\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{invisible}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{moyenne =} \KeywordTok{mean}\NormalTok{(x), }\DataTypeTok{ecart\_type =} \KeywordTok{sd}\NormalTok{(x)))}
\NormalTok{\}}
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{stat\_des\_2}\NormalTok{(x)}
\KeywordTok{str}\NormalTok{(}\KeywordTok{stat\_des\_2}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## List of 2
##  $ moyenne   : num 0.518
##  $ ecart_type: num 0.287
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stat\_des\_2}\NormalTok{(x)}\OperatorTok{$}\NormalTok{moyenne}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0.5177319
\end{lstlisting}

On peut afficher malgré tout le résultat d'une fonction retournant un résultat invisible en ayant recours aux parenthèses.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\KeywordTok{stat\_des\_2}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $moyenne
## [1] 0.5177319
## 
## $ecart_type
## [1] 0.2868012
\end{lstlisting}

Lorsque la dernière instruction est une assignation, nous sommes dans le cas d'un résultat invisible.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  res \textless{}{-}}\StringTok{ }\NormalTok{x}\OperatorTok{\^{}}\DecValTok{2}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\hypertarget{fonctions_structure_parametres}{%
\subsection{Les arguments d'une fonction}\label{fonctions_structure_parametres}}

Dans l'exemple de la fonction \texttt{carre()} que nous avons crée, nous avons renseigné un seul argument, appelé \texttt{x}. Si la fonction que l'on souhaite créer nécessite plusieurs arguments, il faut les séparer par une virgule.

Considérons par exemple le problème suivant. Nous disposons d'une fonction de production \(Y(L,K, M)\), qui dépend du nombre de travailleurs \(L\) et de la quantité de capital \(K\), et du matériel \(M\), telle que \(Y(L,K, M) = L^{0.3}K^{0.5}M^{2}\). Cette fonction pourra s'écrire, en \texttt{R} de la manière suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{production \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(l, k, m) l}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.3}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{k}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.5}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{m}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{fonctions_structure_parametres_appel_noms}{%
\subsubsection{Appel sans noms}\label{fonctions_structure_parametres_appel_noms}}

En reprenant l'exemple précédent, si on nous donne \(L = 60\) et \(K = 42\) et \(M = 40\), on peut en déduire la production :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{production}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{40}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 46.28945
\end{lstlisting}

On peut noter que le nom des arguments n'a pas été mentionné ici. Lors de l'appel de la fonction, \texttt{R} cherche d'abord s'il y a des arguments nommés afin de leur associer des valeurs. S'il n'y a pas de nom, il se basera sur la position donnée aux arguments.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{production}\NormalTok{(}\DataTypeTok{k =} \DecValTok{42}\NormalTok{, }\DataTypeTok{m =} \DecValTok{40}\NormalTok{, }\DataTypeTok{l =} \DecValTok{60}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 46.28945
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{production}\NormalTok{(}\DataTypeTok{k =} \DecValTok{42}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{40}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 46.28945
\end{lstlisting}

\hypertarget{fonctions_structure_parametres_defaut}{%
\subsubsection{Arguments effectifs}\label{fonctions_structure_parametres_defaut}}

On peut, lors de la définition de la fonction, choisir de donner une valeur par défaut aux arguments. On parle d'argument \texttt{formel} pour désigner les arguments de la fonction (les variables utilisées dans le corps de la fonction) et d'argument \texttt{effectif} pour désigner la valeur que l'on souhaite donner à l'argument formel. Pour définir la valeur à donner à un argument formel, on utilise le symbol d'égalité. Lors de l'appel de la fonction, si l'utilisateur ne définit pas explicitement une valeur, celle par défaut sera affectée.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# On propose de définir la valeur du capital à 42 par défaut}
\NormalTok{production\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(l, m, }\DataTypeTok{k =} \DecValTok{42}\NormalTok{) l}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.3}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{k}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.5}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{m}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
\KeywordTok{production\_2}\NormalTok{(}\DataTypeTok{l =} \DecValTok{42}\NormalTok{, }\DataTypeTok{m =} \DecValTok{40}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 41.59216
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{production\_2}\NormalTok{(}\DataTypeTok{l =} \DecValTok{42}\NormalTok{, }\DataTypeTok{m =} \DecValTok{40}\NormalTok{, }\DataTypeTok{k =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 9.076152
\end{lstlisting}

Dans l'exemple précédent, l'argument auquel nous avons donné une valeur est placé en dernier. Ce n'est pas obligatoire, mais plus pratique, si le but recherché est de ne pas avoir à saisir l'argument effectif lors de l'appel de la fonction. De plus, si l'utiliateur ne nomme pas les arguments lors de l'appel, des problèmes liés à l'ordre peuvent apparaître\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{production\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(l, }\DataTypeTok{k =} \DecValTok{42}\NormalTok{, m) l}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.3}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{k}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.5}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{m}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
\KeywordTok{production\_3}\NormalTok{(}\DataTypeTok{l =} \DecValTok{42}\NormalTok{, }\DataTypeTok{m =} \DecValTok{40}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 41.59216
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{production\_3}\NormalTok{(}\DecValTok{42}\NormalTok{, }\DecValTok{40}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in production_3(42, 40): l'argument "m" est manquant, avec aucune valeur par défaut
\end{lstlisting}

\hypertarget{fonctions_structure_parametres_appel_noms_partiels}{%
\subsubsection{Appel avec des noms partiels}\label{fonctions_structure_parametres_appel_noms_partiels}}

Par ailleurs, il est possible de ne pas saisir le nom complet des arguments lors de l'appel d'une fonction. En effet, on peut utiliser une abréviation du nom de l'argument. S'il existe une ambiguïté, \texttt{R} retourne un message d'erreur.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(premier, second, troisieme) premier }\OperatorTok{+}\StringTok{ }\NormalTok{second }\OperatorTok{+}\StringTok{ }\NormalTok{troisieme}
\KeywordTok{f}\NormalTok{(}\DataTypeTok{p =} \DecValTok{1}\NormalTok{, }\DataTypeTok{s =} \DecValTok{2}\NormalTok{, }\DataTypeTok{t =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Problème d\textquotesingle{}ambiguïté}
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(texte, nombre, nom) }\KeywordTok{print}\NormalTok{(nom)}
\KeywordTok{f}\NormalTok{(}\StringTok{"hello"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DataTypeTok{no =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in f("hello", 2, no = 3): l'argument 3 correspond à plusieurs arguments formels
\end{lstlisting}

\begin{remarque}
Si parmi les arguments de la fonction, figure l'argument \texttt{...} (plus de détails sont donnés dans la Section~@ref(fonctions\_structure\_parametres\_special), il n'est pas possible d'utiliser les abréviations.
\end{remarque}

\hypertarget{fonctions_structure_parametres_sans}{%
\subsubsection{Fonctions sans arguments}\label{fonctions_structure_parametres_sans}}

On est parfois amené à créer des fonctions qui ne prennent pas d'argument. Il suffit alors de laisser la liste d'arguments formels vide.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{sample}\NormalTok{(letters, }\DataTypeTok{size =} \DecValTok{10}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1] "q" "c" "c" "z" "o" "f" "n" "i" "o" "c"
\end{lstlisting}

\hypertarget{fonctions_structure_parametres_special}{%
\subsubsection{\texorpdfstring{L'argument spécial \texttt{...}}{L'argument spécial ...}}\label{fonctions_structure_parametres_special}}

l'argument \texttt{...} que l'on peut voir dans certaines fonctions (essayez d'évaluer \texttt{sum} par exemple) sert à indiquer que la fonction peut admettre d'autres arguments que ceux qui ont été définis. Cela sert à, dans la plupart des cas, à passer un argument à une autre fonction contenue dans le corps de la fonction que l'on appelle.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{names}\NormalTok{(}\KeywordTok{list}\NormalTok{(...))}
\KeywordTok{f}\NormalTok{(}\DataTypeTok{premier =} \DecValTok{1}\NormalTok{, }\DataTypeTok{second =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "premier" "second"
\end{lstlisting}

Attention toutefois, l'utilisation de \texttt{...} peut induire des soucis. En effet, un argument mal écrit sera passé à \texttt{...} et il n'y aura pas d'erreur de retournée. Par ailleurs, tous les arguments placés après \texttt{...} doivent être complètement nommés, pas abrégés.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 7
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DataTypeTok{an.rm =} \OtherTok{TRUE}\NormalTok{) }\CommentTok{\# Mauvaise écriture}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] NA
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DataTypeTok{na =} \OtherTok{TRUE}\NormalTok{)  }\CommentTok{\# Abréviation}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] NA
\end{lstlisting}

\hypertarget{fonctions_structure_environnement}{%
\subsection{Portée des fonctions}\label{fonctions_structure_environnement}}

Lorsque une fonction est appelée, le corps de cette fonction est interprété. Les variables ayant été définies dans le corps de la fonction ne vivent qu'à l'intérieur de celle-ci à moins d'avoir spécifié le contraire. On parle alors de \texttt{portée} des variables. Ainsi, une variable ayant une portée locale --- c'est-à-dire vivant uniquement à l'intérieur du corps de la fonction --- peut avoir le même nom qu'une variable globale --- c'est à dire définie dans l'espace de travail de la session ---, sans pour autant désigner le même objet, ou écraser cet objet.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Définition d\textquotesingle{}une variable globale}
\NormalTok{valeur \textless{}{-}}\StringTok{ }\DecValTok{1}

\CommentTok{\# Définition d\textquotesingle{}une variable locale à la fonction f}
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  valeur \textless{}{-}}\StringTok{ }\DecValTok{2}
\NormalTok{  nouvelle\_valeur \textless{}{-}}\StringTok{ }\DecValTok{3}
  \KeywordTok{print}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"valeur vaut : "}\NormalTok{,valeur))}
  \KeywordTok{print}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"nouvelle\_valeur vaut : "}\NormalTok{,valeur))}
\NormalTok{  x }\OperatorTok{+}\StringTok{ }\NormalTok{valeur}
\NormalTok{\}}

\KeywordTok{f}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "valeur vaut : 2"
## [1] "nouvelle_valeur vaut : 2"
\end{lstlisting}

\begin{lstlisting}
## [1] 5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# valeur n\textquotesingle{}a pas été modifiée}
\NormalTok{valeur}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# nouvelle\_valeur n\textquotesingle{}existe pas en dehors de f()}
\NormalTok{nouvelle\_valeur}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Error in eval(expr, envir, enclos): objet 'nouvelle_valeur' introuvable
\end{lstlisting}

Sans trop rentrer trop dans les détails, il semble important de connaître quelques principes à propos de la portée des variables. Les variables sont définies dans des environnements, qui sont embriqués les uns dans les autres. Si une variable n'est pas définie dans le corps d'une fonction, \texttt{R} ira chercher dans un environnement parent.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{valeur \textless{}{-}}\StringTok{ }\DecValTok{1}
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  x }\OperatorTok{+}\StringTok{ }\NormalTok{valeur}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

Si on définit une fonction à l'intérieur d'une autre fonction, et qu'on appelle une variable non définie dans le corps de cette fonction, \texttt{R} ira chercher dans l'environnement directement supérieur. S'il ne trouve pas, il ira chercher dans l'environnement encore supérieur, et ainsi de suite.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La variable valeur n\textquotesingle{}est pas définie dans g(). R va alors chercher dans f().}
\NormalTok{valeur \textless{}{-}}\StringTok{ }\DecValTok{1}
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  valeur \textless{}{-}}\StringTok{ }\DecValTok{2}
\NormalTok{  g \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{    x }\OperatorTok{+}\StringTok{ }\NormalTok{valeur}
\NormalTok{  \}}
  \KeywordTok{g}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La variable valeur n\textquotesingle{}est définie ni dans g() ni dans f()}
\CommentTok{\# mais dans l\textquotesingle{}environnement supérieur (global, ici)}
\NormalTok{valeur \textless{}{-}}\StringTok{ }\DecValTok{1}
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  g \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{    x }\OperatorTok{+}\StringTok{ }\NormalTok{valeur}
\NormalTok{  \}}
  \KeywordTok{g}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

Si on définit une variable dans le corps d'une fonction et que l'on souhaite qu'elle soit accessible dans l'environnement global, on peut utiliser le symbole \texttt{\textless{}\textless{}-}, ou bien la fonction \texttt{assign} (pratique peu recommandable).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rm}\NormalTok{(x)}
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  x \textless{}\textless{}{-}}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En utilisant assign}
\KeywordTok{rm}\NormalTok{(x)}
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
  \CommentTok{\# envir = .GlobalEnv signifique que l\textquotesingle{}on veut définir dans l\textquotesingle{}environnement global}
  \KeywordTok{assign}\NormalTok{(}\DataTypeTok{x =} \StringTok{"x"}\NormalTok{, }\DataTypeTok{value =}\NormalTok{ x }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{, }\DataTypeTok{envir =}\NormalTok{ .GlobalEnv)}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 5
\end{lstlisting}

\hypertarget{documentation}{%
\section{Documentation}\label{documentation}}

Lorsque l'on créé une fonction, il est important de bien la documenter afin de rendre son utilisation facilitée (par les autres mais également par soi-même).

Il existe un \emph{package} (\{\texttt{roxygen2}\}) qui permet de réaliser des fichiers de documentation des fonctions que l'on souhaite exporter au sein d'un \emph{package}. Ces notes de cours ne visent pas à expliquer comment créer un \emph{package}. Toutefois, il n'est pas inutile d'emprunter une technique utilisée par de nombreuses personnes qui créent des \emph{packages} pour am\&liorer la documuentation de nos fonctions dans nos codes.

L'idée est d'ajouter un commentaire \texttt{roxygen} en pré-fixe de la définition de la fonction. Ce commentaire s'écrit à l'aide d'un croisillon suivi d'un guillemet simple : \texttt{\#\textquotesingle{}}. Reprenons la fonction de production, et ajoutons un commentaire \texttt{roxygen} précisant :

\begin{itemize}
\tightlist
\item
  ce que fait la fonction
\item
  quels sont ses arguments (\texttt{@param})
\item
  ce qu'elle retourne (\texttt{@return})
\item
  deux exemples d'utilisation
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Calcul le niveau de production}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @param l montant de force de travail}
\CommentTok{\#\textquotesingle{} @param k montant de capital}
\CommentTok{\#\textquotesingle{} @param m montant de matériel}
\CommentTok{\#\textquotesingle{} @return Le niveau de production d\textquotesingle{}une Cobb{-}Doublas, fonction de \textbackslash{}code\{l\}, \textbackslash{}code\{k\} et \textbackslash{}code\{m\}}
\CommentTok{\#\textquotesingle{} @examples}
\CommentTok{\#\textquotesingle{} production(k = 42, l = 60, m = 40)}
\CommentTok{\#\textquotesingle{} production(40, 20, 60)}
\NormalTok{production \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(l, k, m) \{}
\NormalTok{  l}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.3}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{k}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.5}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{m}\OperatorTok{\^{}}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Plus de détails sont disponibles au \href{(https://r-pkgs.org/man.html)}{chapitre 10} du livre ``R Packages'' d'Hadley Wickham et Jennifer Bryan.

\hypertarget{exercices-1}{%
\section{Exercices}\label{exercices-1}}

\begin{exframe}
\textbf{Exercice 1. Création de fonctions}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Créer une fonction nommée \texttt{somme\_n\_entiers} qui retourne la somme des \(n\) premiers entiers. Son seul argument sera \texttt{n} ;
  2.Utiliser la fonction \texttt{somme\_n\_entiers()} pour calculer la somme des 100 premiers entiers ;
\item
  Terminer la fonction par l'assignation du résultat dans un objet nommé \texttt{res}, puis évaluer l'expression suivante : \texttt{somme\_n\_entiers(100)}. Que peut-on constater ?
\item
  Charger les données \texttt{diamonds} du \emph{package} \{\texttt{ggplot2}\} dans la session \texttt{R} à l'aide de l'expression suivante : \texttt{data(diamonds,\ package\ =\ "ggplot2")}

  Créer une fonction que l'on appellera \texttt{prix\_diamant\_coupe()}, qui, quand on lui fournit la valeur de la coupe du diamant sous forme de caractères (\texttt{Fair}, \texttt{Good}, \texttt{Very\ Good}, \texttt{Premium}, ou \texttt{Ideal}), filtre le tableau de données \texttt{diamonds} pour ne conserver que les observations pour lesquelles la coupe du diamant correspond à celle indiquée en argument, et retourne le prix moyen des observations de la base ainsi filtrée ;
\item
  Reprendre le code de la fonction précédente, et le modifier pour retourner à présent une liste de deux éléments : (i) la moyenne des prix et (ii) l'écart-type ;
\item
  Créer la fonction \texttt{resume\_diamant\_coupe\_couleur()}, qui pour une coupe et une couleur de diamant données, retourne une liste de deux éléments : (i) la moyenne des prix et (ii) l'écart-type pour les diamants possédant cette coupe et cette couleur (la couleur du diamant est une lettre allant de \texttt{J} pour les pires, à \texttt{D} pour les meilleurs). Tester la fonction pour la coupe \texttt{Fair} et la couleur \texttt{D} ;
\item
  Reprendre la fonction précédente, et lui attribuer la valeur \texttt{D} (en chaîne de caractères) comme argument effectif pour la couleur. Tester alors l'appel à la fonction en précisant :
\end{enumerate}

\begin{itemize}
\tightlist
\item
  la coupe \texttt{Fair} et la couleur \texttt{D},
\item
  la coupe \texttt{Fair}, mais pas d'argument pour la couleur,
\item
  la coupe \texttt{Fair} et la couleur \texttt{E},
\item
  la coupe non précisée mais la couleur \texttt{E} ;
\end{itemize}
\end{exframe}

\begin{exframe}
\textbf{Exercice 2. Création de fonctions}

Supposons que les adresses e-mails des étudiant•e•s d'Aix-Marseille Université sont constituées de la manière suivante : le prénom et le nom de famille séparés par un point, le symbole arobase et le enfin le nom de domaine. Supposons de plus que les étudiant•e•s ont un seul prénom, et aucune particule au nom de famille. La syntaxe des adresses e-mail est donc comme suit : \texttt{nom.prenom@etu.univ-amu.fr}.

\texttt{emails\ \textless{}-\ c("marie.petit@etu.univ-amu.fr",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "jean.dupont@etu.univ-amu.fr",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "isabelle.martinez@etu.univ-amu.fr",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "pierre.moreau@etu.univ-amu.fr")}

Créer une fonction, qui à partir d'\textbf{une seule} adresse e-mail d'un•e étudiant•e, retourne un tibble contenant trois variables : le prénom, le nom et l'adresse e-mail de cet•te étudiant•e.
\end{exframe}

\hypertarget{boucles}{%
\chapter{Boucles et calculs vectoriels}\label{boucles}}

Il existe deux sortes de boucles dans \texttt{R}. Celles pour lesquelles les itérations continuent tant qu'une condition n'est pas invalidée (\texttt{while()}), et celles pour lesquelles le nombre d'itérations est défini au moment de lancer la boucle (\texttt{for()}).

Avant de présenter chacune de ces fonctions, il est nécessaire de préciser que les boucles ne sont pas le point fort de \texttt{R}. Dès que l'on souhaite appliquer une fonction à chaque élément d'un vecteur, et/ou que le résultat de chaque itération ne dépend pas de l'itération précédente, il est préférable de vectoriser les calculs (voir Section~@ref(boucles\_vectorisation)).

\hypertarget{boucles_boucles}{%
\section{Les boucles}\label{boucles_boucles}}

\hypertarget{boucles_boucles_while}{%
\subsection{\texorpdfstring{Les boucles avec \texttt{while()}}{Les boucles avec while()}}\label{boucles_boucles_while}}

Quand on souhaite répéter un calcul tant qu'une condition est satisfaite, on utilise la fonction \texttt{while()}, avec la syntaxte suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while}\NormalTok{(condition) instruction}
\end{Highlighting}
\end{Shaded}

avec \texttt{condition} un logique, comme vu dans la Section~@ref(manip\_operateurs\_logiques), et \texttt{instruction} du code, qui peut être entouré d'accolades si on souhaite évaluer plusieurs instructions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\DecValTok{100}
\ControlFlowTok{while}\NormalTok{(x}\OperatorTok{/}\DecValTok{3} \OperatorTok{\textgreater{}}\StringTok{ }\DecValTok{1}\NormalTok{)\{}
\NormalTok{  x \textless{}{-}}\StringTok{ }\NormalTok{x}\OperatorTok{/}\DecValTok{3}
\NormalTok{\}}
\NormalTok{x}\OperatorTok{/}\DecValTok{3} \OperatorTok{\textgreater{}}\StringTok{ }\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1.234568
\end{lstlisting}

\hypertarget{boucles_boucles_for}{%
\subsection{\texorpdfstring{Les boucles avec \texttt{for()}}{Les boucles avec for()}}\label{boucles_boucles_for}}

Quand on connaît le nombre d'itérations à l'avance, on peut utiliser la fonction \texttt{for()}. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(variable }\ControlFlowTok{in}\NormalTok{ vector) instruction}
\end{Highlighting}
\end{Shaded}

avec \texttt{variable} le nom d'une variable locale à la fonction \texttt{for()}, \texttt{vector} un vecteur à \texttt{n} éléments définissant les valeurs que prendra \texttt{variable} pour chacun des \texttt{n} tours, et \texttt{instruction} le code à exécuter à chaque itération.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(nom }\ControlFlowTok{in}  \KeywordTok{c}\NormalTok{(}\StringTok{"Sonia"}\NormalTok{, }\StringTok{"Anne{-}Hélène"}\NormalTok{, }\StringTok{"Julien{-}Yacine"}\NormalTok{)) }\KeywordTok{print}\NormalTok{(nom)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Sonia"
## [1] "Anne-Hélène"
## [1] "Julien-Yacine"
\end{lstlisting}

On peut utiliser la fonction \texttt{for()} pour remplir les éléments d'une liste, ou d'un vecteur. à chaque itération, \texttt{R} doit trouver le vecteur de destination en mémoire, créer un nouveau vecteur qui permettra de contenir plus de données, copier données depuis l'ancien vecteur pour les insérer dans le nouveau, et enfin supprimer l'ancien vecteur (Ross \protect\hyperlink{ref-Ross_2014_Vectorization}{2014}). C'est une opération coûteuse en temps. Un moyen de rendre cette allocation plus efficace est de créer \emph{a priori} le vecteur ou la liste en le remplissant avec des données manquantes. Ainsi, \texttt{R} n'aura pas besoin de ré-allouer la mémoire à chaque itération.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mauvaise manière}
\NormalTok{resultat \textless{}{-}}\StringTok{ }\OtherTok{NULL}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq\_len}\NormalTok{(}\DecValTok{3}\NormalTok{)) \{}
\NormalTok{  resultat[i] \textless{}{-}}\StringTok{ }\NormalTok{i}
\NormalTok{\}}
\NormalTok{resultat}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Manière plus économique}
\NormalTok{resultat \textless{}{-}}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq\_len}\NormalTok{(}\DecValTok{3}\NormalTok{)) \{}
\NormalTok{  resultat[i] \textless{}{-}}\StringTok{ }\NormalTok{i}
\NormalTok{\}}
\NormalTok{resultat}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3
\end{lstlisting}

\hypertarget{boucles_boucles_conditions}{%
\subsection{Les conditions}\label{boucles_boucles_conditions}}

On peut soumettre l'exécution de codes en \texttt{R} à conditions que certaines conditions soient honorées.

\hypertarget{boucles_boucles_conditions_if}{%
\subsubsection{\texorpdfstring{Les instructions \texttt{if} \ldots{} \texttt{else}}{Les instructions if \ldots{} else}}\label{boucles_boucles_conditions_if}}

Les instructions \texttt{if} et \texttt{else} fournissent un moyen d'exécuter du code si une condition est respectée ou non. La syntaxe prend deux formes :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Première forme (pas de code si condition == FALSE)}
\ControlFlowTok{if}\NormalTok{ (condition) instruction}

\CommentTok{\# Seconde forme}
\ControlFlowTok{if}\NormalTok{ (condition) instruction si vrai }\ControlFlowTok{else}\NormalTok{ instruction si faux}
\end{Highlighting}
\end{Shaded}

avec \texttt{condition} un logique et \texttt{instruction} du code à évaluer si la condition est satisfaite. à nouveau, on peut avoir recours aux accolades pour créer des regroupements.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Simple condition}
\NormalTok{x \textless{}{-}}\StringTok{ }\DecValTok{2}
\ControlFlowTok{if}\NormalTok{(x }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Hello"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x \textless{}{-}}\StringTok{ }\DecValTok{3}
\ControlFlowTok{if}\NormalTok{(x }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}

\CommentTok{\# Avec des instructions dans le cas contraire}
\ControlFlowTok{if}\NormalTok{(x }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"Hello"}\NormalTok{) }\ControlFlowTok{else} \KeywordTok{print}\NormalTok{(}\StringTok{"x est différent de 2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "x est différent de 2"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{(x }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{)\{}
  \KeywordTok{print}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}\CommentTok{\# x != 2}
\NormalTok{  x \textless{}{-}}\StringTok{ }\NormalTok{x}\DecValTok{{-}1}
  \KeywordTok{print}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"La nouvelle valeur de x : "}\NormalTok{, x))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "La nouvelle valeur de x : 2"
\end{lstlisting}

\begin{remarque}
Attention, lorsque l'on fait des regroupements et qu'on utilise la structure \texttt{if} et \texttt{else}, il est nécessaire d'écrire le mot \texttt{else} sur la même ligne que la parenthèse fermante du groupe d'instructions à réaliser dans le de la condition du \texttt{if} vérifiée.
\end{remarque}

\hypertarget{boucles_boucles_conditions_switch}{%
\subsubsection{\texorpdfstring{La fonction \texttt{switch()}}{La fonction switch()}}\label{boucles_boucles_conditions_switch}}

Avec la fonction \texttt{switch()}, on peut indiquer à \texttt{R} d'exécuter un code en fonction du résultat obtenu lors d'un test. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch}\NormalTok{(valeur\_test,}
       \DataTypeTok{cas\_1 =}\NormalTok{ \{}
\NormalTok{         instruction\_cas\_}\DecValTok{1}
\NormalTok{       \},}
       \DataTypeTok{cas\_2 =}\NormalTok{ \{}
\NormalTok{         instruction\_cas\_}\DecValTok{2}
\NormalTok{       \},}
\NormalTok{       ...}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

avec \texttt{valeur\_test} un nombre ou une chaîne de caractères. Si \texttt{valeur\_test} vaut \texttt{cas\_1}, alors uniquement \texttt{instruction\_cas\_1} sera évaluée, si \texttt{valeur\_test} vaut \texttt{cas\_2}, alors ce sera \texttt{instruction\_cas\_2} qui le sera, et ainsi de suite. On peut rajouter une valeur par défaut en utilisant la syntaxte suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch}\NormalTok{(valeur\_test,}
       \DataTypeTok{cas\_1 =}\NormalTok{ \{}
\NormalTok{         instruction\_cas\_}\DecValTok{1}
\NormalTok{       \},}
       \DataTypeTok{cas\_2 =}\NormalTok{ \{}
\NormalTok{         instruction\_cas\_}\DecValTok{2}
\NormalTok{       \},}
\NormalTok{       \{}
\NormalTok{        instruction\_defaut }
\NormalTok{       \}}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

Voici un exemple d'utilisation, issu de la page d'aide de la fonction.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{centre \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, type) \{}
  \ControlFlowTok{switch}\NormalTok{(type,}
         \DataTypeTok{mean =} \KeywordTok{mean}\NormalTok{(x),}
         \DataTypeTok{median =} \KeywordTok{median}\NormalTok{(x))}
\NormalTok{\}}
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{rcauchy}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{centre}\NormalTok{(x, }\StringTok{"mean"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0.9196552
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{centre}\NormalTok{(x, }\StringTok{"median"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0.2626783
\end{lstlisting}

\hypertarget{boucles_boucles_repeat}{%
\subsection{\texorpdfstring{L'instruction \texttt{repeat} \ldots{} \texttt{break}}{L'instruction repeat \ldots{} break}}\label{boucles_boucles_repeat}}

L'instruction \texttt{repeat}, \ldots{} \texttt{break} permet de répéter une expression. Il est nécessaire d'ajouter un test d'arrêt, à l'aide de l'instruction \texttt{break}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i \textless{}{-}}\StringTok{ }\DecValTok{1}
\ControlFlowTok{repeat}\NormalTok{ \{}
\NormalTok{  i \textless{}{-}}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
  \ControlFlowTok{if}\NormalTok{(i }\OperatorTok{==}\StringTok{ }\DecValTok{3}\NormalTok{) }\ControlFlowTok{break}
\NormalTok{\}}
\NormalTok{i}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 3
\end{lstlisting}

\hypertarget{boucles_boucles_next}{%
\subsection{\texorpdfstring{L'instruction \texttt{next} \ldots{} \texttt{break}}{L'instruction next \ldots{} break}}\label{boucles_boucles_next}}

L'instruction \texttt{next} \ldots{} \texttt{break} autorise de passer immédiatement à l'itération suivante d'une boucle \texttt{for}, \texttt{while} ou \texttt{repeat}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resul \textless{}{-}}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{(i }\OperatorTok{==}\StringTok{ }\DecValTok{5}\NormalTok{) }\ControlFlowTok{next}
\NormalTok{  resul[i] \textless{}{-}}\StringTok{ }\NormalTok{i}
\NormalTok{\}}
\CommentTok{\# Le 5e élément de resul est resté non{-}disponible}
\NormalTok{resul}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1]  1  2  3  4 NA  6  7  8  9 10
\end{lstlisting}

\hypertarget{boucles_boucles_progressbar}{%
\subsection{Barre de progression}\label{boucles_boucles_progressbar}}

Lorsque l'exécution d'une boucle prend du temps, il peut être intéressant d'avoir une idée de l'état d'avancement des itérations. Pour cela, il est bien sûr possible d'afficher une valeur dans la console à chaque tour, chaque 10 tours, etc.

La fonction \texttt{txtProgressBar()} du \emph{package} \{\texttt{utils}\} permet un affichage d'une barre de progression dans la console. Il suffit de lui fournir une valeur minimale et maximale, et de la mettre à jour à chaque itération. l'argument \texttt{style} autorise de surcroît à choisir un ``style'' pour la barre. Le style numéro 3 affiche un pourcentage de progression, et est utile lorsque d'autres résultats sont affichés dans la console lors de l'exécution de la boucle, dans la mesure où la barre est de nouveau affichée au complet dans la console si nécessaire.

Dans l'exemple qui suit, à chacun des dix tours, une pause \(0.1\) seconde est effectuée, puis la barre de progression est mise à jour.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nb\_tours \textless{}{-}}\StringTok{ }\DecValTok{10}
\NormalTok{p\_b \textless{}{-}}\StringTok{ }\KeywordTok{txtProgressBar}\NormalTok{(}\DataTypeTok{min =} \DecValTok{1}\NormalTok{, }\DataTypeTok{max =}\NormalTok{ nb\_tours, }\DataTypeTok{style =} \DecValTok{3}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{nb\_tours)\{}
  \KeywordTok{Sys.sleep}\NormalTok{(}\FloatTok{0.1}\NormalTok{)}
  \KeywordTok{setTxtProgressBar}\NormalTok{(p\_b, i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Si l'exécution est vraiment longue, et qu'on est impatient de connaître les résultats, il existe de plus une fonction amusante dans le \emph{package} \texttt{beepr}, qui porte le nom de \texttt{beep()}. Plusieurs sons peuvent être utilisés (voir la page d'aide de la fonction).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(beepr)}
\KeywordTok{beep}\NormalTok{(}\StringTok{"mario"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{boucles_vectorisation}{%
\section{La vectorisation}\label{boucles_vectorisation}}

Comme indiqué plus haut, les boucles sont des opérations lentes en \texttt{R}. Il est cependant possible, dans de nombreux cas, d'éviter de les employer, en ayant recours à la vectorisation : au lieu d'appliquer une fonction à un scalaire, on l'applique à un vecteur. En fait, nous avons déjà eu recours à maintes reprises aux calculs vectoriels. En effet, lorsque nous avons procédé à des additions, des multiplications, etc. sur des vecteurs, nous avons effectué des calculs vectoriels.

Empruntons un exemple à Burns (\protect\hyperlink{ref-Burns_2011_R}{2011}) : dans des langages comme le \texttt{C}, pour effectuer la somme des logarithmes naturels des \(n\) premiers entiers, voici une manière de faire :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Somme des logarithmes des 10 premiers entiers}
\NormalTok{somme\_log \textless{}{-}}\StringTok{ }\DecValTok{0}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq\_len}\NormalTok{(}\DecValTok{10}\NormalTok{))\{}
\NormalTok{  somme\_log \textless{}{-}}\StringTok{ }\NormalTok{somme\_log }\OperatorTok{+}\StringTok{ }\KeywordTok{log}\NormalTok{(i)}
\NormalTok{\}}
\NormalTok{somme\_log}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 15.10441
\end{lstlisting}

Il est possible d'obtenir le même résultat, à la fois d'une manière plus élégante, mais surtout plus efficace en vectorisant le calcul :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{log}\NormalTok{(}\KeywordTok{seq\_len}\NormalTok{(}\DecValTok{10}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 15.10441
\end{lstlisting}

Ou bien, en utilisant l'opérateur Pipe, afin d'éviter la lecture pénible de cette composée de fonctions :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq\_len}\NormalTok{(}\DecValTok{10}\NormalTok{) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{log}\NormalTok{() }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 15.10441
\end{lstlisting}

Derrière ce code, la fonction \texttt{log()} applique la fonction logarithme sur toutes les valeurs du vecteur donné en argument. La fonction \texttt{sum()}, quant à elle, se charge d'additionner tous les éléments du vecteur qui lui est donné en argument. Ces deux fonctions utilisent la vectorisation, mais d'une manière différente : la fonction \texttt{log()} applique une opération à chaque élément d'un vecteur, tandis que la fonction \texttt{sum()} produit un résultat basé sur la totalité du vecteur. L'avantage d'utiliser des fonctions vectorielles plutôt que d'écrire une boucle pour effectuer le calcul, est que ces premières font appel à des fonctions rédigées en \texttt{C} ou \texttt{FORTRAN}, qui utilisent aussi des boucles, mais comme ce sont des langages compilés et non pas interprétés, les itérations sont réalisées dans un temps réduit.

Il existe des fonctions, rédigées en \texttt{C} qui effectuent des boucles \texttt{for}. On leur donne souvent le nom de "\emph{fonctions de la famille apply}'`. Il ne s'agit pas de la vectorisation, mais ces fonctions sont souvent mentionnées dès que l'on parle de ce sujet. Ce sont des fonctionnelles qui prennent une fonction en \emph{input} et retournent un vecteur en \emph{output} (Wickham \protect\hyperlink{ref-Wickham_2014_Advanced_R_Functionals}{2014}). Ces fonctions sont très utilisées, mais elles souffrent d'un manque d'uniformité. En effet, elles ont été rédigées par des personnes différentes, ayant chacune leur convention. Le \emph{package} \{\texttt{plyr}\} remédie à ce problème, et ajoute par la même occasion des fonctions supplémentaires, pour couvrir plus de cas que les "\emph{fonctions de la famille apply}''. Plus récemment, le \emph{package} \{\texttt{purrr}\} a également introduit des fonctions de ce type qui seront présentées ici.

Nous allons donc nous attarder dans un premier temps les fonctions du \emph{package} \{\texttt{purr}\}. Puis, afin d'en conserver une trace, sur les fonctions du \emph{package} \{\texttt{purrr}\} ainsi que celles du \emph{package} \{\texttt{base}\}.

\hypertarget{boucles_vectorisation_purrr}{%
\section{\texorpdfstring{Avec \{\texttt{purrr}\}}{Avec \{purrr\}}}\label{boucles_vectorisation_purrr}}

Le \emph{package} \{\texttt{purrr}\} propose de nombreuses fonctions permettant de manipuler les listes et les tableaux de données. Dans cette partie, nous allons nous concentrer sur les fonctions de ce \emph{package} qui permettent d'appliquer des opérations sur chaque élément d'une liste ou sur chaque colonne d'un tableau de données. Le nom de ces fonctions commence par le préfixe \texttt{map}. Si la structure du résultat voulu est différente d'une liste, le nom de la fonction à utiliser se poursuit par un suffixe désignant la structure désirée.

\begin{longtable}[]{@{}lr@{}}
\toprule
\begin{minipage}[b]{0.26\columnwidth}\raggedright
Fonction\strut
\end{minipage} & \begin{minipage}[b]{0.68\columnwidth}\raggedleft
Résultat\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.26\columnwidth}\raggedright
\texttt{map()}\strut
\end{minipage} & \begin{minipage}[t]{0.68\columnwidth}\raggedleft
Liste\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.26\columnwidth}\raggedright
\texttt{map\_chr()}\strut
\end{minipage} & \begin{minipage}[t]{0.68\columnwidth}\raggedleft
Vecteur de caractères\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.26\columnwidth}\raggedright
\texttt{map\_dbl()}\strut
\end{minipage} & \begin{minipage}[t]{0.68\columnwidth}\raggedleft
Vecteur de \emph{doubles}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.26\columnwidth}\raggedright
\texttt{map\_int()}\strut
\end{minipage} & \begin{minipage}[t]{0.68\columnwidth}\raggedleft
Vecteur d'entiers\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.26\columnwidth}\raggedright
\texttt{map\_lgl()}\strut
\end{minipage} & \begin{minipage}[t]{0.68\columnwidth}\raggedleft
Vecteur de booléens\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.26\columnwidth}\raggedright
\texttt{map\_dfr()}\strut
\end{minipage} & \begin{minipage}[t]{0.68\columnwidth}\raggedleft
\emph{data frame} créé en concaténant par les lignes (\texttt{rows}) à chaque itération\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.26\columnwidth}\raggedright
\texttt{map\_dfc()}\strut
\end{minipage} & \begin{minipage}[t]{0.68\columnwidth}\raggedleft
\emph{data frame} créé en concaténant par les colonnes (\texttt{columns}) à chaque itération\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Ces fonctions prennent les arguments suivants :

\begin{itemize}
\tightlist
\item
  \texttt{.x} : une liste ou un vecteur ;
\item
  \texttt{.f} : une fonction, une formule (qui sera transformée automatiquement en fonction) ou un vecteur / une liste ;
\item
  \texttt{...} : des arguments additionnels passés à la fonction appliquée à chaque élément.
\end{itemize}

\hypertarget{listes-ou-vecteurs-en-input}{%
\subsection{\texorpdfstring{Listes ou vecteurs en \emph{input}}{Listes ou vecteurs en input}}\label{listes-ou-vecteurs-en-input}}

Lorsque l'on donne une liste ou un vecteur à l'argument \texttt{.x} des fonctions de type \texttt{map}, la fonction (ou la formule) donnée en argument \texttt{.f} est appliquée à chaque élément de la liste ou du vecteur d'entrée. La structure du résultat dépend de la fonction \texttt{map} utilisée, qui est précisée à l'aide du suffixe du nom de la fonction.

Prenons un exemple. Admettons que l'on dispose d'une liste de longueur 100, dont chaque élément contient 50 valeurs numériques. On peut faire face à ce type de données lorsqu'on souhaite réaliser des simulations par ré-échantillonnage, par exemple. Dans cet exemple, nous aurions au préalable réalisé 100 rééchantillonnage différents. Admettons que l'on souhaite connaître la moyenne de chaque ré-échantillon.

Dans un premier temps, générons une liste contenant 50 valeurs dans un 100 éléments. Les 50 valeurs seront tirées ici selon une loi Normale dont les arguments sont aléatoirement tirées.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{263}\NormalTok{)}
\NormalTok{simulations \textless{}{-}}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\DataTypeTok{mode =} \StringTok{"list"}\NormalTok{, }\DataTypeTok{length =} \DecValTok{100}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(simulations))\{}
\NormalTok{  simulations[[i]] \textless{}{-}}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DataTypeTok{n =} \DecValTok{50}\NormalTok{,}
                            \DataTypeTok{mean =} \KeywordTok{sample}\NormalTok{(}\OperatorTok{{-}}\DecValTok{10}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{),}
                            \DataTypeTok{sd =} \KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DataTypeTok{min=}\DecValTok{1}\NormalTok{, }\DataTypeTok{max =} \DecValTok{5}\NormalTok{))}
\NormalTok{\}}
\KeywordTok{length}\NormalTok{(simulations)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 100
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(simulations[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -10.233237  -8.904499 -10.737834  -7.454745  -9.909407  -8.800618
\end{lstlisting}

Nous souhaitons donc calculer la moyenne de chacun des 100 éléments de cette liste. Avec une boucle \texttt{for}, on pourrait faire comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean\_samples \textless{}{-}}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\DataTypeTok{mode=}\StringTok{"numeric"}\NormalTok{, }\DataTypeTok{length =} \DecValTok{100}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(simulations)) }
\NormalTok{  mean\_samples[[i]] \textless{}{-}}\StringTok{ }\KeywordTok{mean}\NormalTok{(simulations[[i]])}

\KeywordTok{head}\NormalTok{(mean\_samples)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -10.220707   9.918496  -8.248388  -6.879007  -7.120338  -7.047220
\end{lstlisting}

De manière équivalente, et avec un temps d'exécution comparable, on peut utiliser une des fonctions du \emph{package} \{\texttt{purrr}\}. Ici, nous voulons appliquer à une liste en entrée, une fonction (\texttt{mean()}) sur chacun des éléments, puis obtenir le résultat final sous la forme d'un vecteur de numériques. Nous pouvons de fait utiliser la fonction \texttt{map\_dbl()} comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean\_samples\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{map\_dbl}\NormalTok{(simulations, mean)}
\KeywordTok{head}\NormalTok{(mean\_samples\_}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -10.220707   9.918496  -8.248388  -6.879007  -7.120338  -7.047220
\end{lstlisting}

Cette méthode a l'avantage de produire un code plus élégant et plus rapide à lire.

On peut également faire appel à l'opérateur Pipe pour rendre la lecture encore plus aisée :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean\_samples\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{simulations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map\_dbl}\NormalTok{(mean)}
\end{Highlighting}
\end{Shaded}

Admettons maintenant que nous voulons calculer le premier quartile empirique de chaque élément de \texttt{simulations}. Pour ce faire, il faut appliquer la fonction \texttt{quantile()}, en précisant à l'aide de l'argument \texttt{probs} que nous voulons le quantile d'ordre 0.25. Si on désire utiliser la fonction \texttt{map\_dbl()}, il faut ajouter un argument à cette dernière pour que celui-ci soit transmis à la fonction \texttt{quantile()} (il s'agit de fait d'appeler l'argument \texttt{...} de la fonction \texttt{map\_dbl()}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simulations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map\_dbl}\NormalTok{(quantile, }\DataTypeTok{probs =} \FloatTok{.25}\NormalTok{) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{head}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -11.110399   8.129051 -11.295354  -8.150094  -9.325573  -8.541390
\end{lstlisting}

Si à présent, nous souhaitons appliquer plusieurs fonctions à chaque élément de notre liste et récupérer le résultat sous la forme d'un tableau de données, on peut utiliser la fonction \texttt{map\_df()}. Admettons que l'on souhaite obtenir, pour chaque élément, la moyenne des valeurs, le premier et le troisième quartiles. On peut procéder comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simulations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map\_df}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x)\{}
    \KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mean =} \KeywordTok{mean}\NormalTok{(x),}
           \DataTypeTok{q1 =} \KeywordTok{quantile}\NormalTok{(x, }\DataTypeTok{probs =} \FloatTok{.25}\NormalTok{),}
           \DataTypeTok{q3 =} \KeywordTok{quantile}\NormalTok{(x, }\DataTypeTok{probs =} \FloatTok{.75}\NormalTok{))}
\NormalTok{  \})}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 100 x 3
##      mean      q1    q3
##     <dbl>   <dbl> <dbl>
##  1 -10.2  -11.1   -9.37
##  2   9.92   8.13  12.0 
##  3  -8.25 -11.3   -5.24
##  4  -6.88  -8.15  -5.33
##  5  -7.12  -9.33  -5.17
##  6  -7.05  -8.54  -5.38
##  7   4.93   3.44   6.22
##  8   1.74   0.946  2.52
##  9  -4.57  -6.14  -2.94
## 10   9.12   5.77  12.1 
## # ... with 90 more rows
\end{lstlisting}

Dans l'exemple précédent, à chaque itération, les fonctions \texttt{mean()} et \texttt{quantile()} ont été évaluées sur l'élément courant que nous avons décidé d'appeler \texttt{x}. Le résultat de l'évaluation de ces fonctions a été, à chaque itération, consigné dans un tableau, à l'aide de la fonction \texttt{tibble()}.

Afin d'éviter de devoir écrire \texttt{function(x)}, il est possible d'utiliser un raccourci : \texttt{\textasciitilde{}}. L'élément courant auquel on applique une fonction est alors désigné par le symbole \texttt{.} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simulations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map\_df}\NormalTok{(}\OperatorTok{\textasciitilde{}}\KeywordTok{tibble}\NormalTok{(}
    \DataTypeTok{mean =} \KeywordTok{mean}\NormalTok{(.),}
           \DataTypeTok{q1 =} \KeywordTok{quantile}\NormalTok{(., }\DataTypeTok{probs =} \FloatTok{.25}\NormalTok{),}
           \DataTypeTok{q3 =} \KeywordTok{quantile}\NormalTok{(., }\DataTypeTok{probs =} \FloatTok{.75}\NormalTok{)}
\NormalTok{  ))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 100 x 3
##      mean      q1    q3
##     <dbl>   <dbl> <dbl>
##  1 -10.2  -11.1   -9.37
##  2   9.92   8.13  12.0 
##  3  -8.25 -11.3   -5.24
##  4  -6.88  -8.15  -5.33
##  5  -7.12  -9.33  -5.17
##  6  -7.05  -8.54  -5.38
##  7   4.93   3.44   6.22
##  8   1.74   0.946  2.52
##  9  -4.57  -6.14  -2.94
## 10   9.12   5.77  12.1 
## # ... with 90 more rows
\end{lstlisting}

On peut noter que dans le résultat final, les tableaux créés à chaque itération ont été collés par lignes. C'est le cas puisque nous avons fait appel à la fonction \texttt{map\_df()}. Si en revanche on supprime le suffixe \texttt{\_df()} de cette fonction, et que nous utilions uniquement \texttt{map()}, alors le résultat final sera rétribué dans une liste de la même longueur que celle donnée en \emph{input} à l'argument \texttt{.x} (c'est-à-dire \texttt{simulations} dans notre exemple) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tmp \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{simulations }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map}\NormalTok{(}\OperatorTok{\textasciitilde{}}\KeywordTok{tibble}\NormalTok{(}
    \DataTypeTok{mean =} \KeywordTok{mean}\NormalTok{(.),}
    \DataTypeTok{q1 =} \KeywordTok{quantile}\NormalTok{(., }\DataTypeTok{probs =} \FloatTok{.25}\NormalTok{),}
    \DataTypeTok{q3 =} \KeywordTok{quantile}\NormalTok{(., }\DataTypeTok{probs =} \FloatTok{.75}\NormalTok{))}
\NormalTok{  )}
\KeywordTok{length}\NormalTok{(tmp)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 100
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tmp[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 1 x 3
##    mean    q1    q3
##   <dbl> <dbl> <dbl>
## 1 -10.2 -11.1 -9.37
\end{lstlisting}

\hypertarget{tibbles-en-input}{%
\subsection{\texorpdfstring{Tibbles en \emph{input}}{Tibbles en input}}\label{tibbles-en-input}}

À présent, considérons le cas où l'objet donné en entrée aux fonctions de type \texttt{map} est un tableau de données. Dans ce cas, la fonction (ou la formule) donnée à l'argument \texttt{.f} de la fonction de type \texttt{map} sera appliquée à chacune des colonnes du tableau de données.

Par exemple, pour connaître la moyenne des colonnes de type numérique dans le tableau de données \texttt{iris}, on peut dans un premier temps sélectionner uniquement les colonnes numériques à l'aide de la fonction \texttt{select\_if()} en précisant que l'on souhaite conserver uniquement les colonnes pour lesquelles l'application de la fonction \texttt{is.numeric()} retournerala valeur \texttt{TRUE}. Ensuite, si on applique la fonction \texttt{map\_df()} au tableau de données \texttt{iris} dont seules les colonnes numériques ont été conservées, en fournissant à l'argument \texttt{.f} la fonction \texttt{mean()}, on obtient la moyenne pour chaque colonne de ce tableau :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{select\_if}\NormalTok{(is.numeric) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map\_df}\NormalTok{(mean)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 1 x 4
##   Sepal.Length Sepal.Width Petal.Length Petal.Width
##          <dbl>       <dbl>        <dbl>       <dbl>
## 1         5.84        3.06         3.76        1.20
\end{lstlisting}

Si on applique une fonction à l'aide de \texttt{map()} aux colonnes d'un tableau de données, et que cette fonction retourne plusieurs valeurs, il est possible de faire à nouveau appel à une fonction de type \texttt{map} sur le résultat pour extraire un des résultats. Admettons par exemple que l'on souhaite effectuer un test de normalité sur chacune des colonnes (numériques) du tableau de données \texttt{iris}, puis extraire la valeur-p associée au test (en effectuant, par exemple un test de Shapiro-Wilk). La valeur-p est stocjée dans un élément du résutat retourné par la fonction \texttt{shapiro.test()} nommé \texttt{p.value}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{select\_if}\NormalTok{(is.numeric) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map}\NormalTok{(shapiro.test) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map\_dbl}\NormalTok{(}\StringTok{"p.value"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
## 1.018116e-02 1.011543e-01 7.412263e-10 1.680465e-08
\end{lstlisting}

Comme avec les listes (cf plus haut), il est possible d'appliquer plusieurs fonctions à chaque colonne du tableau de données et de retourner sous la forme d'un tibble chaque sous-résultat. On peut par ailleurs ajouter à la fonction \texttt{map\_df()} l'argument \texttt{.id} auquel on indique la valeur \texttt{"variable"} pour faire figurer une colonne indiquant le nom de chaque colonne.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{select\_if}\NormalTok{(is.numeric) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map\_df}\NormalTok{(}\OperatorTok{\textasciitilde{}}\KeywordTok{tibble}\NormalTok{(}
    \DataTypeTok{mean =} \KeywordTok{mean}\NormalTok{(.),}
    \DataTypeTok{q1 =} \KeywordTok{quantile}\NormalTok{(., }\DataTypeTok{probs =} \FloatTok{.25}\NormalTok{),}
    \DataTypeTok{q3 =} \KeywordTok{quantile}\NormalTok{(., }\DataTypeTok{probs =} \FloatTok{.75}\NormalTok{)}
\NormalTok{    ),}
    \DataTypeTok{.id =} \StringTok{"variable"}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 4 x 4
##   variable      mean    q1    q3
##   <chr>        <dbl> <dbl> <dbl>
## 1 Sepal.Length  5.84   5.1   6.4
## 2 Sepal.Width   3.06   2.8   3.3
## 3 Petal.Length  3.76   1.6   5.1
## 4 Petal.Width   1.20   0.3   1.8
\end{lstlisting}

Evidemment, il est possible d'appliquer certaines fonctions sur des variables factorielles. Par exemple, si on désire connaître le nombre de valeurs distinctes pour chaque variable catégorielle d'un tableau de données :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{select\_if}\NormalTok{(is.factor) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{map\_df}\NormalTok{(}\OperatorTok{\textasciitilde{}}\KeywordTok{tibble}\NormalTok{(}
    \DataTypeTok{n\_dist =} \KeywordTok{n\_distinct}\NormalTok{(.),}
    \DataTypeTok{class =} \KeywordTok{class}\NormalTok{(.x)}
\NormalTok{    ),}
  \DataTypeTok{.id =} \StringTok{"variable"}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 0 x 0
\end{lstlisting}

Astuce : pour connaître le type de données de chaque colonne, on peut faire appel à la fonction \texttt{map\_chr()} en appelant la fonction \texttt{class()} sur chaque colonne :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{\%\textgreater{}\%}\StringTok{ }\KeywordTok{map\_chr}\NormalTok{(class)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##    "numeric"    "numeric"    "numeric"    "numeric"  "character"
\end{lstlisting}

\hypertarget{boucles_vectorisation_plyr}{%
\section{\texorpdfstring{Avec \{\texttt{plyr}\}}{Avec \{plyr\}}}\label{boucles_vectorisation_plyr}}

Les fonctions que nous allons aborder dans cette section possèdent des noms faciles à se remémorer : la première lettre correspond au format d'entrée des données, la seconde au format de sortie souhaité, et la fin du nom se termine par le suffixe \texttt{ply} . Ainsi, la fonction \texttt{llapply()} prend en entrée une liste, effectue une opération sur les éléments, et retourne une liste (Anderson \protect\hyperlink{ref-Anderson_2012_A_Quick}{2012}).

Les différentes fonctions que nous allons passer en revue sont consignées dans le tableau ci-dessous, où les lignes correspondent aux formats d'entrée, et les lignes aux formats de sortie. Pour y avoir accès, il est possible de charger le \emph{package}. Il est également possible de faire précéder l'appel des fonctions par le nom du \emph{package} (il existe de nombreux conflits de noms de fonctions entre celle de \{\texttt{plyr}\} et d'autres \emph{packages}\ldots)

\begin{longtable}[]{@{}lccc@{}}
\toprule
Type & \texttt{array} & \texttt{data.frame} & \texttt{list}\tabularnewline
\midrule
\endhead
\texttt{array} & \texttt{aaply()} & \texttt{adply()} & \texttt{alply()}\tabularnewline
\texttt{data.frame} & \texttt{daply()} & \texttt{ddply()} & \texttt{dlply()}\tabularnewline
\texttt{list} & \texttt{laply()} & \texttt{ldply()} & \texttt{llply()}\tabularnewline
\bottomrule
\end{longtable}

\begin{remarque}
Il est possible d'avoir plusieurs arguments en \texttt{input} au lieu d'un seul objet. Les fonctions \texttt{mlply()}, \texttt{mdply()} et \texttt{maply()} s'en chargent. Si à la place du \texttt{m}, la première lettre est un \texttt{r}, il s'agit alors de fonction de réplications. Enfin, si la seconde lettre est un trait de soulignement (\texttt{\_}), alors le résultat retourné n'est pas affiché (le code utilise la fonction \texttt{invisible()}).
\end{remarque}

Tous les arguments de ces fonctions commencent par un point (\texttt{.}), afin d'éviter des incompatibilités avec la fonction à appliquer.

\hypertarget{boucles_vectorisation_plyr_a_ply}{%
\subsection{\texorpdfstring{Array en \emph{input}}{Array en input}}\label{boucles_vectorisation_plyr_a_ply}}

Les fonctions \texttt{aaply()}, \texttt{adply()} et \texttt{alply()} appliquent une fonction à chaque portion d'un \emph{array} et ensuitent joignent le résultat sous forme d'un \emph{array}, d'un \emph{data frame} ou d'une \emph{list} respectivement.

l'argument \texttt{.margins} détermine la manière de découper le tableau. Il y en a quatre pour un tableau en deux dimensions :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{.margins\ =\ 1} : par lignes ;
\item
  \texttt{.margins\ =\ 2} : par colonnes ;
\item
  \texttt{.margins\ =\ c(1,2)} : par cellule ;
\item
  \texttt{.margins\ =\ c()} : ne pas faire de découpement.
\end{enumerate}

Pour un tableau en trois dimensions, il y a trois découpages possibles en deux dimensions, trois en une dimension et une en zéro dimension (voir Wickham (\protect\hyperlink{ref-Wickham_2011_Split}{2011})) au besoin.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau \textless{}{-}}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{24}\NormalTok{, }\DataTypeTok{dim =} \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{),}
                 \DataTypeTok{dimnames =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{ligne =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{],}
                                 \DataTypeTok{colonne =}\NormalTok{ LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{],}
                                 \DataTypeTok{annee =} \DecValTok{2001}\OperatorTok{:}\DecValTok{2002}\NormalTok{))}
\NormalTok{tableau}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## , , annee = 2001
## 
##      colonne
## ligne A B C  D
##     a 1 4 7 10
##     b 2 5 8 11
##     c 3 6 9 12
## 
## , , annee = 2002
## 
##      colonne
## ligne  A  B  C  D
##     a 13 16 19 22
##     b 14 17 20 23
##     c 15 18 21 24
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La moyenne des valeurs pour chaque ligne}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{aaply}\NormalTok{(tableau, }\DecValTok{1}\NormalTok{, mean) }\CommentTok{\# résultat sous forme de tableau}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    a    b    c 
## 11.5 12.5 13.5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{adply}\NormalTok{(tableau, }\DecValTok{1}\NormalTok{, mean) }\CommentTok{\# résultat sous forme de liste}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   ligne   V1
## 1     a 11.5
## 2     b 12.5
## 3     c 13.5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{alply}\NormalTok{(tableau, }\DecValTok{1}\NormalTok{, mean) }\CommentTok{\# résultat sous forme de liste}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $`1`
## [1] 11.5
## 
## $`2`
## [1] 12.5
## 
## $`3`
## [1] 13.5
## 
## attr(,"split_type")
## [1] "array"
## attr(,"split_labels")
##   ligne
## 1     a
## 2     b
## 3     c
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La moyenne des valeurs pour chaque longitude}
\CommentTok{\# en ne simplifiant pas le résultat}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{aaply}\NormalTok{(tableau, }\DecValTok{2}\NormalTok{, mean, }\DataTypeTok{.drop =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        
## colonne  1
##       A  8
##       B 11
##       C 14
##       D 17
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Par lignes et colonnes}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{aaply}\NormalTok{(tableau, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{), mean)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      colonne
## ligne A  B  C  D
##     a 7 10 13 16
##     b 8 11 14 17
##     c 9 12 15 18
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{adply}\NormalTok{(tableau, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{), mean)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    ligne colonne V1
## 1      a       A  7
## 2      b       A  8
## 3      c       A  9
## 4      a       B 10
## 5      b       B 11
## 6      c       B 12
## 7      a       C 13
## 8      b       C 14
## 9      c       C 15
## 10     a       D 16
## 11     b       D 17
## 12     c       D 18
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# L\textquotesingle{}affichage prend beaucoup de place}
\CommentTok{\# alply(tableau, c(1,2), mean)}

\CommentTok{\# Avec une fonction définie par l\textquotesingle{}utilisateur}
\NormalTok{standardise \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) (x }\OperatorTok{{-}}\StringTok{ }\KeywordTok{min}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\NormalTok{(}\KeywordTok{max}\NormalTok{(x) }\OperatorTok{{-}}\StringTok{ }\KeywordTok{min}\NormalTok{(x))}
\CommentTok{\# Standardiser les valeurs par colonne}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{aaply}\NormalTok{(tableau, }\DecValTok{2}\NormalTok{, standardise)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## , , annee = 2001
## 
##        ligne
## colonne a          b         c
##       A 0 0.07142857 0.1428571
##       B 0 0.07142857 0.1428571
##       C 0 0.07142857 0.1428571
##       D 0 0.07142857 0.1428571
## 
## , , annee = 2002
## 
##        ligne
## colonne         a         b c
##       A 0.8571429 0.9285714 1
##       B 0.8571429 0.9285714 1
##       C 0.8571429 0.9285714 1
##       D 0.8571429 0.9285714 1
\end{lstlisting}

\hypertarget{boucles_vectorisation_plyr_d_ply}{%
\subsection{\texorpdfstring{\emph{Data frame} en \emph{input}}{Data frame en input}}\label{boucles_vectorisation_plyr_d_ply}}

En économétrie, les \emph{data frames} sont très présents. Aussi, la connaissance des fonction \texttt{daply()}, \texttt{ddply()} et \texttt{dlply()} s'avère pratique. En effet, elles sont très utiles pour appliquer des fonctions à des groupes basés sur des combinaisons de variables. Actuellement, il est toutefois, selon moi, plus pratique d'avoir recours aux fonctions du \emph{package} \{\texttt{dplyr}\} (\texttt{group\_by()}, \texttt{summarise()}, \texttt{mutate()}, \ldots, comme présentées dans la Section~@ref(tableaux\_de\_donnees)). À titre informatif, ces notes de cours présentent toutefois les fonctions du \emph{package} \{\texttt{plyr}\}.

Avec les fonctions \texttt{d*ply()}, il est nécessaire d'indiquer quelles variables, ou fonctions de variables on souhaite utiliser, en l'indiquant à l'argument \texttt{.variables}. Elles peuvent être contenue dans le \emph{data frame} fourni à l'argument \texttt{.data}, ou bien provenir de l'environnement global. \texttt{R} cherchera dans un premier temps si la variable est contenue dans le \emph{data frame}, et, s'il ne trouve pas, ira chercher dans l'environnement global.

Pour indiquer que l'on désire faire le regroupement selon une variable --- mettons \texttt{variable\_1} --- il faudra fournir l'expression \texttt{.(variable\_1)} à l'argument \texttt{.variables}. Si on souhaite effectuer les regroupement selon les interactions de plusieurs variables --- \texttt{variable\_1}, \texttt{variable\_2} et \texttt{variable\_3}, il faut alors utiliser l'expression suivante : \texttt{.(variable\_1,\ variable\_2,\ variable\_3)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{region =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\StringTok{"Bretagne"}\NormalTok{, }\DecValTok{4}\NormalTok{), }\KeywordTok{rep}\NormalTok{(}\StringTok{"Corse"}\NormalTok{, }\DecValTok{2}\NormalTok{)), }\DecValTok{2}\NormalTok{),}
         \DataTypeTok{departement =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Cotes{-}d\textquotesingle{}Armor"}\NormalTok{, }\StringTok{"Finistere"}\NormalTok{,}
                             \StringTok{"Ille{-}et{-}Vilaine"}\NormalTok{, }\StringTok{"Morbihan"}\NormalTok{,}
                             \StringTok{"Corse{-}du{-}Sud"}\NormalTok{, }\StringTok{"Haute{-}Corse"}\NormalTok{), }\DecValTok{2}\NormalTok{),}
         \DataTypeTok{annee =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2011}\NormalTok{, }\DecValTok{2010}\NormalTok{), }\DataTypeTok{each =} \DecValTok{6}\NormalTok{),}
         \DataTypeTok{ouvriers =} \KeywordTok{c}\NormalTok{(}\DecValTok{8738}\NormalTok{, }\DecValTok{12701}\NormalTok{, }\DecValTok{11390}\NormalTok{, }\DecValTok{10228}\NormalTok{, }\DecValTok{975}\NormalTok{, }\DecValTok{1297}\NormalTok{,}
                      \DecValTok{8113}\NormalTok{, }\DecValTok{12258}\NormalTok{, }\DecValTok{10897}\NormalTok{, }\DecValTok{9617}\NormalTok{, }\DecValTok{936}\NormalTok{, }\DecValTok{1220}\NormalTok{),}
         \DataTypeTok{ingenieurs =} \KeywordTok{c}\NormalTok{(}\DecValTok{1420}\NormalTok{, }\DecValTok{2530}\NormalTok{, }\DecValTok{3986}\NormalTok{, }\DecValTok{2025}\NormalTok{, }\DecValTok{259}\NormalTok{, }\DecValTok{254}\NormalTok{,}
                        \DecValTok{1334}\NormalTok{, }\DecValTok{2401}\NormalTok{, }\DecValTok{3776}\NormalTok{, }\DecValTok{1979}\NormalTok{, }\DecValTok{253}\NormalTok{, }\DecValTok{241}\NormalTok{))}

\NormalTok{chomage}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 12 x 5
##    region   departement     annee ouvriers ingenieurs
##    <chr>    <chr>           <dbl>    <dbl>      <dbl>
##  1 Bretagne Cotes-d'Armor    2011     8738       1420
##  2 Bretagne Finistere        2011    12701       2530
##  3 Bretagne Ille-et-Vilaine  2011    11390       3986
##  4 Bretagne Morbihan         2011    10228       2025
##  5 Corse    Corse-du-Sud     2011      975        259
##  6 Corse    Haute-Corse      2011     1297        254
##  7 Bretagne Cotes-d'Armor    2010     8113       1334
##  8 Bretagne Finistere        2010    12258       2401
##  9 Bretagne Ille-et-Vilaine  2010    10897       3776
## 10 Bretagne Morbihan         2010     9617       1979
## 11 Corse    Corse-du-Sud     2010      936        253
## 12 Corse    Haute-Corse      2010     1220        241
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Total chomeurs en Bretagne et en Corse pour les années 2010 et 2011}
\CommentTok{\# Sous forme de data frame}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{ddply}\NormalTok{(chomage, plyr}\OperatorTok{::}\NormalTok{.(annee), summarise, }\DataTypeTok{total\_chomeurs =} \KeywordTok{sum}\NormalTok{(ouvriers }\OperatorTok{+}\StringTok{ }\NormalTok{ingenieurs))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   annee total_chomeurs
## 1  2010          53025
## 2  2011          55803
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sous forme de tableau}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{daply}\NormalTok{(chomage, plyr}\OperatorTok{::}\NormalTok{.(annee), summarise, }\DataTypeTok{total\_chomeurs =} \KeywordTok{sum}\NormalTok{(ouvriers }\OperatorTok{+}\StringTok{ }\NormalTok{ingenieurs))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $`2010`
## [1] 53025
## 
## $`2011`
## [1] 55803
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sous forme de liste}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{dlply}\NormalTok{(chomage, plyr}\OperatorTok{::}\NormalTok{.(annee), summarise, }\DataTypeTok{total\_chomeurs =} \KeywordTok{sum}\NormalTok{(ouvriers }\OperatorTok{+}\StringTok{ }\NormalTok{ingenieurs))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $`2010`
##   total_chomeurs
## 1          53025
## 
## $`2011`
##   total_chomeurs
## 1          55803
## 
## attr(,"split_type")
## [1] "data.frame"
## attr(,"split_labels")
##   annee
## 1  2010
## 2  2011
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Total chomeurs pour les années 2010 et 2011, par région du data frame}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{ddply}\NormalTok{(chomage, plyr}\OperatorTok{::}\NormalTok{.(annee, region), summarise,}
      \DataTypeTok{total\_chomeurs =} \KeywordTok{sum}\NormalTok{(ouvriers }\OperatorTok{+}\StringTok{ }\NormalTok{ingenieurs))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   annee   region total_chomeurs
## 1  2010 Bretagne          50375
## 2  2010    Corse           2650
## 3  2011 Bretagne          53018
## 4  2011    Corse           2785
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Nombre d\textquotesingle{}observations pour chaque groupe}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{ddply}\NormalTok{(chomage, plyr}\OperatorTok{::}\NormalTok{.(annee, region), nrow) }
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   annee   region V1
## 1  2010 Bretagne  4
## 2  2010    Corse  2
## 3  2011 Bretagne  4
## 4  2011    Corse  2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En utilisant une fonction définie par l\textquotesingle{}utilisateur}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{ddply}\NormalTok{(chomage, plyr}\OperatorTok{::}\NormalTok{.(annee, region), }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  moy\_ouvriers \textless{}{-}}\StringTok{ }\KeywordTok{mean}\NormalTok{(x}\OperatorTok{$}\NormalTok{ouvriers)}
\NormalTok{  moy\_ingenieurs \textless{}{-}}\StringTok{ }\KeywordTok{mean}\NormalTok{(x}\OperatorTok{$}\NormalTok{ingenieurs)}
  \KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{moy\_ouvriers =}\NormalTok{ moy\_ouvriers, }\DataTypeTok{moy\_ingenieurs =}\NormalTok{ moy\_ingenieurs)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   annee   region moy_ouvriers moy_ingenieurs
## 1  2010 Bretagne     10221.25        2372.50
## 2  2010    Corse      1078.00         247.00
## 3  2011 Bretagne     10764.25        2490.25
## 4  2011    Corse      1136.00         256.50
\end{lstlisting}

\hypertarget{boucles_vectorisation_plyr_l_ply}{%
\subsection{\texorpdfstring{\emph{List} en \emph{input}}{List en input}}\label{boucles_vectorisation_plyr_l_ply}}

Les fonctions du type \texttt{l*ply()} prennent une liste en entrée. Il n'y a donc pas de paramétrage à effectuer pour choisir un découpage, il est déjà fait.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{liste \textless{}{-}}
\StringTok{  }\KeywordTok{list}\NormalTok{(}\DataTypeTok{normale =}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{),}
       \DataTypeTok{logiques =}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{),}
       \DataTypeTok{x =}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\OtherTok{NA}\NormalTok{, }\DecValTok{3}\NormalTok{))}

\CommentTok{\# Obtenir la longueur de chaque élément de la liste}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{laply}\NormalTok{(liste, length)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 10  3  3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{ldply}\NormalTok{(liste, length)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        .id V1
## 1  normale 10
## 2 logiques  3
## 3        x  3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{llply}\NormalTok{(liste, length)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $normale
## [1] 10
## 
## $logiques
## [1] 3
## 
## $x
## [1] 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Calculer la moyenne pour chaque élément}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{llply}\NormalTok{(liste, mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{unlist}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   normale  logiques         x 
## 0.1322028 0.6666667 1.5000000
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Appliquer une fonction définie par l\textquotesingle{}utilisateur}
\NormalTok{plyr}\OperatorTok{::}\KeywordTok{llply}\NormalTok{(liste, }\ControlFlowTok{function}\NormalTok{(x, y) x }\OperatorTok{/}\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{) }\OperatorTok{+}\StringTok{ }\NormalTok{y, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $normale
##  [1] -2.7385827  3.3891033 -4.3208096 14.0669232  4.4924421 -4.2061356
##  [7]  5.6869803  7.5847895  6.3552892 -0.3099997
## 
## $logiques
## [1] 3.5 3.5 2.0
## 
## $x
## [1]  2 NA  4
\end{lstlisting}

\hypertarget{boucles_vectorisation_plyr_parallel}{%
\subsection{Calcul parallèle}\label{boucles_vectorisation_plyr_parallel}}

En utilisant plusieurs processeurs, on peut effectuer des calculs parallèles, ce qui accélère les calculs dans certains cas. En effet, quand il est possible de fractionner les opérations à effectuer en morceaux, on peut en réaliser une partie sur un processeur, une autre sur un second processeur, et ainsi de suite. Les résultats obtenus sont ensuite rassemblés avant d'être retournés. Le \emph{package} \{\texttt{doMC}\} (ou \{\texttt{doSMP}\} sur Windows) peut être chargé pour utiliser la fonction de calcul parallèle proposé par les fonctions \texttt{**ply()}. Il suffit de préciser le nombre de cœurs souhaité en faisant appel à la fonction \texttt{registerDoMC()}, et de fixer la valeur \texttt{TRUE} à l'argument \texttt{.parallel} de la fonction \texttt{**ply()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{valeur\_1 =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{12000}\NormalTok{),}
         \DataTypeTok{id =} \KeywordTok{rep}\NormalTok{(month.abb, }\DataTypeTok{each =} \DecValTok{1000}\NormalTok{))}

\CommentTok{\# Fonction lente (et inutile)}
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  res \textless{}{-}}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\KeywordTok{nrow}\NormalTok{(x))}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(res))\{}
\NormalTok{    res[i] \textless{}{-}}\StringTok{ }\KeywordTok{mean}\NormalTok{(x[}\DecValTok{1}\OperatorTok{:}\NormalTok{i, }\StringTok{"valeur\_1"}\NormalTok{],)}
\NormalTok{  \}}
  \KeywordTok{mean}\NormalTok{(res)}
\NormalTok{\}}

\KeywordTok{library}\NormalTok{(doMC)}
\CommentTok{\# Définir le parallel backend avec le package foreach}
\KeywordTok{registerDoMC}\NormalTok{(}\DataTypeTok{cores=}\DecValTok{4}\NormalTok{)}

\KeywordTok{system.time}\NormalTok{(plyr}\OperatorTok{::}\KeywordTok{ddply}\NormalTok{(df, plyr}\OperatorTok{::}\NormalTok{.(id), f))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    user  system elapsed 
##   0.294   0.026   0.321
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system.time}\NormalTok{(plyr}\OperatorTok{::}\KeywordTok{ddply}\NormalTok{(df, plyr}\OperatorTok{::}\NormalTok{.(id), f, }\DataTypeTok{.parallel =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    user  system elapsed 
##   0.402   0.284   0.191
\end{lstlisting}

\hypertarget{boucles_vectorisation_apply}{%
\section{\texorpdfstring{Avec \{\texttt{base}\}}{Avec \{base\}}}\label{boucles_vectorisation_apply}}

Le tableau ci-dessous recense les fonctions principales \emph{de la famille apply} du \emph{package} \{\texttt{base}\}.

\begin{longtable}[]{@{}ccc@{}}
\toprule
Fonction & Input & Output\tabularnewline
\midrule
\endhead
\texttt{apply()} & Matrice ou tableau & Vecteur ou tableau ou liste\tabularnewline
\texttt{lapply()} & Liste ou vecteur & Liste\tabularnewline
\texttt{sapply()} & Liste ou vecteur & Vecteur ou matrice ou liste\tabularnewline
\texttt{vapply()} & Liste ou vecteur & Vecteur ou matrice ou liste\tabularnewline
\texttt{tapply()} & Tableau et facteurs & Tableau ou liste\tabularnewline
\texttt{mapply()} & Listes et/ou vecteurs & Vecteur ou matrice ou liste\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{boucles_vectorisation_apply_lapply}{%
\subsection{\texorpdfstring{La fonction \texttt{lapply}}{La fonction lapply}}\label{boucles_vectorisation_apply_lapply}}

La fonction \texttt{lapply()} applique à chaque élément du premier argument qui lui est donné une fonction indiquée en second argument et retourne le résultat sous forme de liste. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(X, FUN, ...)}
\end{Highlighting}
\end{Shaded}

avec \texttt{X} la liste ou le vecteur donné en argument sur lequel on désire appliquer la fonction \texttt{FUN}. L'argument \texttt{...} permet comme expliqué dans une précédente remarque, de fournir des arguments à une fonction imbriquée, en l'occurance à celle que l'on souhaite appliquer à tous les éléments de \texttt{X}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{list}\NormalTok{(}\DataTypeTok{normale =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{),}
       \DataTypeTok{logiques =} \KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{,  }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{),}
       \DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{3}\NormalTok{))}

\CommentTok{\# Obtenir la liste des longueurs de chaque élément}
\KeywordTok{lapply}\NormalTok{(liste, length)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $normale
## [1] 10
## 
## $logiques
## [1] 3
## 
## $x
## [1] 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Calculer la moyenne pour chaque élément}
\KeywordTok{lapply}\NormalTok{(liste, mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $normale
## [1] 0.04319732
## 
## $logiques
## [1] 0.6666667
## 
## $x
## [1] 1.5
\end{lstlisting}

On peut créer une fonction à l'intérieur de l'appel à la fonction \texttt{lapply()}. Le premier argument est nécessairement un élément du vecteur auquel on souhaite appliquer la fonction.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(liste, }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{/}\StringTok{ }\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $normale
##  [1] -17.375456  -6.647068  19.251983 -12.199524 -42.424943  24.224455
##  [7] -12.030570  24.388223  31.518789   1.294111
## 
## $logiques
## [1] 1.5 1.5 0.0
## 
## $x
## [1]  0 NA  2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Si la fonction doit posséder plusieurs arguments}
\KeywordTok{lapply}\NormalTok{(liste, }\ControlFlowTok{function}\NormalTok{(x, y) x }\OperatorTok{/}\StringTok{ }\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{) }\OperatorTok{+}\StringTok{ }\NormalTok{y, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $normale
##  [1] -15.375456  -4.647068  21.251983 -10.199524 -40.424943  26.224455
##  [7] -10.030570  26.388223  33.518789   3.294111
## 
## $logiques
## [1] 3.5 3.5 2.0
## 
## $x
## [1]  2 NA  4
\end{lstlisting}

On peut appliquer la fonction \texttt{lapply()} sur des tableaux de données, dans la mesure où ces derniers sont des listes. Cela s'avère pratique pour réaliser des opérations pour chaque colonne d'un tableau de données. Afin de prendre moins de place dans l'affichage, l'exemple suivant utilise la fonction \texttt{unlist()} pour aplatir la liste.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(cars)}

\CommentTok{\# Afficher le type de chaque colonne de la data frame "cars"}
\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(cars, class))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##     speed      dist 
## "numeric" "numeric"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Calculer la moyenne pour chaque colonne}
\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(cars, mean))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## speed  dist 
## 15.40 42.98
\end{lstlisting}

\begin{remarque}
Attention, ce qui suit relève plus d'un tour de passe-passe que de la programmation élégante.

Si la fonction que l'on souhaite appliquer aux éléments de notre vecteur retourne un vecteur ligne de même longueur pour chaque élément, la fonction \texttt{do.call()} peut devenir un outil très pratique pour créer une \emph{data frame}. Par exemple, définissons une liste à l'aide de \texttt{lapply()}: \texttt{l\ \textless{}-\ lapply(1:3,\ function(x)\ cbind(valeur\ =\ x,\ lettre\ =\ LETTERS{[}x{]}))}. Ensuite, pour coller les lignes entre-elles : \texttt{do.call("rbind",\ l)\ \%\textgreater{}\%\ data.frame()}.

L'appel de \texttt{do.call("rbind",\ x)} revient à faire \texttt{rbind(x{[}1{]},\ x{[}2{]},\ ...,\ x{[}n{]})} avec \texttt{x} un vecteur de taile \(n\).
\end{remarque}

\hypertarget{boucles_vectorisation_apply_sapply}{%
\subsection{\texorpdfstring{La fonction \texttt{sapply()}}{La fonction sapply()}}\label{boucles_vectorisation_apply_sapply}}

La fonction \texttt{sapply()} applique une fonction aux éléments d'un vecteur ou d'une liste et peut retourner un vecteur, une liste ou une matrice. Elle possède la syntaxe suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(X, FUN, simplify, USE.NAMES)}
\end{Highlighting}
\end{Shaded}

où \texttt{X} est le vecteur ou la liste auquel on souhaite appliquer la fonction \texttt{FUN}. Lorsque \texttt{simplify} vaut \texttt{FALSE}, le résultat est retourné sous forme de liste, exactement comme \texttt{lapply()} (la fonction \texttt{sapply()} s'appuie sur la fonction \texttt{lapply()}). Lorsque \texttt{simplify} vaut \texttt{TRUE} (par défaut), le résultat est retourné dans une forme simplifiée, si cela est possible. Si tous les éléments retournés par la fonction \texttt{FUN} sont des scalaires, alors \texttt{sapply()} retourne un vecteur ; sinon, si les éléments retournés ont la même taille, \texttt{sapply()} retourne une matrice avec une colonne pour chaque élément de \texttt{X} auquel la fonction \texttt{FUN} est appliquée. l'argument \texttt{USE.NAMES}, quand il vaut \texttt{TRUE} (par défaut), et si \texttt{X} est de type \texttt{character}, utilise \texttt{X} comme nom pour le résultat, à moins que le résultat possède déjà des noms.

\begin{lstlisting}
(x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)))

# Application de la fonction quantile() à chaque élément
# pour obtenir la médiane et les quartiles

# Avec lapply()
lapply(x, quantile)

# Avec sapply
sapply(x, quantile)

# Exemple avec USE.NAMES
sapply(LETTERS[1:3], nchar)
sapply(LETTERS[1:3], nchar, USE.NAMES = FALSE)
\end{lstlisting}

\hypertarget{boucles_vectorisation_apply_vapply}{%
\subsection{\texorpdfstring{La fonction \texttt{vapply}}{La fonction vapply}}\label{boucles_vectorisation_apply_vapply}}

La fonction \texttt{vapply} est similaire à \texttt{sapply()}, mais elle possède un type de valeurs spécifié, ce qui peut rendre l'utilisation plus sûre (et parfois plus rapide). Lorsqu'on lui fournit un \emph{data frame}, \texttt{vapply} retourne le même résultat que \texttt{sapply()}. Cependant, quand on lui fournit une liste vide, \texttt{vapply} retourne un vecteur logique de longueur nulle (ce qui est plus sensé que la liste vide que returne \texttt{sapply()}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{vapply}\NormalTok{(X, FUN, FUN.VALUE, ..., USE.NAMES)}
\end{Highlighting}
\end{Shaded}

avec \texttt{X}, \texttt{FUN}, \texttt{...} et \texttt{USE.NAMES} les mêmes arguments que pour \texttt{sapply()}. l'argument \texttt{FUN.VALUE} doit être un vecteur, un masque pour la valeur retournée par la fonction de \texttt{FUN}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Retourner le vecteur }
\KeywordTok{sapply}\NormalTok{(cars, is.numeric)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## speed  dist 
##  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{vapply}\NormalTok{(cars, is.numeric, }\DataTypeTok{FUN.VALUE =} \KeywordTok{logical}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## speed  dist 
##  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec la liste vide}
\KeywordTok{sapply}\NormalTok{(}\KeywordTok{list}\NormalTok{(), is.numeric)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## list()
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{vapply}\NormalTok{(}\KeywordTok{list}\NormalTok{(), is.numeric, }\DataTypeTok{FUN.VALUE =} \KeywordTok{logical}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## logical(0)
\end{lstlisting}

\hypertarget{boucles_vectorisation_apply_apply}{%
\subsection{\texorpdfstring{La fonction \texttt{apply()}}{La fonction apply()}}\label{boucles_vectorisation_apply_apply}}

La fonction \texttt{apply()} possède la syntaxe suivante :
\textless\textless boucles\_vectorisation\_apply\_apply\_syntaxe, eval = FALSE\textgreater\textgreater=
apply(X, MARGIN, FUN, \ldots)
@
avec \texttt{X} une matrice ou un tableau, \texttt{MARGIN} indiquant si on souhaite appliquer la fonction \texttt{FUN} aux lignes (\texttt{MARGIN\ =\ 1}) ou aux colonnes (\texttt{MARGIN\ =\ 2}), et \texttt{...} des arguments supplémentaires éventuels à passer à la fonction \texttt{FUN}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(X \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Somme par ligne}
\KeywordTok{apply}\NormalTok{(X, }\DataTypeTok{MARGIN =} \DecValTok{1}\NormalTok{, sum)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 12 15 18
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Somme par colonne}
\KeywordTok{apply}\NormalTok{(X, }\DataTypeTok{MARGIN =} \DecValTok{2}\NormalTok{, sum)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  6 15 24
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Fonction définie par l\textquotesingle{}utilisateur}
\KeywordTok{apply}\NormalTok{(X, }\DataTypeTok{MARGIN =} \DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(x) }\OperatorTok{/}\StringTok{ }\KeywordTok{sum}\NormalTok{(X))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 0.2666667 0.3333333 0.4000000
\end{lstlisting}

\hypertarget{boucles_vectorisation_apply_tapply}{%
\subsection{\texorpdfstring{La fonction \texttt{tapply()}}{La fonction tapply()}}\label{boucles_vectorisation_apply_tapply}}

La fonction \texttt{tapply()} s'applique à chaque cellule d'un tableau, sur des regroupements définis par les variables catégorielles fournies. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tapply}\NormalTok{(X,INDEX, FUN, ..., simplify)}
\end{Highlighting}
\end{Shaded}

avec \texttt{X} le taleau de données, \texttt{INDEX} une liste d'un ou plusieurs facteurs, chacun de même taille que \texttt{X}. l'argument \texttt{FUN} renseigne la fonction que l'on souhaite appliquer. Si \texttt{SIMPLIFY} vaut \texttt{FALSE}, le résultat est un tableau de mode \texttt{list}. Sinon (par défaut), le résultat est un tableau de scalaires.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(iris)}
\KeywordTok{head}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Moyenne de la longueur des sépales par espèce}
\KeywordTok{tapply}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length, iris}\OperatorTok{$}\NormalTok{Species, mean)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##     setosa versicolor  virginica 
##      5.006      5.936      6.588
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Pour retourner le résultat sous forme de liste}
\KeywordTok{tapply}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length, iris}\OperatorTok{$}\NormalTok{Species, mean, }\DataTypeTok{simplify =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $setosa
## [1] 5.006
## 
## $versicolor
## [1] 5.936
## 
## $virginica
## [1] 6.588
\end{lstlisting}

\hypertarget{boucles_vectorisation_apply_mapply}{%
\subsection{\texorpdfstring{La fonction \texttt{mapply()}}{La fonction mapply()}}\label{boucles_vectorisation_apply_mapply}}

La fonction \texttt{mapply()} applique une fonction à plusieurs listes ou vecteurs. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mapply}\NormalTok{(FUN, ..., MoreArgs, SIMPLIFY, USE.NAMES)}
\end{Highlighting}
\end{Shaded}

avec \texttt{FUN} la fonction à appliquer aux vecteurs ou listes fournies (grâce à \texttt{...}), \texttt{MoreArgs} une liste d'arguments supplémentaires à fournir à la fonction à appliquer. Les arguments \texttt{SIMPLIFY} et \texttt{USE.NAMES} ont le même usage que pour la fonction \texttt{sapply()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(l1 \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{), }\DataTypeTok{b =} \KeywordTok{c}\NormalTok{(}\DecValTok{6}\OperatorTok{:}\DecValTok{10}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $a
## [1] 1 2 3 4 5
## 
## $b
## [1]  6  7  8  9 10
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(l2 \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{c =} \KeywordTok{c}\NormalTok{(}\DecValTok{11}\OperatorTok{:}\DecValTok{15}\NormalTok{), }\DataTypeTok{d =} \KeywordTok{c}\NormalTok{(}\DecValTok{16}\OperatorTok{:}\DecValTok{20}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $c
## [1] 11 12 13 14 15
## 
## $d
## [1] 16 17 18 19 20
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La somme des éléments correspondants de l1 et l2}
\KeywordTok{mapply}\NormalTok{(sum, l1}\OperatorTok{$}\NormalTok{a, l1}\OperatorTok{$}\NormalTok{b, l2}\OperatorTok{$}\NormalTok{c, l2}\OperatorTok{$}\NormalTok{d)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 34 38 42 46 50
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Attention au recyclage silencieux !}
\NormalTok{(l1 \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{), }\DataTypeTok{b =} \KeywordTok{c}\NormalTok{(}\DecValTok{6}\OperatorTok{:}\DecValTok{20}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $a
## [1] 1 2 3 4 5
## 
## $b
##  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mapply}\NormalTok{(sum, l1}\OperatorTok{$}\NormalTok{a, l1}\OperatorTok{$}\NormalTok{b, l2}\OperatorTok{$}\NormalTok{c, l2}\OperatorTok{$}\NormalTok{d)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1] 34 38 42 46 50 39 43 47 51 55 44 48 52 56 60
\end{lstlisting}

\hypertarget{boucles_vectorisation_Vectorize}{%
\subsection{\texorpdfstring{La fonction \texttt{Vectorize()}}{La fonction Vectorize()}}\label{boucles_vectorisation_Vectorize}}

La fonction \texttt{Vectorize()} permet de convertir une fonction scalaire en une fonction vectorielle. Attention, cela ne permet pas d'améliorer la rapidité d'exécution du code. Par contre, son utilisation assez intuitive permet de gagner du temps. Il s'agit donc de faire l'arbitrage entre le temps passé à trouver un moyen élégant et efficace pour effectuer une opération en passant par de réels calculs vectoriels et le gain d'exécution que ce calcul vectoriel apporte vis-à-vis d'une boucle. La syntaxe de la fonction \texttt{Vectorize()} est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Vectorize}\NormalTok{(FUN, vectorize.args, SIMPLIFY, USE.NAMES)}
\end{Highlighting}
\end{Shaded}

avec \texttt{FUN} une fonction à appliquer, \texttt{vectorize.args} un vecteur d'arguments (de type caractère) qui devraient être vectorisés (par défaut, tous les arguments de \texttt{FUN}). Les arguments \texttt{SIMPLIFY} et \texttt{USE.NAMES} on le même emploi que dans la fonction \texttt{sapply()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, y) }\KeywordTok{c}\NormalTok{(x, y)}
\CommentTok{\# On "vectorise" la fonction f}
\NormalTok{vf \textless{}{-}}\StringTok{ }\KeywordTok{Vectorize}\NormalTok{(f, }\DataTypeTok{SIMPLIFY =} \OtherTok{FALSE}\NormalTok{)}
\KeywordTok{f}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 2 3 1 2 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{vf}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] 1 1
## 
## [[2]]
## [1] 2 2
## 
## [[3]]
## [1] 3 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Vectorise seulement y, pas x}
\KeywordTok{vf}\NormalTok{(}\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] 1 2 3 1
## 
## [[2]]
## [1] 1 2 3 2
## 
## [[3]]
## [1] 1 2 3 3
\end{lstlisting}

\hypertarget{boucles_exercices}{%
\section{Exercices}\label{boucles_exercices}}

\begin{exframe}
\textbf{Exercice 1. Boucle \texttt{while()}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  à l'aide de la fonction \texttt{while()}, créer une boucle qui permet de calculer la factorielle d'un nombre ;
\item
  Réutiliser le code de la question précédente pour en faire une fonction qui, lorsqu'on lui donne un nombre, retourne sa factorielle. Comparer le résultat avec la fonction \texttt{factorial()}.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 2. Boucles \texttt{while()} et \texttt{for()}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Choisir un nombre mystère entre 1 et 100, et le stocker dans un objet que l'on nommera \texttt{nombre\_mystere}. Ensuite, créer une boucle qui à chaque itération effectue un tirage aléatoire d'un entier compris entre 1 et 100. Tant que le nombre tiré est différent du nombre mystère, la boucle doit continuer. à la sortie de la boucle, une variable que l'on appellera \texttt{nb\_tirages} contiendra le nombre de tirages réalisés pour obtenir le nombre mystère ;
\item
  Utiliser le code de la question précédente pour réaliser la fonction \texttt{trouver\_nombre}, qui, lorsqu'on lui donne un nombre compris entre 1 et 100, retourne le nombre de tirages aléatoires d'entiers compris entre 1 et 100 nécessaires avant de tirer le nombre mystère ;
\item
  En utilisant une boucle \texttt{for}, faire appel 1000 fois à la fonction \texttt{trouver\_nombre()} qui vient d'être créée. à chaque itération, stocker le résultat dans un élément d'un vecteur que l'on appellera \texttt{nb\_essais\_rep}. Enfin, afficher la moyenne du nombre de tirages nécessaires pour retrouver le nombre magique.
\end{enumerate}

\texttt{nb\_essais\_rep\ \textless{}-\ rep(NA,\ 1000)}
\end{exframe}

\begin{exframe}
\textbf{Exercice 3. Boucles \texttt{for()}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Parcourir les entiers de 1 à 20 à l'aide d'une boucle \texttt{for} en affichant dans la console à chaque itération si le nombre courant est pair ;
\item
  L'objet \texttt{month.name} est un vecteur contenant les noms des mois du calendrier, en anglais. Parcourir chacun des éléments de ce vecteur, et afficher dans la console pour chacun des mois si le nombre de caractères composant le nom du mois est pair ou impair.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 4. Suite de Fibonacci}

Utiliser une boucle \texttt{for} pour reproduire la suite de Fibonacci jusqu'à son dixième terme (la séquence \(F_n\) est définie par la relation de récurrence suivante : \(F_{n} = F_{n-1} + F_{n-2}\) ; les valeurs initiales sont : \(F_0 = 0\) et \(F_{1} = 1\)).
\end{exframe}

\begin{exframe}
\textbf{Exercice 5. Barre de progression}

Considérons le vecteur de chaînes de caractères \texttt{ids} ainsi que la liste \texttt{res} :
\end{exframe}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(magrittr)}
\NormalTok{n \textless{}{-}}\StringTok{ }\DecValTok{1000}
\NormalTok{ids \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{str\_c}\NormalTok{(}\KeywordTok{sample}\NormalTok{(LETTERS, n, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{),}
        \KeywordTok{sample}\NormalTok{(letters, n, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{unique}\NormalTok{()}
\NormalTok{res \textless{}{-}}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\KeywordTok{length}\NormalTok{(ids))}
\end{Highlighting}
\end{Shaded}

\begin{exframe}
Parcourir les éléments du vecteur \texttt{ids} à l'aide d'une boucle \texttt{for()}. à chaque itération, stocker dans l'élément de la liste \texttt{res} dont la position correspond à celle de l'identifiant courant dans \texttt{ids} les informations suivantes : (i) l'identifiant courant et (ii) la somme de \(50 000\) tirages aléatoires selon une \(\mathcal{N}(0,1)\).

Afficher l'état d'avancement de la boucle à l'aide d'une barre de progression.
\end{exframe}

\begin{exframe}
\textbf{Exercice 6. Fonctions appliquées aux éléments d'une liste}

Soit une liste nommée \texttt{twittos}, disponible à l'adresse suivante : \url{http://egallic.fr/Enseignement/R/Exercices/donnees/twittos.rda}. Elle contient des informations fictives sur des utilisateurs de Twitter ; chaque élément de cette liste est une liste dont les éléments sont les suivants :

\begin{itemize}
\tightlist
\item
  \texttt{screen\_name} : nom d'utilisateur ;
\item
  \texttt{nb\_tweets} : nombre de tweets ;
\item
  \texttt{nb\_followers} : nombre de followers ;
\item
  \texttt{nb\_friends} : nombre de followings ;
\item
  \texttt{created\_at} : date de création du compte ;
\item
  \texttt{location} : ville renseignée.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Importer le contenu du fichier dans la session \texttt{R} ;
\item
  Utiliser la fonction \emph{map} appropriée sur \texttt{twittos} pour récupérer une liste contenant uniquement les noms d'utilisateurs. Faire de même pour le nombre de followers, puis appliquer \texttt{unlist()} au résultat ;
\item
  Créer une fonction qui, quand on lui fournit un élément de la liste \texttt{twittos}, c'est-à-dire les informations sous forme de liste d'un seul utilisateur, retourne ces informations sous forme de tableau de données. Nommer cette fonction \texttt{twittos\_to\_df} ;
\item
  Appliquer la fonction \texttt{twittos\_to\_df()} au premier élément de la liste \texttt{twittos}, puis utiliser la fonction \emph{map} appropriée pour appliquer la fonction \texttt{twittos\_to\_df()} à tous les éléments de la liste. Stocker ce dernier résultat dans un objet appelé \texttt{res} ;
\item
  Quelle est la structure de l'objet \texttt{res} obtenu à la question précédente ?
\item
  Importer le fichier disponible à cette adresse dans la session \texttt{R} : \url{http://egallic.fr/Enseignement/R/Exercices/donnees/dates_tw.rda}. Il s'agit d'une liste donc chaque élément contient une liste indiquant le nom d'un utilisateur et la date de chacun de ses tweets.
\item
  Appliquer la fonction \emph{map} appropriée à la liste \texttt{dates\_tw} qui vient d'être importée dans \texttt{R}, pour afficher l'heure moyenne des tweets pour chaque utilisateur, puis faire de même pour l'écart-type.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 7. Fonctions appliquées aux éléments d'une matrice}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer une matrice de dimension \(100\times 5\), donc chaque vecteur colonne est composé de tirages issus d'une loi Normale centrée réduite ;
\item
  Utiliser la fonction \texttt{apply()} pour calculer la moyenne des valeurs de chaque colonne ;
\item
  Utiliser la fonction \texttt{apply()} pour calculer l'écart-type des valeurs de chaque colonne.
\end{enumerate}
\end{exframe}

\hypertarget{graphiques}{%
\chapter{Graphiques}\label{graphiques}}

L'analyse de données passe souvent par une phase de visualisation. \texttt{R} propose différentes méthodes pour créer des graphiques. Le \emph{package} \{\texttt{graphics}\}, qui est installé d'office et chargé par défaut au démarrage de \texttt{R}, contient de nombreuses fonctions pour réaliser des graphiques. Cependant, nous allons plutôt présenter les bases de la confection de graphiques à partir du \emph{package} \{\texttt{ggplot2}\}. Comme ce document a vocation à être une introduction, seule une infime partie des possibilités offertes par \{\texttt{ggplot2}\} est abordée. Le lecteur ou la lectrice intéressé•e est invité•e à consulter des excellents ouvrages ayant été publiés (Chang \protect\hyperlink{ref-Chang_2013_R}{2013}, Wickham\_2009\_ggplot2).

Les graphiques avec \{\texttt{ggplot2}\} sont crées par couches (\emph{layers}), avec la première constituée des données brutes, puis les suivantes d'annotations, d'informations statistiques. \{\texttt{ggplot2}\} s'appuie sur une grammaire. L'apprentissage de cette grammaire nécessite un peu de temps, mais permet de créer des graphiques intelligibles. La grammaire graphique crée une carte, un plan (\emph{mapping}) pour passer des données aux attributs esthétiques des objets géométriques (comme la couleur, la forme, ou la taille des points, lignes, etc.). Elle permet également d'appliquer des transformations aux données avant de les représenter, ou encore de faire du facettage (\emph{faceting}).

Pour pouvoir utiliser les fonctions de \{\texttt{ggplot2}\}, il est nécessaire d'installer le \emph{package} lors de la première utilisation, puis de le charger les fois suivantes.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Lors de la première utilisation}
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}

\CommentTok{\# Les fois suivantes}
\KeywordTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Avant de rentrer dans le vif du sujet, il est important de mentionner la page d'aide du \emph{package} sur Internet, qui est très bien réalisée, et s'avère être un excellent aide-mémoire : \url{https://ggplot2.tidyverse.org/reference/}.

\hypertarget{graphiques_structure}{%
\section{Structure}\label{graphiques_structure}}

Les éléments de la grammaire graphique utilisés par \{\texttt{ggplot2}\} sont les suivants :

\begin{itemize}
\tightlist
\item
  des données brutes (\textbf{\emph{data}}) ;
\item
  une projection graphique pour lier ces données aux attributs esthétiques (\textbf{\emph{mapping}}) ;
\item
  des objets géométriques (\textbf{\emph{geom}}) (points, lignes, polygones, etc.) ;
  -des transformations statistiques (\textbf{\emph{stats}}) ;
\item
  des échelles (\textbf{\emph{scale}}) qui lient les données à un espace esthétique ;
\item
  un système de coordonnées (\textbf{\emph{coord}}), indiquant comment les coordonnées issues des données sont positionnées sur le graphique ;
\item
  une indication de regroupement à effectuer dans les données pour créer des sous-groupes, afin de créer des facettes (\textbf{\emph{facet}}).
\end{itemize}

Les mots en gras dans la liste ci-avant servent de base dans les noms des fonctions du \emph{package} \{\texttt{ggplot2}\}. Par exemple, les fonctions pour définir le type de géométrie souhaité commencent par \texttt{geom\_}.

La création d'un graphique avec \{\texttt{ggplot2}\} débute avec l'appel de la fonction \texttt{ggplot()}. Les couches supplémentaires (\emph{layers}) sont ajoutées en ayant recours au symbole \texttt{+}. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(data, }\KeywordTok{aes}\NormalTok{(x, y)) }\OperatorTok{+}\StringTok{ }\NormalTok{layers}
\end{Highlighting}
\end{Shaded}

Il est possible de stocker un graphique créé avec \{\texttt{ggplot2}\} dans une variable, en utilisant la flèche d'assignation. Des nouvelles couches peuvent ensuite être ajoutées à l'objet stocké.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(data, }\KeywordTok{aes}\NormalTok{(x, y)) }\OperatorTok{+}\StringTok{ }\NormalTok{layers}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\NormalTok{new\_layers}
\end{Highlighting}
\end{Shaded}

Les données doivent être fournies sous forme de \emph{tibble} ou \emph{data.frame} à la fonction \texttt{ggplot()}.

\hypertarget{graphiques_ggplot}{%
\section{\texorpdfstring{Des graphiques élaborés avec \texttt{ggplot()}}{Des graphiques élaborés avec ggplot()}}\label{graphiques_ggplot}}

Pour illustrer les différentes notions, un échantillon de 135 films est utilisé. Il est issus de la base \texttt{film} obtenue, à l'époque, sur un site qui s'appelait \emph{freebase}. Ce jeu de données contient des informations relatives à la date de première date de sortie, à la durée la plus longue du film, l'estimation du budget, les revenus bruts et le premier pays indiqué concernant la réalisation du film.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{load}\NormalTok{(}\KeywordTok{url}\NormalTok{(}\StringTok{"http://egallic.fr/R/films.rda"}\NormalTok{))}
\KeywordTok{head}\NormalTok{(films)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##                                      name initial_release_date runtime year
## 1                            Galaxy Quest           1999-12-23     102 1999
## 2                Star Trek: First Contact           1996-11-18     111 1996
## 3                            Forrest Gump           1994-06-23     142 1994
## 4 Star Wars Episode I: The Phantom Menace           1999-05-19     136 1999
## 5                                 Titanic           1997-11-01     194 1997
## 6                        Independence Day           1996-06-25     153 1996
##   estimated_budget gross_revenue                  country country_abr
## 1         4.50e+07      90683916 United States of America         USA
## 2         4.50e+07      92001027 United States of America         USA
## 3         5.50e+07     677387716 United States of America         USA
## 4         1.15e+08    1027044330 United States of America         USA
## 5         2.00e+08    2185240703 United States of America         USA
## 6         7.50e+07     817400891 United States of America         USA
\end{lstlisting}

Créons une sous-base, qui ne concerne que quelques pays :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}
\NormalTok{pays\_liste \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{c}\NormalTok{(}\StringTok{"United States of America"}\NormalTok{, }\StringTok{"New Zealand"}\NormalTok{,}
    \StringTok{"United Kingdom"}\NormalTok{, }\StringTok{"Spain"}\NormalTok{)}
\NormalTok{films\_reduit \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{films }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(country }\OperatorTok{\%in\%}\StringTok{ }\NormalTok{pays\_liste)}
\end{Highlighting}
\end{Shaded}

Le graphique le plus commun est sans doùte le nuage de points (ou \emph{scatterplot}).

L'exemple suivant trace des un nuage de points représentant le budget estimé de chaque film en fonction des recettes brutes. Nous avons besoin d'utiliser la fonction \texttt{geom\_point()}, qui définit le type de géométrie. D'autres types de géométries sont présentés à la Section~@ref(graphiques\_ggplot\_geom).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_ggplot-1} \end{center}

\hypertarget{graphiques_ggplot_aes}{%
\subsection{Arguments esthétiques}\label{graphiques_ggplot_aes}}

Parmi les arguments esthétiques que l'on peut modifier, on retrouve :

\begin{itemize}
\tightlist
\item
  \texttt{colour} : la couleur ;
\item
  \texttt{shape} : la forme ;
\item
  \texttt{size} : la taille ;
\item
  \texttt{alpha} : la transparence ;
\item
  \texttt{fill} : le remplissage.
\end{itemize}

Dans l'exemple précédent, ces arguments n'ayant pas étés modifiés, ils ont conservé leur valeur par défaut. Pour les modifier, il suffit d'indiquer la valeur voulue à l'intérieur de la fonction \texttt{ggplot()} ou d'une fonction de géométrie.

Par exemple, pour que la couleur des points soit \texttt{dodger\ blue} et que la transparence soit de \texttt{0.8} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"dodger blue"}\NormalTok{, }\DataTypeTok{alpha =} \FloatTok{.8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_ggplot_col-1} \end{center}

Il est également possible de faire dépendre les arguments esthétiques des valeurs prises par les variables du tableau de données. En fonction du mode de la variable utilisée, les effets seront différents. Par exemple, si on décide de faire dépendre la couleur d'une variable continue, une échelle de couleurs sera utilisée ; si la variable est discrète, une palette de couleurs est utilisée. Pour ce faire, il faut indiquer le \emph{mapping} à l'intérieur de la fonction \texttt{aes()}.

Par exemple, pour faire dépendre la couleur des points de la valeur prise par l'estimation de budget (variable continue) :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{.8}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =}\NormalTok{ estimated\_budget))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_ggplot_continue-1} \end{center}

Et pour faire dépendre la couleur des points du pays d'origine :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{.8}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =}\NormalTok{ country))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_ggplot_continue_2-1} \end{center}

\begin{remarque}
Une petite astuce pour créer un \emph{bubble chart} consiste à attribuer à l'argument \texttt{size} des valeurs prises par une variable.
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{.8}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =}\NormalTok{ country, }\DataTypeTok{size =}\NormalTok{ runtime))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_ggplot_bubble-1} \end{center}

\begin{remarque}
Si on souhaite que la couleur de la forme géométrique soit la même pour toutes les observations, il faut renseigner l'argument \texttt{color} dans la fonction \texttt{geom\_*} et non pas \texttt{ggplot()}.
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_rem \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit, }
         \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
             \DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"red"}\NormalTok{)}
\NormalTok{p\_rem}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_structure_geom_point_red-1} \end{center}

\begin{remarque}
Si on fournit un argument esthétique à la fonction \texttt{aes()}, à l'intérieur de la fonction \texttt{geom\_*}, une nouvelle variable est créé, qui vaut, pour toutes les observations, la valeur attribuée à l'argument esthétique. De fait, \{\texttt{ggplot2}\} se charge d'interpréter cela comme une variable de mode facteur, qui ne contient qu'un niveau.
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_rem \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit, }
         \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
             \DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"green"}\NormalTok{))}
\CommentTok{\# La couleur pour les points va s\textquotesingle{}appuyer sur une variable qui}
\CommentTok{\# vient d\textquotesingle{}être créée, et qui vaut "green" pour toutes les obs.}
\CommentTok{\# Il est alors considéré qu\textquotesingle{}il n\textquotesingle{}y a qu\textquotesingle{}un facteur.}
\CommentTok{\# Donc la couleur affichée sera le rose !}
\NormalTok{p\_rem}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_structure_geom_point_red_2-1} \end{center}

\hypertarget{graphiques_ggplot_geom}{%
\subsection{\texorpdfstring{Arguments géométriques (fonctions \texttt{geom\_*})}{Arguments géométriques (fonctions geom\_*)}}\label{graphiques_ggplot_geom}}

Pour définir le type d'objet géométrique utilisé pour représenter les données, on ajoute une couche au graphique. Le nom des fonctions qui ajoutent ce type de couches possède la syntaxe suivante : \texttt{geom\_*}, où l'étoile doit être remplacée par le nom d'une forme géométrique. Les principales fonctions sont les suivantes :

\begin{itemize}
\tightlist
\item
  \texttt{geom\_point()} : tracer des points ;
\item
  \texttt{geom\_line()} : tracer des lignes ;
\item
  \texttt{geom\_polygon()} : tracer des lignes ;
\item
  \texttt{geom\_path()} : tracer des points dans l'ordre du tableau de données
\item
  \texttt{geom\_step()} : faire un graphique en escalier ;
\item
  \texttt{geom\_boxplot()} : tracer une boîte à moustache ;
\item
  \texttt{geom\_jitter()} : mettre des points côte à côte pour une variable catégorielle ;
\item
  \texttt{geom\_smooth()} : ajouter une courbe de tendance ;
\item
  \texttt{geom\_histogram()} : tracer un histogramme ;
\item
  \texttt{geom\_bar()} : tracer un diagramme en bâton ;
\item
  \texttt{geom\_density()} : tracer une estimation de densité.
\end{itemize}

Toutes les fonctions \texttt{geom\_*} possèdent les arguments optionnels suivants : \texttt{data}, \texttt{mapping}, \texttt{...}, \texttt{geom} (ou \texttt{stat}) et \texttt{position}. S'ils sont omis, leur valeur est héritée de celle des arguments correspondants de la fonction \texttt{ggplot()}. Si à l'inverse ils sont renseignés, alors leur valeur vient remplacer celle héritée. Certaines fonctions ont d'autres arguments ; le lecteur ou la lectrice est invité•e à consulter l'aide pour de plus amples détails.

Le but ici n'est pas de passer en revue chaque fonction, mais de permettre au lecteur ou à la lectrice de comprendre le fonctionnement des graphiques en couche avec \{\texttt{ggplot2}\}. Toutes les fonctions \texttt{geom\_*} fonctionnent de la même manière. En étant capable de comprendre les exemples qui suivent, il ne devrait pas être compliqué d'explorer les cas non traités dans ce document.

\hypertarget{graphiques_ggplot_geom_points}{%
\subsubsection{Points}\label{graphiques_ggplot_geom_points}}

La fonction qui permet de tracer des points a déjà été utilisées à plusieurs reprises : \texttt{geom\_point()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
           \DataTypeTok{y =}\NormalTok{ gross\_revenue, }\DataTypeTok{col =}\NormalTok{ country)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_point-1} \end{center}

Si on renseigne le chemin vers les données à l'intérieur de la fonction \texttt{geom\_point()} plutôt que dans \texttt{ggplot()}, il faut veiller à bien préciser l'argument \texttt{data} !

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
           \DataTypeTok{y =}\NormalTok{ gross\_revenue, }\DataTypeTok{col =}\NormalTok{ country))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_point_2-1} \end{center}

Attention, pour que tous les points aient la même couleur, il faut que l'argument esthétique soit fourni à \texttt{geom\_point()} et non pas à \texttt{ggplot()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_point_3-1} \end{center}

\hypertarget{graphiques_ggplot_geom_line}{%
\subsubsection{Lignes}\label{graphiques_ggplot_geom_line}}

Pour tracer des lignes entre les points, il faut utiliser la fonction \texttt{geom\_line()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
           \DataTypeTok{y =}\NormalTok{ gross\_revenue, }\DataTypeTok{col =}\NormalTok{ country)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_line-1} \end{center}

Le fait d'ajouter l'argument \texttt{colour} et de lui donner en valeur une variable de type facteur crée automatiquement des groupes. Les points de chaque groupe seront reliés entre eux.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
           \DataTypeTok{y =}\NormalTok{ gross\_revenue, }\DataTypeTok{group =}\NormalTok{ country)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_line_2-1.pdf}

\hypertarget{graphiques_ggplot_geom_polygon}{%
\subsubsection{Polygones}\label{graphiques_ggplot_geom_polygon}}

La fonction \texttt{geom\_polygon()} permet de tracer des polygones. Les coordonnées doivent être ordonnées dans le sens direct. Tandis que de nombreuses fonctions utilisant des polygones en \texttt{R} nécessitent que la première et la dernière observation soient identiques, et ce afin de pouvoir fermer le polygone, ce n'est pas obligatoire avec \{\texttt{ggplot2}\}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.75}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.5}\NormalTok{))}

\KeywordTok{ggplot}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y), }\DataTypeTok{fill =} \StringTok{"light green"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_polygon-1} \end{center}

\hypertarget{graphiques_ggplot_geom_boxplot}{%
\subsubsection{Boxplot}\label{graphiques_ggplot_geom_boxplot}}

Pour réaliser une boîte à moustache, il faut utiliser la fonction \texttt{geom\_boxplot()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ country, }\DataTypeTok{y =}\NormalTok{ runtime, }\DataTypeTok{fill =}\NormalTok{ country)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_boxplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_boxplot-1} \end{center}

\begin{remarque}
La fonction \texttt{geom\_boxplot()} ne permet pas de tracer de manière élégante (au sens du code) la boîte à moustache pour une seule variable. Il faut pour cela, avoir recours à une petite astuce : fournir une variable factorielle à une seule modalité à l'esthétique \texttt{x}.
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{factor}\NormalTok{(}\DecValTok{1}\NormalTok{), }\DataTypeTok{y =}\NormalTok{ runtime)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_boxplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_boxplot_seule-1} \end{center}

\hypertarget{graphiques_ggplot_geom_jitter}{%
\subsubsection{Gigue}\label{graphiques_ggplot_geom_jitter}}

Une forme géométrique qui peut être pratique est \texttt{jitter}. Elle permet de placer les points côte à côte au lieu de les entasser. Dans le cas de variables catégorielles, cela peut être intéressant à utiliser.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ country, }\DataTypeTok{y =}\NormalTok{ estimated\_budget, }\DataTypeTok{col =}\NormalTok{ country)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_qplot_geom_jitter-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ country, }\DataTypeTok{y =}\NormalTok{ estimated\_budget, }\DataTypeTok{col =}\NormalTok{ country)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_jitter}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_qplot_geom_jitter-2} \end{center}

\hypertarget{graphiques_ggplot_geom_smooth}{%
\subsubsection{Courbe de tendance}\label{graphiques_ggplot_geom_smooth}}

On peut facilement ajouter une courbe de tendance à un nuage de points, en ajoutant une couche avec la fonction \texttt{geom\_smooth()}. Des intervalles de confiance associés aux valeurs obtenues par le lissage sont automatiquement dessinés. Pour les retirer, il faut ajouter \texttt{se=FALSE} à la liste des arguments.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_smooth}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/raphiques_ggplot_ggplot_smooth-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_smooth}\NormalTok{(}\DataTypeTok{se =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/raphiques_ggplot_ggplot_smooth-2} \end{center}

L'argument \texttt{method} contrôle le type de lissage. Par défaut, la fonction \texttt{loess()} est appelée pour le réaliser, et l'argument \texttt{method} est fixé à \texttt{loess}. Si on regarde la page d'aide de cette fonction, on voit que cette dernière possède plusieurs arguments modifiables. Comme l'argument \texttt{...} est présent dans la fonction \texttt{ggplot()}, on peut transmettre à la fonction de lissage les arguments que l'on souhaite modifier.

Parmi les autres méthodes qu'il est possible d'utiliser pour le lissage, on retrouve \texttt{lm}, pour un modèle linéaire, \texttt{rlm} (\emph{package} \{\texttt{MASS}\}) pour un modèle linéaire robuste, ou encore \texttt{gam} (\emph{package} \{\texttt{mgcv}\}) pour un modèle additif généralisé.

Voici un exemple, avec un lissage par régression linéaire, avec un intervalle de confiance pour la prévision à \(90\%\) :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films, }
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{stat\_smooth}\NormalTok{(}\DataTypeTok{method =} \StringTok{"lm"}\NormalTok{, }\DataTypeTok{level =} \FloatTok{0.9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_qplot_smooth_ic-1} \end{center}

\hypertarget{graphiques_qplot_geom_histogram}{%
\subsubsection{Histogramme}\label{graphiques_qplot_geom_histogram}}

Pour réaliser un histogramme, \{\texttt{ggplot2}\} propose la fonction \texttt{geom\_histogram()}. La fenêtre (\emph{bindwidth}) par défaut est l'étendue divisée par 30.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ runtime)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_histogram}\NormalTok{(}\DataTypeTok{fill =} \StringTok{"dodger blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_histogram-1} \end{center}

Si on ajoute au moins un des arguments esthétiques \texttt{colour} ou \texttt{fill} en fonction d'une variable, les histogrammes feront état des sous-groupes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ (estimated\_budget}\OperatorTok{/}\DecValTok{1000000}\NormalTok{)}\OperatorTok{/}\NormalTok{runtime,}
           \DataTypeTok{fill =}\NormalTok{ country))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_histogram}\NormalTok{(}\DataTypeTok{binwidth =} \FloatTok{0.1}\NormalTok{, }\DataTypeTok{colour =} \StringTok{"dark grey"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_histogram_fill-1} \end{center}

\hypertarget{graphiques_qplot_geom_densite}{%
\subsubsection{Densité}\label{graphiques_qplot_geom_densite}}

Pour afficher des estimations de la densité, il faut utiliser la fonction \texttt{geom\_density()}. Le noyau peut être changé \emph{via} l'argument \texttt{kernel} (c.f. la page d'aide \texttt{?stat\_density} pour de plus amples détails).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ (estimated\_budget}\OperatorTok{/}\DecValTok{1000000}\NormalTok{)}\OperatorTok{/}\NormalTok{runtime)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_density}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_densite-1} \end{center}

Si on ajoute au moins un des arguments esthétiques \texttt{colour} ou \texttt{fill} en fonction d'une variable, les densités seront estimées pour chaque sous groupe.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ (estimated\_budget}\OperatorTok{/}\DecValTok{1000000}\NormalTok{)}\OperatorTok{/}\NormalTok{runtime,}
           \DataTypeTok{fill =}\NormalTok{ country)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_density}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"black"}\NormalTok{, }\DataTypeTok{alpha =} \FloatTok{.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_densite_fill-1} \end{center}

\hypertarget{rubans}{%
\subsubsection{Rubans}\label{rubans}}

L'affichage de rubans autour d'une valeur centrale permet, notamment, de réaliser une représentation graphique d'intervalles de confiance. Il suffit pour cela de faire appel à la fonction \texttt{geom\_ribbon()} et de renseigner en plus des arguments \texttt{x} et \texttt{y} qui peuvent être hérités d'une couche précédente, les arguments \texttt{ymin} et \texttt{ymax} qui vont définir les valeurs minimum et maximum pour les ordonnées, respectivement, en chaque point d'abscisse.

Admettons que l'on dispose d'un tableau de données dans lequel, pour chaque unité de temps, on dispose d'une valeur de nombre de passagers estimés, ainsi que les bornes d'un intervalle de confiance données dans les colonnes \texttt{passenger\_low} et \texttt{passenger\_high}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_passengers \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{time =} \KeywordTok{as.vector}\NormalTok{(}\KeywordTok{time}\NormalTok{(AirPassengers)),}
  \DataTypeTok{passenger =} \KeywordTok{as.vector}\NormalTok{(AirPassengers)) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}
    \DataTypeTok{passenger\_low =}\NormalTok{ passenger}\DecValTok{{-}20}\NormalTok{,}
    \DataTypeTok{passenger\_high =}\NormalTok{ passenger}\OperatorTok{+}\DecValTok{20}
\NormalTok{  )}
\NormalTok{df\_passengers}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 144 x 4
##     time passenger passenger_low passenger_high
##    <dbl>     <dbl>         <dbl>          <dbl>
##  1 1949        112            92            132
##  2 1949.       118            98            138
##  3 1949.       132           112            152
##  4 1949.       129           109            149
##  5 1949.       121           101            141
##  6 1949.       135           115            155
##  7 1950.       148           128            168
##  8 1950.       148           128            168
##  9 1950.       136           116            156
## 10 1950.       119            99            139
## # ... with 134 more rows
\end{lstlisting}

Il faut bien penser à afficher le ruban avant la ligne (sinon cette dernière peut se retrouver cachée par le ruban si l'argument \texttt{alpha} du ruban n'autorise aucune transparence).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ df\_passengers,}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ time, }\DataTypeTok{y =}\NormalTok{ passenger)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_ribbon}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{ymin =}\NormalTok{ passenger\_low, }\DataTypeTok{ymax =}\NormalTok{ passenger\_high),}
              \DataTypeTok{fill =} \StringTok{"gray"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_geom_ribbon-1} \end{center}

\hypertarget{graphiques_ggplot_stat}{%
\subsection{Arguments statistiques}\label{graphiques_ggplot_stat}}

Pour effectuer des opérations statistiques sur les données avant de les représenter, \{\texttt{ggplot2}\} propose de nombreuses fonctions. Leur nom suit la syntaxe suivante : \texttt{stat\_*} avec \texttt{*} le nom d'une opération à réaliser, comme par exemple \texttt{density} pour une estimation de la densité par la méthode du noyau. Les fonctions de type \texttt{geom\_*} s'appuient sur celles de type \texttt{stat\_*}. Une ou plusieurs variables sont créés automatiquement lors de l'appel à ces fonctions.

Il faut savoir qu'il est possible d'accéder à ces variables, à condition de connaître leur nom, en les entourant par deux points de chaque côté. Par exemple, lorsque l'on fait appel à la fonction \texttt{geom\_histogram()}, un appel interne à la fonction \texttt{stat\_bin()} est fait par défaut (voir le fichier d'aide de la fonction \texttt{geom\_histogram()}). Or, la fonction \texttt{stat\_bin()} retourne entre autre les variables \texttt{count}, qui indique le nombre d'observations dans chaque classe créée (\emph{bin}) ; \texttt{density} pour la densité des points dans chaque classe, mise à l'échelle pour que l'intégrale vaille 1 (pourcentage du total sur la largeur de la barre).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Par défaut, stat\_bin() utilise ..count.. en ordonnées}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ runtime)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_histogram}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_stat-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Produit le même résultat}
\CommentTok{\# ggplot(data = films\_reduit, aes(x = runtime)) + stat\_bin()}

\CommentTok{\# Pour afficher la densité estimée à la place}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ runtime)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_histogram}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =}\NormalTok{ ..density..))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_stat-2} \end{center}

Il n'est pas rare de vouloir tracer un histogramme et d'y ajouter une courbe de densité. Pour cela, avec \{\texttt{ggplot2}\}, on peut faire appel à la fonction \texttt{stat\_density()}, soit directement, soit par l'intermédiaire de la fonction \texttt{geom\_line()}, en fournissant la valeur \texttt{"density"} à l'argument \texttt{stat}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ runtime))}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_histogram}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{geom\_line}\NormalTok{(}\DataTypeTok{stat=}\StringTok{"density"}\NormalTok{, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{size =} \FloatTok{1.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_stat_density-1} \end{center}

On peut voir sur le précédent graphique que les valeurs pour l'axe des ordonnées sont basées sur ce qu'utilise par défaut la fonction \texttt{geom\_histogram()}{[}\^{}On peut noter que si on fait appel à la fonction \texttt{geom\_line()} avant \texttt{geom\_histogram()}, l'étiquette de l'axe des ordonnées sera \texttt{density}, mais les valeurs seront bien celles du nombre de données par classe !{]}, à savoir le nombre de données par classe. En revanche, l'axe des ordonnées pour la densité estimée par \texttt{stat\_density()} est la valeur de la densité. Comme les valeurs de la densité sont moins élevées que celles du nombre de points par classe, on n'aperçoit qu'une forme applatie de cette première. Aussi, il faut indiquer à la fonction \texttt{ggplot()} le \emph{mapping} suivant : \texttt{y\ =\ ..density..}. De fait, lors de l'appel de la fonction \texttt{stat\_bin()}, la valeur utilisée pour \texttt{y} sera la densité plutôt que la variable de comptage.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ runtime, }\DataTypeTok{y =}\NormalTok{ ..density..))}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_histogram}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"white"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_line}\NormalTok{(}\DataTypeTok{stat=}\StringTok{"density"}\NormalTok{, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{size =} \FloatTok{1.2}\NormalTok{)  }
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_stat_2-1} \end{center}

Un dernier exemple des fonctions \texttt{stat\_*()} (le lecteur ou la lectrice étant invité•e à consulter les références mentionnées au sujet de \{\texttt{ggplot2}\} pour plus de détails sur ces fonctions) : les estimations de densité en 2d.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ runtime, }\DataTypeTok{y =}\NormalTok{ gross\_revenue))}

\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{stat\_density2d}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_stat_3-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En faisant dépendre la couleur des lignes de contour de la hauteur}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{stat\_density2d}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =}\NormalTok{ ..level..)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_stat_3-2} \end{center}

Les principales fonctions \texttt{stat\_*()}, qui peuvent donc être soit appelées directement, soit en fournissant le suffixe à l'argument \texttt{stat} d'une fonction \texttt{geom\_*}, sont les suivantes :

\begin{itemize}
\tightlist
\item
  \texttt{stat\_bin()} : répartition des données en classes ;
\item
  \texttt{stat\_contour()} : calculer les contours des données en 3d ;
\item
  \texttt{stat\_density()} : estimation de densité 1d par la méthode du noyau;
\item
  \texttt{stat\_density2d()} : estimation de densité 2d ;
\item
  \texttt{stat\_identity()} : ne transforme pas les données ;
\item
  \texttt{stat\_qq()} : \emph{qqplot} (droite de Henry) ;
\item
  \texttt{stat\_quantile()} : quantiles continus ;
\item
  \texttt{stat\_smooth()} : lissage ;
\item
  \texttt{stat\_sum()} : somme les valeurs uniques ;
\item
  \texttt{stat\_summary()} : appliquer une fonction pour faire des \emph{summaries} sur les valeurs de \texttt{y} ;
\item
  \texttt{stat\_unique()} : retire les valeurs dupliquées.
\end{itemize}

\hypertarget{graphiques_ggplot_scale}{%
\subsection{\texorpdfstring{Échelles (fonction \texttt{scale\_*()})}{Échelles (fonction scale\_*())}}\label{graphiques_ggplot_scale}}

Les fonctions \texttt{scale\_*()} du \emph{package} \{\texttt{ggplot2}\} permettent de définir et contrôler le \emph{mapping} entre les données et les attributs esthétiques. Chaque argument esthétique possède son échelle, et sa fonction \texttt{scale\_*()}. Encore une fois, le nom des fonctions est bien pensé, et tout est uniformisé. De fait, l'utilisateur peut, une fois qu'il a compris le fonctionnement d'une fonction, utiliser toutes les autres aisément.

On peut diviser en quatre catégories les échelles :

\begin{itemize}
\tightlist
\item
  de positions ;
\item
  de couleurs ;
\item
  manuelles discrètes ;
\item
  \texttt{identity} : pas de mise à l'échelle.
\end{itemize}

Ces échelles font donc le lien entre :

\begin{itemize}
\tightlist
\item
  le domaine (\emph{domain}) : il s'agit de l'espace des données. Cet espace est caractérisé de manière différente selon la nature des données. En effet, si ces dernières sont discrètes, ce qui est le cas pour les facteurs, les logiques ou encore les chaînes de caractères, alors le domaine sera une énumération des valeurs possibles. En revanche, si les données sont continues, le domaine sera être défini par un intervalle ;
\item
  la gamme (\emph{range}) : il s'agit de l'espace des esthétiques. La gamme sera discrète lorsque le domaine l'est, et sera constituée des valeurs esthétiques correspondantes aux valeurs des données d'\emph{input}. En revanche, lorsque le domaine est continue, la gamme est alors un chemin, pour indiquer comment passer d'une valeur à une autre.
\end{itemize}

Les échelles sont ajoutées automatiquement aux graphiques et l'utilisateur n'a rien à faire (c'est ce qui a été fait dans les sections précédentes). Cependant, la possibilité de changer ces échelles est offerte à l'utilisateur, par l'intermédiaire des fonction \texttt{scale\_*()}. Les échelles dépendent du type de variable en \emph{input}, à savoir continues (\emph{numeric}) ou discrètes (\emph{factor}, \emph{character} ou \emph{logical}). Pour ajouter ou modifier une échelle, il faut en construire une nouvelle, et l'ajouter au graphique, à l'aide, encore une fois, de l'opérateur \texttt{+}. Le nom des échelles est composé de deux ou trois parties : le préfixe \texttt{scale\_}, puis le nom de l'esthétique auquel on ajoute un trait de soulignement, et enfin le nom de l'échelle à utiliser. Par exemple, pour modifier l'échelle qui gère la couleur, pour des données d'\texttt{input} continues, pour changer les couleurs du gradient, il faut utiliser la fonction \texttt{scale\_colour\_gradient()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
                \DataTypeTok{y =}\NormalTok{ gross\_revenue, }\DataTypeTok{colour =}\NormalTok{ runtime)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Changer l\textquotesingle{}échelle des couleurs pour que les films les plus courts}
\CommentTok{\# soient en rouge (\#FF0000), et les plus longs en jaune (\#FFFF00),}
\CommentTok{\# en créant un dégradé.}
\CommentTok{\# On change également le titre de la légende}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_colour\_gradient}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Runtime"}\NormalTok{, }\DataTypeTok{low =} \StringTok{"\#FF0000"}\NormalTok{, }\DataTypeTok{high =}\StringTok{"\#FFFF00"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale-2} \end{center}

Le tableau ci-dessous répertorie les fonctions \texttt{scale\_*()} en fonction du type d'esthétique et de la nature discrète ou continue des données.

\begin{longtable}[]{@{}lll@{}}
\toprule
\begin{minipage}[b]{0.22\columnwidth}\raggedright
Esthétique\strut
\end{minipage} & \begin{minipage}[b]{0.35\columnwidth}\raggedright
Variable discrète\strut
\end{minipage} & \begin{minipage}[b]{0.35\columnwidth}\raggedright
Variable continue\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.22\columnwidth}\raggedright
Transparence (alpha)\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_alpha\_discrete()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_alpha\_continuous()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_alpha\_manual()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_alpha\_identity()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_alpha\_identity()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
Couleur (colour)\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_discrete()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_continuous()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_brewer()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_dilstiller()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_grey()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_gradient()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_hue()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_gradient2()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_manual()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_gradientn()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_identity()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_colour\_identity()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
Remplissage (fill)\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_discrete()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_continuous()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_brewer()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_distiller()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_grey()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_gradient()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_hue()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_gradient2()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_manual()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_gradientn()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_identity()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_fill\_identity()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
Type de ligne (linetype)\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_linetype\_discrete()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_linetype\_continuous()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_linetype\_manual()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_linetype\_identity()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_linetype\_identity()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
Forme\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_shape\_discrete()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_shape\_continuous()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_shape\_manual()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_shape\_identity()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_shape\_identity()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
Taille (size)\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_size\_discrete()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_size\_continuous()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_size\_manual()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_size\_area()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_size\_identity()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_size\_identity()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
Position (x, y)\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_x\_discrete()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_x\_continuous()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_y\_discrete()}\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_y\_continuous()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_x\_date()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_y\_date()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_x\_datetime()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_y\_datetime()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_x\_log10()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_y\_log10()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_x\_reverse()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_y\_reverse()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_x\_sqrt()}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.35\columnwidth}\raggedright
\texttt{scale\_y\_sqrt()}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

L'emploi de ces fonctions est simple, et les fichiers d'aide lèvent les éventuels doutes. Prenons cependent le temps de regarder un second exemple. Traçons un nuage de points représentant le revenu brut des films en fonction de leur budget ; faisons dépendre la couleur et la taille des points du pays d'origine, et de la longueur du film respectivement. La couleur dépend donc d'une variable discrète, et la taille d'une variable continue.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
                \DataTypeTok{y =}\NormalTok{ gross\_revenue,}
                \DataTypeTok{colour =}\NormalTok{ country,}
                \DataTypeTok{size =}\NormalTok{ runtime)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}

\CommentTok{\# Le graphique par défaut}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale_2-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Dégradé de gris pour la couleur, les valeurs manquantes en orange}
\CommentTok{\# Le titre de la légende est aussi modifié}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_colour\_grey}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{, }\DataTypeTok{start =} \FloatTok{.1}\NormalTok{, }\DataTypeTok{end =} \FloatTok{.8}\NormalTok{,}
                      \DataTypeTok{na.value =} \StringTok{"orange"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale_2-2} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Définissons nous{-}même la couleur pour chaque pays}
\CommentTok{\# Si on souhaite en plus afficher un nom différent,}
\CommentTok{\# il faut faire attention à bien effectuer le matching...}
\CommentTok{\# La variable "country" est transformée en facteur,}
\CommentTok{\# l\textquotesingle{}ordre est alphabétique (mais peut être changé avec la fonction order())}
\KeywordTok{levels}\NormalTok{(}\KeywordTok{factor}\NormalTok{(films\_reduit}\OperatorTok{$}\NormalTok{country))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "New Zealand"              "Spain"                   
## [3] "United Kingdom"           "United States of America"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Une première solution}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_colour\_manual}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{,}
                        \DataTypeTok{values =} \KeywordTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"green"}\NormalTok{, }\StringTok{"blue"}\NormalTok{, }\StringTok{"orange"}\NormalTok{),}
                        \DataTypeTok{labels =} \KeywordTok{c}\NormalTok{(}\StringTok{"NZ"}\NormalTok{, }\StringTok{"ES"}\NormalTok{, }\StringTok{"UK"}\NormalTok{, }\StringTok{"USA"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale_2-3} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Une seconde solution, plus longue, moins esthétique, mais plus sûre}
\NormalTok{p \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_colour\_manual}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{,}
                          \DataTypeTok{values =} \KeywordTok{c}\NormalTok{(}\StringTok{"Spain"}\NormalTok{ =}\StringTok{ "green"}\NormalTok{, }\StringTok{"New Zealand"}\NormalTok{ =}\StringTok{ "red"}\NormalTok{,}
                                     \StringTok{"United States of America"}\NormalTok{ =}\StringTok{ "orange"}\NormalTok{,}
                                     \StringTok{"United Kingdom"}\NormalTok{ =}\StringTok{ "blue"}\NormalTok{),}
                          \DataTypeTok{labels =} \KeywordTok{c}\NormalTok{(}\StringTok{"Spain"}\NormalTok{ =}\StringTok{ "ES"}\NormalTok{, }\StringTok{"New Zealand"}\NormalTok{ =}\StringTok{ "NZ"}\NormalTok{,}
                                     \StringTok{"United States of America"}\NormalTok{ =}\StringTok{ "USA"}\NormalTok{,}
                                     \StringTok{"United Kingdom"}\NormalTok{ =}\StringTok{ "UK"}\NormalTok{))}


\CommentTok{\# Changeons également la taille}
\CommentTok{\# En choisissant nous même les seuils}
\KeywordTok{range}\NormalTok{(films\_reduit}\OperatorTok{$}\NormalTok{runtime)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  66 375
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_size\_continuous}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Film}\CharTok{\textbackslash{}n}\StringTok{Duration"}\NormalTok{,}
                          \DataTypeTok{breaks =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{300}\NormalTok{, }\OtherTok{Inf}\NormalTok{),}
                          \DataTypeTok{range =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale_2-4} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Un autre graphique, avec des dates en abscisses.}
\CommentTok{\# Le package scales offre de merveilleuses fonctions !}
\NormalTok{films\_reduit}\OperatorTok{$}\NormalTok{initial\_release\_date2 \textless{}{-}}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(films\_reduit}\OperatorTok{$}\NormalTok{initial\_release\_date)}
\NormalTok{p\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
              \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ initial\_release\_date2, }\DataTypeTok{y =}\NormalTok{ runtime)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}

\CommentTok{\# En affichant les dates tous les dix ans uniquement}
\KeywordTok{library}\NormalTok{(scales)}
\NormalTok{p\_}\DecValTok{2} \OperatorTok{+}\StringTok{ }\KeywordTok{scale\_x\_date}\NormalTok{(}\DataTypeTok{breaks =} \KeywordTok{date\_breaks}\NormalTok{(}\StringTok{"10 year"}\NormalTok{),}
                   \DataTypeTok{labels =} \KeywordTok{date\_format}\NormalTok{(}\StringTok{"\%Y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale_2-5} \end{center}

Les légendes affichées sont fonction du \emph{mapping} réalisé, et \{\texttt{ggplot2}\} essaie de combiner les légendes autant que possible. Par exemple, si le paramétrage de la couleur et de la forme concernent la même variable, au lieu d'afficher deux légendes distinctes (une pour la couleur, et une pour la forme), une seule combinant les deux arguments esthétiques sera affichée. Par ailleurs, il est nécessaire que les légendes qui sont combinées possèdent le même nom. Il est important d'avoir conscience de cela : en effet, pour changer le titre d'une légende, si elle est le résultat d'une combinaison, il est nécessaire de le changer pour toutes les légendes qui composent la combinaison.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue,}
                \DataTypeTok{colour =}\NormalTok{ country\_abr, }\DataTypeTok{size =}\NormalTok{ country\_abr)) }\OperatorTok{+}
\StringTok{              }\KeywordTok{geom\_point}\NormalTok{()}

\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_colour\_discrete}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale_3-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_colour\_discrete}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{scale\_size\_discrete}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_scale_3-2} \end{center}

\hypertarget{graphiques_ggplot_group}{%
\subsection{Groupes}\label{graphiques_ggplot_group}}

Dans de nombreux cas, \{\texttt{ggplot2}\} effectue des regroupements automatiquement, lorsqu'il y a besoin de tracer des objets géométriques. Par exemple, lorsque l'on souhaite tracer des points, chaque groupe est constitué d'un seul point. Pour tracer des polygones, chaque groupe est constitué de plusieurs points qu'il faut relier. Le groupement s'effectue en fonction des interactions de toutes les variables qualitatives d'un graphique. Parfois, il est nécessaire de définir à nouveau les groupes (par exemple, si aucune variable discrète n'est appelée dans le graphique). Pour ce faire, il faut préciser quelle variable doit permettre le regroupement, en l'indiquant à l'argument \texttt{group}. L'exemple qui suit s'appuie sur les données \texttt{AirPassengers}, qui renseignent le nombre de passagers aériens annuels entre 1949 et 1960. Si on désire afficher le nombre de passagers en fonction des mois de l'année, en superposant les courbes par année, l'argument \texttt{group} nous le permet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{year =} \KeywordTok{rep}\NormalTok{(}\DecValTok{1949}\OperatorTok{:}\DecValTok{1960}\NormalTok{, }\DataTypeTok{each =} \DecValTok{12}\NormalTok{),}
           \DataTypeTok{month =} \KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DecValTok{12}\NormalTok{),}
           \DataTypeTok{passengers =} \KeywordTok{c}\NormalTok{(AirPassengers))}
\KeywordTok{head}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## # A tibble: 6 x 3
##    year month passengers
##   <int> <int>      <dbl>
## 1  1949     1        112
## 2  1949     2        118
## 3  1949     3        132
## 4  1949     4        129
## 5  1949     5        121
## 6  1949     6        135
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sans préciser de groupe}
\CommentTok{\# Comme il n\textquotesingle{}y a pas de variable discrète, on obtient }
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ month, }\DataTypeTok{y =}\NormalTok{ passengers)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_line}\NormalTok{()}

\CommentTok{\# En précisant que l\textquotesingle{}on souhaite regrouper par années}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ month, }\DataTypeTok{y =}\NormalTok{ passengers, }\DataTypeTok{group =}\NormalTok{ year)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_group-1} \includegraphics{_main_files/figure-latex/graphiques_ggplot_group-2} \end{center}

Si on veut tracer des lignes qui relient des points au sein d'un même groupe, alors que l'échelle est discrète, il est tout à fait possible d'indiquer un changement du groupement par défaut. Il suffit alors de préciser la valeur du groupe à l'argument \texttt{group} dans la fonction \texttt{aes()} de la fonction \texttt{geom\_line()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Boxplot du nombre de passager pour chaque mois}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{factor}\NormalTok{(month), }\DataTypeTok{y =}\NormalTok{ passengers)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_boxplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_group_2-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En ajoutant les lignes de chaque année}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{factor}\NormalTok{(month), }\DataTypeTok{y =}\NormalTok{ passengers)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_boxplot}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_line}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{group =}\NormalTok{ year), }\DataTypeTok{colour =} \StringTok{"dodger blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_group_2-2} \end{center}

\hypertarget{graphiques_ggplot_annotations}{%
\subsection{Annotations}\label{graphiques_ggplot_annotations}}

L'annotation sur un graphique peut passer par du texte, ou bien par l'ajout d'objets géométriques (\emph{e.g.}, des lignes ou des rectangles).

Les exemples qui suivent vont s'appuyer sur le graphique suivant.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget, }\DataTypeTok{y =}\NormalTok{ gross\_revenue)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{graphiques_ggplot_annotations_texte}{%
\subsubsection{Texte}\label{graphiques_ggplot_annotations_texte}}

Pour ajouter du texte sur les graphiques, il existe deux fonctions dans le \emph{package} \texttt{ggplot} : \texttt{geom\_text()} et \texttt{annotate()}, bien que la dernière soit plus générique (elle permet d'ajouter d'autres éléments que du texte). Nous ne présentons que la manière d'utiliser \texttt{annotate()}, dans la mesure où elle offre des performances accrues comparativement à \texttt{geom\_text()}.

La fonction \texttt{annotate()}, dans le cas général, créé une nouvelle couche qui contient les annotations. Les données pour faire le lien avec les arguments esthétiques ne sont pas celles du tableau de données, mais contenues dans un vecteur qu'il est nécessaire de renseigner. Par ailleurs, la forme géométrique est à définir \emph{via} l'argument \texttt{geom} (\texttt{"text"} pour du texte, ou encore \texttt{"segment"} pour un segment, etc.). Enfin, comme pour les couches de type \texttt{geom\_*}, on peut rajouter des arguments esthétiques.

Pour ajouter du texte, on précise la position \texttt{x} et \texttt{y} (ou les positions, si on désire afficher plusieurs textes), l'argument \texttt{geom} doit recevoir la valeur \texttt{"text"} et l'argument \texttt{legend} se voit attribuer la chaîne à afficher (ou les chaînes en cas d'affichage de plusieurs textes){[}\^{}Les règles de recyclage s'appliquent !{]}. Si on souhaite afficher le texte d'une certaine couleur, on peut ajouter l'argument \texttt{colour} dans la fonction \texttt{annotate()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ajout d\textquotesingle{}un texte simple}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{annotate}\NormalTok{(}\StringTok{"text"}\NormalTok{, }\DataTypeTok{x =} \FloatTok{1e8}\NormalTok{, }\DataTypeTok{y =} \FloatTok{2e9}\NormalTok{, }\DataTypeTok{label =} \StringTok{"Du texte"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_texte-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ajoute de deux textes, le premier en rouge, le second en bleu}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{annotate}\NormalTok{(}\StringTok{"text"}\NormalTok{, }\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\FloatTok{1e8}\NormalTok{, }\FloatTok{2e8}\NormalTok{), }\DataTypeTok{y =} \FloatTok{2e9}\NormalTok{,}
             \DataTypeTok{label =} \KeywordTok{c}\NormalTok{(}\StringTok{"Du texte"}\NormalTok{, }\StringTok{"Un autre texte"}\NormalTok{),}
             \DataTypeTok{colour =} \KeywordTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"blue"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_texte-2} \end{center}

Dès lors que des lettres grecques doivent apparaître, ou bien des écritures en indice ou exposant, ou encore des symboles mathématiques, on peut rajouter l'argument \texttt{parse} évalué à \texttt{TRUE}. Pour faire apparaître une lettre grecque, il suffit d'écrire son nom. Pour écrire en indice, on utilise les crochets \texttt{{[}{]}} et pour écrire en exposant, l'accent circonflèxe \texttt{\^{}}. Attention, pour ajouter un terme en indice et un en exposant, il est nécessaire de le faire dans l'ordre suivant : d'abord en indice, puis en exposant.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{annotate}\NormalTok{(}\StringTok{"text"}\NormalTok{, }\DataTypeTok{x =} \FloatTok{1e8}\NormalTok{, }\DataTypeTok{y =} \FloatTok{2e9}\NormalTok{,}
             \DataTypeTok{label =} \StringTok{"sqrt(1{-}alpha) + beta[i+1]\^{}n"}\NormalTok{, }\DataTypeTok{parse =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_expr-1} \end{center}

Il est aussi possible, pour afficher des expressions mathématiques ou des lettres grecques, de faire appel à la fonction \texttt{TeX} du \emph{package} \{\texttt{latex2exp}\}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(latex2exp)}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{annotate}\NormalTok{(}\StringTok{"text"}\NormalTok{, }\DataTypeTok{x =} \FloatTok{1e8}\NormalTok{, }\DataTypeTok{y =} \FloatTok{2e9}\NormalTok{,}
             \DataTypeTok{label =} \KeywordTok{TeX}\NormalTok{(}\StringTok{"$}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{sqrt\{1{-}}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{alpha\} + }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{beta\^{}\{n\}\_\{i+1\}$"}\NormalTok{,}
                         \DataTypeTok{output =} \StringTok{"character"}\NormalTok{),}
             \DataTypeTok{parse =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-108-1.pdf}

\hypertarget{graphiques_ggplot_annotations_lignes}{%
\subsubsection{Lignes}\label{graphiques_ggplot_annotations_lignes}}

Le \emph{package} \{\texttt{ggplot2}\} contient quatre fonctions très utile pour ajouter des lignes sur un graphique, en plus des fonctions \texttt{geom\_line()} et \texttt{geom\_path()} :

\begin{itemize}
\tightlist
\item
  \texttt{geom\_vline()} : ligne verticale;
\item
  \texttt{geom\_hline()} : ligne horizontale;
\item
  \texttt{geom\_abline()} : ligne spécifiée par sa pente et son ordonnée à l'origine ;
\item
  \texttt{geom\_segment()} : segment ou flèche (en utilisant \texttt{arrow()}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ligne verticale}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_vline}\NormalTok{(}\DataTypeTok{xintercept =} \KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{3e8}\NormalTok{, }\DataTypeTok{by =} \FloatTok{1e8}\NormalTok{),}
               \DataTypeTok{size =} \DecValTok{1}\NormalTok{, }\DataTypeTok{col =} \StringTok{"dodger blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_lignes-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ligne horizontale}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_hline}\NormalTok{(}\DataTypeTok{yintercept =} \KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{2e9}\NormalTok{, }\DataTypeTok{by =} \FloatTok{1e9}\NormalTok{),}
               \DataTypeTok{col =} \StringTok{"gold"}\NormalTok{, }\DataTypeTok{linetype =} \StringTok{"longdash"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_lignes-2} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Droite}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_abline}\NormalTok{(}\DataTypeTok{intercept =} \FloatTok{1e9}\NormalTok{, }\DataTypeTok{slope =} \DecValTok{{-}5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_lignes-3} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Segment}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_segment}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \DecValTok{0}\NormalTok{, }\DataTypeTok{xend =} \FloatTok{1e8}\NormalTok{, }
                     \DataTypeTok{y =} \DecValTok{0}\NormalTok{, }\DataTypeTok{yend =} \FloatTok{1e9}\NormalTok{), }\DataTypeTok{col =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_lignes-4} \end{center}

Pour les segments, il peut être plus intéressant d'utiliser la fonction \texttt{annotate()}, afin de s'affranchir de tout héritage des arguments de la fonction \texttt{ggplot()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{annotate}\NormalTok{(}\DataTypeTok{geom =} \StringTok{"segment"}\NormalTok{,}
             \DataTypeTok{x =} \DecValTok{0}\NormalTok{, }\DataTypeTok{xend =} \FloatTok{1e8}\NormalTok{,}
             \DataTypeTok{y =} \DecValTok{0}\NormalTok{, }\DataTypeTok{yend =} \FloatTok{1e9}\NormalTok{, }\DataTypeTok{col =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_lignes_annotate-1} \end{center}

Pour tracer une flèche, il faut avoir recours à la fonction \texttt{arrow()} du \emph{package} \{\texttt{grid}\}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{annotate}\NormalTok{(}\DataTypeTok{geom =} \StringTok{"segment"}\NormalTok{, }\DataTypeTok{x =} \DecValTok{0}\NormalTok{, }\DataTypeTok{xend =} \FloatTok{1e8}\NormalTok{,}
             \DataTypeTok{y =} \DecValTok{0}\NormalTok{, }\DataTypeTok{yend =} \FloatTok{1e9}\NormalTok{, }\DataTypeTok{col =} \StringTok{"blue"}\NormalTok{,}
             \DataTypeTok{arrow =} \KeywordTok{arrow}\NormalTok{(}\DataTypeTok{length =} \KeywordTok{unit}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\StringTok{"cm"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_lignes_arrow-1} \end{center}

\hypertarget{graphiques_ggplot_annotations_rect}{%
\subsubsection{Rectangles}\label{graphiques_ggplot_annotations_rect}}

Pour ajouter un rectangle à un graphique, ce qui peut être pratique avec des données temporelles par exemple (\emph{e.g.}, pour faire figurer les périodes de croissance ou de récession), on peut utiliser soit la fonction \texttt{geom\_rect()}, soit à nouveau la fonction \texttt{annotate()}. Les deux méthodes fonctionnent à peu près de la même façon, mais encore une fois, \texttt{annotate()} permet de ne pas subir les héritages des arguments esthétiques.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{annotate}\NormalTok{(}\DataTypeTok{geom =} \StringTok{"rect"}\NormalTok{, }\DataTypeTok{xmin =} \FloatTok{1e8}\NormalTok{, }\DataTypeTok{xmax =} \FloatTok{2e8}\NormalTok{,}
             \DataTypeTok{ymin =} \OperatorTok{{-}}\OtherTok{Inf}\NormalTok{, }\DataTypeTok{ymax =} \OtherTok{Inf}\NormalTok{,}
             \DataTypeTok{alpha =} \FloatTok{.3}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"red"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{annotate}\NormalTok{(}\DataTypeTok{geom  =}\StringTok{"rect"}\NormalTok{, }\DataTypeTok{xmin =} \DecValTok{0}\NormalTok{, }\DataTypeTok{xmax =} \FloatTok{5e8}\NormalTok{,}
           \DataTypeTok{ymin =} \FloatTok{1e9}\NormalTok{, }\DataTypeTok{ymax =} \FloatTok{2e9}\NormalTok{,}
           \DataTypeTok{alpha =} \FloatTok{.2}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"dodger blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_annotations_rect-1} \end{center}

\hypertarget{graphiques_ggplot_position}{%
\subsection{Positions}\label{graphiques_ggplot_position}}

Pour modifier le positionnement de certains éléments dans les graphiques, \{\texttt{ggplot2}\} propose cinq fonctions :

\begin{itemize}
\tightlist
\item
  \texttt{position\_dodge()} : évite les chevauchements, place les éléments côte à côte ;
\item
  \texttt{position\_fill()} : empile les éléments qui se chevauchent, en normalisant pour avoir une hauteur égale ;
\item
  \texttt{position\_identity()} : n'ajuste pas la position;
\item
  \texttt{position\_jitter()} : place les éméments côte à côte en essyant d'optimiser l'espace ;
\item
  \texttt{position\_stack()} : empile les éléments qui se chevauchent.
\end{itemize}

La manière la plus simple d'utiliser ces fonctions est de les appeler à travers l'argument \texttt{position} d'une fonction \texttt{geom\_*}, en précisant uniquement le suffixe. Par exemple, avec un diagramme en bâton, pour que les barres soient côte à côte, on indique \texttt{position\ =\ "dodge"} à la fonction `geom\_bar()\}.

Encore une fois, même s'il est possible de réaliser une action avec une fonction de \{\texttt{ggplot2}\}, cela ne veut pas forcément dire que cette action est adaptée à une lecture facilitée. Ainsi, lorsque l'on fournit la valeur \texttt{"identity"} à l'argument \texttt{position} de la fonction \texttt{geom\_bar()}, les barres s'entre-mêlent, et certaines peuvent devenir invisibles, cachées par une autre.

Les exemples ci-après montrent toutes les possibilités de placement pour un diagramme en bâton.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ runtime, }\DataTypeTok{fill =}\NormalTok{ country\_abr))}
\KeywordTok{library}\NormalTok{(grid)}
\NormalTok{p \textless{}{-}}\StringTok{ }\NormalTok{p }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{text =} \KeywordTok{element\_text}\NormalTok{(}\DataTypeTok{size =} \DecValTok{5}\NormalTok{),}
        \DataTypeTok{legend.key.size =} \KeywordTok{unit}\NormalTok{(.}\DecValTok{1}\NormalTok{, }\StringTok{"cm"}\NormalTok{)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{scale\_fill\_discrete}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{)}

\CommentTok{\# Dodge}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"dodge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_position-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Fill}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"fill"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_position-2} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Identity (pas pratique avec un barchart)}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"identity"}\NormalTok{, }\DataTypeTok{alpha =} \FloatTok{.8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_position-3} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Jitter}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"jitter"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_position-4} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Stack}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom\_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"stack"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_position-5} \end{center}

\hypertarget{graphiques_ggplot_facet}{%
\subsection{Facettes}\label{graphiques_ggplot_facet}}

Tout comme pour \texttt{qplot()}, on peut créer des facettes, c'est-à-dire produire des graphique de même type pour différentes sous-divisions du tableau de données, et les aligner sur une grille. \{\texttt{ggplot2}\} propose deux fonctions pour faire du \emph{fateting} : \texttt{facet\_grid()} (produisant une grille à deux dimensions, pour laquelle les variables définissent les lignes et colonnes) et \texttt{facet\_wrap()} (produisant les graphiques pour chaque sous-division, qui sont ensuite placés sur une grille à deux dimension, les uns après les autres).

Les deux arguments principaux de ces fonctions sont : les variables servant à faire le \emph{faceting}, sour forme de formule, et un logique indiquant si les échelles de positions doivent être globales ou bien locales à chaque facette.

Pour être plus précis avec les exemples, nous avons besoin d'une seconde variable qualitative avec peu de modalités. Prenons arbitrairement une variable indicatrice, valant \texttt{nouveau} pour les films produits après 2000, et \texttt{ancien} sinon.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{films\_reduit}\OperatorTok{$}\NormalTok{old \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{ifelse}\NormalTok{(films\_reduit}\OperatorTok{$}\NormalTok{year }\OperatorTok{\textless{}=}\StringTok{ }\DecValTok{2000}\NormalTok{, }\StringTok{"ancien"}\NormalTok{, }\StringTok{"nouveau"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{graphiques_ggplot_facet_grid}{%
\subsubsection{\texorpdfstring{La fonction \texttt{facet\_grid()}}{La fonction facet\_grid()}}\label{graphiques_ggplot_facet_grid}}

Pour créer une grille sur laquelle les colonnes et les lignes servent à différentier différentes modalités de variables, on utilise la fonction \texttt{facet\_grid()}. L'argument \texttt{facets} attend une formule, dont la syntaxe est la suivante : \texttt{variable\_ligne\ \textasciitilde{}\ variable\_colonne}, avec \texttt{variable\_ligne} le nom de la variable facteur en ligne, et \texttt{variable\_colonne} le nom de la variable facteur en colonne. Le symbole \texttt{.} indique que l'on ne souhaite pas créer de facette sur la dimension :

\begin{itemize}
\tightlist
\item
  \texttt{.\textasciitilde{}.} (la valeur par défaut) : ne pas faire de \emph{faceting} ;
\item
  \texttt{.\ \textasciitilde{}\ variable\_colonne} : une ligne, autant de colonnes que de valeurs possibles pour \texttt{variable\_colonne} ;
\item
  \texttt{variable\_ligne\ \textasciitilde{}\ .} : autant de lignes que de valeurs possibles pour \texttt{variable\_ligne}, une seule colonne ;
\item
  \texttt{variable\_ligne\ \textasciitilde{}\ variable\_colonne} : autant de lignes que de valeurs possibles pour \texttt{variable\_ligne}, autant de colonnes que de valeurs possibles pour \texttt{variable\_colonne}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
                \DataTypeTok{y =}\NormalTok{ gross\_revenue,}
                \DataTypeTok{colour =}\NormalTok{ country,}
                \DataTypeTok{size =}\NormalTok{ runtime)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}

\CommentTok{\# Avec une colonne pour chaque pays}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{facet\_grid}\NormalTok{(. }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{country)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_facet_grid-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec en ligne la récence du film, et en colonne le pays}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{facet\_grid}\NormalTok{(old }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{country)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_facet_grid-2} \end{center}

On peut ajouter une option pour avoir les situations marginales (similairement au tableau obtenu, dans le cas de deux variables aléatoires discrètes, faisant figurer les lois marginales en bout de ligne et de colonne). Pour ce faire, il faut attribuer la valeur \texttt{TRUE} à l'argument \texttt{margins}. Si on souhaite afficher uniquement les facettes supplémentaires pour une variable mais pas les deux, il faut fournir le nom de cette variable à l'argument \texttt{margins}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{facet\_grid}\NormalTok{(old }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{country, }\DataTypeTok{margins =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_facet_grid_margins-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ajout d\textquotesingle{}une facette avec tous les pays, en différenciant par ligne (récence)}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{facet\_grid}\NormalTok{(old }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{country, }\DataTypeTok{margins =} \StringTok{"country"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_facet_grid_margins-2} \end{center}

\hypertarget{graphiques_ggplot_facet_wrap}{%
\subsubsection{\texorpdfstring{La fonction \texttt{facet\_wrap()}}{La fonction facet\_wrap()}}\label{graphiques_ggplot_facet_wrap}}

La fonction \texttt{facet\_wrap()} fonctionne un peu différemment de \texttt{facet\_grid()}. En effet, au lieu de travailler en fonction de variables par lignes et par colonnes, elle crée une succession de graphiques qui sont \textbf{par la suite} placés sur une grille à deux dimensions. Pour créer les facette, il faut renseigner une formule à l'argument \texttt{facets}. La syntaxe pour la formule est la suivante : \texttt{\textasciitilde{}\ variable\_1\ +\ variable\_2\ +\ ...\ variable\_n}. La grille finale sera ce qui se rapproche le plus d'un carré. Dans les cas où ce n'est pas possible, la grille sera plutôt large que longue (nos écrans sont généralement configurés ainsi, ce qui explique ce choix).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec une seule variable}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{facet\_wrap}\NormalTok{(}\DataTypeTok{facets =} \OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{country)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_facet_wrap-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec deux variables}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{facet\_wrap}\NormalTok{(}\DataTypeTok{facets =} \OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{country }\OperatorTok{+}\StringTok{ }\NormalTok{old)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_facet_wrap-2} \end{center}

\hypertarget{graphiques_ggplot_facet_scales}{%
\subsubsection{Échelles et facettes}\label{graphiques_ggplot_facet_scales}}

Que ce soit pour \texttt{facet\_grid()} ou \texttt{facet\_wrap()}, il est possible de préciser si les échelles de positions doivent s'appliquer à tous les graphiques de la grille, ou bien doivent varier. Cela se fait \emph{via} l'argument \texttt{scales}. On distingue quatre options :

\begin{itemize}
\tightlist
\item
  \texttt{fixed} : les échelles les fixes, identiques pour chaque graphique ;
\item
  \texttt{free} : les échelles peuvent varier en fonction de chaque graphique de la grille ;
\item
  \texttt{free\_x} : seule l'échelle pour les \texttt{x} peut varier, l'échelle pour les \texttt{y} est fixe, commune à chaque graphique de la grille ;
\item
  \texttt{free\_y} : seule l'échelle pour les \texttt{y} peut varier, l'échelle pour les \texttt{x} est fixe, commune à chaque graphique de la grille.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_m \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
       \KeywordTok{aes}\NormalTok{(estimated\_budget}\OperatorTok{/}\DecValTok{1000000}\NormalTok{, }
\NormalTok{           gross\_revenue}\OperatorTok{/}\DecValTok{1000000}\NormalTok{, }
           \DataTypeTok{colour =}\NormalTok{ country, }
           \DataTypeTok{size =}\NormalTok{ runtime)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}

\CommentTok{\# Toutes les échelles identiques}
\NormalTok{p\_m }\OperatorTok{+}\StringTok{ }\KeywordTok{facet\_wrap}\NormalTok{( }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{country, }\DataTypeTok{scales =} \StringTok{"fixed"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_facet_scales-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Échelles variant pour chaque graphique de la grille}
\NormalTok{p\_m }\OperatorTok{+}\StringTok{ }\KeywordTok{facet\_wrap}\NormalTok{( }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{country, }\DataTypeTok{scales =} \StringTok{"free\_y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_facet_scales-2} \end{center}

\hypertarget{graphiques_ggplot_coord}{%
\subsection{Coordonnées}\label{graphiques_ggplot_coord}}

Le \emph{package} \{\texttt{ggplot2}\} gère plusieurs systèmes de coordonnées différents, le système cartésien étant celui utilisé par défaut. Pour définir le système souhaité, il faut faire appel aux fonctions commençant par \texttt{coord\_} :

\begin{itemize}
\tightlist
\item
  \texttt{coord\_cartesian()} : coordonnées cartésiennes ;
\item
  \texttt{coord\_fixed()} : coordonnées cartésiennes avec la même échelle pour les deux axes ;
\item
  \texttt{coord\_flip()} : coordonnées cartésiennes avec les axes renversés ;
\item
  \texttt{coord\_map()} : projections pour les cartes ;
\item
  \texttt{coord\_polar()} : coordonnées polaires ;
\item
  \texttt{coord\_trans()} : coordonnées cartésiennes transformées.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget}\OperatorTok{/}\FloatTok{1e6}\NormalTok{,}
                \DataTypeTok{y =}\NormalTok{ gross\_revenue}\OperatorTok{/}\FloatTok{1e6}\NormalTok{)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{()}
\CommentTok{\# En renversant les axes}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{coord\_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_coord-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En effectuant une transformation du système de coordonnées}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{coord\_trans}\NormalTok{(}\DataTypeTok{x =} \StringTok{"log10"}\NormalTok{, }\DataTypeTok{y =} \StringTok{"log10"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_coord-2} \end{center}

\begin{remarque}
Nous avons vu que la fonction \texttt{scale\_x\_log10()} (Section~@ref(graphiques\_ggplot\_scale)) permet aussi de changer les échelles en échelles logarithmiques. Cependant, il y a une petite différence : avec \texttt{coord\_trans}, la transformation est réalisée après la réalisation de statistiques. Cela a un impact, par exemple, sur les lignes du quadrillage
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_x\_log10}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_coord_remarque-1} \end{center}

\hypertarget{graphiques_ggplot_axes}{%
\subsection{Titres, axes, légendes}\label{graphiques_ggplot_axes}}

Jusqu'ici, les graphiques proposés en exemple souffrent pour la plupart de l'absence de titre, de légendes illisibles, etc. Heureusement, tout cela est paramétrable !

Pour ajouter un titre, rien de plus simple : faire appel à la fonction \texttt{ggtitle()}, et fournir le titre à l'argument \texttt{label}. Pour changer les étiquettes des axes, on peut faire appel aux fonctions \texttt{xlab()} et \texttt{ylab()} pour l'axe des \texttt{x} et des \texttt{y} respectivement, et renseigner l'argument \texttt{label}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget}\OperatorTok{/}\FloatTok{1e6}\NormalTok{,}
                \DataTypeTok{y =}\NormalTok{ gross\_revenue}\OperatorTok{/}\FloatTok{1e6}\NormalTok{)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{ggtitle}\NormalTok{(}\StringTok{"Titre"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{xlab}\NormalTok{(}\StringTok{"Étiquette axe des x"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{ylab}\NormalTok{(}\StringTok{"Étiquette axe des y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La fonction \texttt{labs()} permet de gérer les trois en même temps :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget}\OperatorTok{/}\FloatTok{1e6}\NormalTok{,}
                \DataTypeTok{y =}\NormalTok{ gross\_revenue}\OperatorTok{/}\FloatTok{1e6}\NormalTok{)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{labs}\NormalTok{(}
    \DataTypeTok{title =} \StringTok{"Titre"}\NormalTok{,}
    \DataTypeTok{x =} \StringTok{"Étiquette axe des x"}\NormalTok{,}
    \DataTypeTok{y =} \StringTok{"Étiquette axe des y"}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

Pour définir manuellement les limites des axes, on peut utiliser les fonctions \texttt{xlim()} et \texttt{ylim()}. Attention toutefois, les valeurs en dehors des intervalles définis seront complètement jetées, les autres couches hériteront des données appartenant aux intervalles définis. Pour changer les limites des axes sans jeter de données, il faut faire appel à la fonction \texttt{coord\_cartesian()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df \textless{}{-}}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{10}\NormalTok{), }
             \DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{10}\NormalTok{),}
             \DataTypeTok{g =} \KeywordTok{factor}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DataTypeTok{each =} \DecValTok{4}\NormalTok{)))}

\NormalTok{p\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y, }\DataTypeTok{group =}\NormalTok{ g, }\DataTypeTok{fill =}\NormalTok{ g)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{()}
\NormalTok{p\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y, }\DataTypeTok{group =}\NormalTok{ g, }\DataTypeTok{fill =}\NormalTok{ g)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position=}\StringTok{"none"}\NormalTok{)}

\CommentTok{\# Le graphique par défaut}
\NormalTok{p\_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_axes_limites-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En jouant avec la limite des x avec la fonction xlim()}
\NormalTok{p\_}\DecValTok{2} \OperatorTok{+}\StringTok{ }\KeywordTok{xlim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_axes_limites-2} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec la fonction coord\_cartesian()}
\NormalTok{p\_}\DecValTok{2} \OperatorTok{+}\StringTok{ }\KeywordTok{coord\_cartesian}\NormalTok{(}\DataTypeTok{xlim =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{7}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_axes_limites-3} \end{center}

Le changement des arguments des légendes est un peu moins simple. Il faut passer par la fonction \texttt{theme()}. Le lecteur ou la lectrice est invité•e à consulter la page d'aide de la fonction à l'adresse suivante : \url{http://docs.ggplot2.org/current/theme.html}. Dès que l'on souhaite modifier l'aspect de la légende, des marques des axes, des étiquettes des axes, des lignes principales et secondaires formant le quadrillage, etc. il faut utiliser la fonction \texttt{theme()}.

Les éléments pouvant être changés sont nombreux. Il y a quatre types de fonctions pour modifier les éléments :

\begin{itemize}
\item
  \texttt{element\_text()} : pour toutes les étiquettes, ce qui est au format texte. On peut modifier :

  \begin{itemize}
  \tightlist
  \item
    \texttt{family} : la famille de la fonte,
  \item
    \texttt{face} : graisse (``plain'', ``italic'', ``bold'', ``bold.italic''),
  \item
    \texttt{colour} : couleur,
  \item
    \texttt{size} : taille en pts,
  \item
    \texttt{hjust} : justification horizontale, dans {[}0, 1{]},
  \item
    \texttt{vjust} : justification verticale, dans {[}0, 1{]},
  \item
    \texttt{angle} : angle, dans {[}0, 360{]},
  \item
    \texttt{lineheight} : hauteur de ligne (pour l'espacement entre les lignes) ;
  \end{itemize}
\item
  \texttt{element\_line()} : pour toutes les lignes tracées. On peut modifier :

  \begin{itemize}
  \tightlist
  \item
    \texttt{colour} : la couleur de ligne,
  \item
    \texttt{size} : la taille,
  \item
    \texttt{linetype} : le type de ligne (``blank'', ``solid'', ``dashed'', ``dotted'', ``dotdash'', ``longdash'', "twodash),
  \item
    \texttt{lineend} : le type de fin de ligne (``round'', ``butt'' ou ``square'') ;
  \end{itemize}
\item
  \texttt{element\_rect()} : pour les backgrounds et les cadres. On peut modifier :

  \begin{itemize}
  \tightlist
  \item
    \texttt{fill} : la couleur de remplissage,
  \item
    \texttt{colour} : la couleur de la bordure,
  \item
    \texttt{size} : la taille de la bordure,
  \item
    \texttt{linetype} : le type de ligne (``blank'', ``solid'', ``dashed'', ``dotted'', ``dotdash'', ``longdash'', "twodash) ;
  \end{itemize}
\item
  \texttt{element\_blank()} permet de ne rien dessiner.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit,}
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget}\OperatorTok{/}\FloatTok{1e6}\NormalTok{, }
                \DataTypeTok{y =}\NormalTok{ gross\_revenue}\OperatorTok{/}\FloatTok{1e6}\NormalTok{,}
                \DataTypeTok{colour =}\NormalTok{ country\_abr)) }\OperatorTok{+}
\StringTok{  }\CommentTok{\# Tracer des points}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{  }\CommentTok{\# Ajout d\textquotesingle{}un titre}
\StringTok{  }\KeywordTok{ggtitle}\NormalTok{(}\StringTok{"Titre}\CharTok{\textbackslash{}n}\StringTok{sur deux lignes"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\CommentTok{\# Changement des étiquettes pour les axes}
\StringTok{  }\KeywordTok{xlab}\NormalTok{(}\StringTok{"Étiquette axe des x"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylab}\NormalTok{(}\StringTok{"Étiquette axe des y"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\CommentTok{\# Changement du titre de la légende}
\StringTok{  }\KeywordTok{scale\_colour\_discrete}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{)}

\CommentTok{\# Le graphique par défaut}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_axes_theme-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En changeant certains éléments}
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{plot.title =} \KeywordTok{element\_text}\NormalTok{(}\DataTypeTok{family =} \StringTok{"Times"}\NormalTok{, }\DataTypeTok{face =} \StringTok{"bold"}\NormalTok{,}
                       \DataTypeTok{colour =} \StringTok{"red"}\NormalTok{,}
                       \DataTypeTok{size =} \KeywordTok{rel}\NormalTok{(}\DecValTok{2}\NormalTok{),}
                       \DataTypeTok{hjust =} \DecValTok{0}\NormalTok{,}
                       \DataTypeTok{lineheight =} \FloatTok{1.5}\NormalTok{),}
          \DataTypeTok{axis.title =} \KeywordTok{element\_text}\NormalTok{(}\DataTypeTok{face =} \StringTok{"bold"}\NormalTok{, }\DataTypeTok{colour =} \StringTok{"orange"}\NormalTok{),}
          \DataTypeTok{axis.text.x =} \KeywordTok{element\_text}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"blue"}\NormalTok{, }\DataTypeTok{angle =} \DecValTok{45}\NormalTok{),}
          \DataTypeTok{axis.ticks =} \KeywordTok{element\_line}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"brown"}\NormalTok{, }\DataTypeTok{size =} \KeywordTok{rel}\NormalTok{(}\DecValTok{2}\NormalTok{)),}
          \DataTypeTok{legend.key =} \KeywordTok{element\_rect}\NormalTok{(}\DataTypeTok{fill =} \StringTok{"dodger blue"}\NormalTok{, }\DataTypeTok{colour =} \StringTok{"red"}\NormalTok{),}
          \DataTypeTok{legend.background =} \KeywordTok{element\_rect}\NormalTok{(}\DataTypeTok{fill =} \StringTok{"green"}\NormalTok{,}
                                           \DataTypeTok{colour =} \StringTok{"purple"}\NormalTok{,}
                                           \DataTypeTok{linetype =} \StringTok{"twodash"}\NormalTok{),}
          \DataTypeTok{panel.grid.minor =} \KeywordTok{element\_blank}\NormalTok{(),}
          \DataTypeTok{panel.grid.major =} \KeywordTok{element\_line}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"black"}\NormalTok{)}
\NormalTok{          )}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_axes_theme-2} \end{center}

Comme on peut le voir, changer les arguments graphiques peut facilement produire un graphique difficile à lire. Le thème par défaut dans \{\texttt{ggplot2}\} a été étudié, il convient dans de nombreux cas (pour un affichage sur un écran d'ordinateur). Mais on est parfois amené à effectuer quelques changements, d'où l'importance deprésenter la méthode pour réaliser ces changements. Par ailleurs, il existe d'autres thèmes réfléchis dans le \emph{package} \{\texttt{ggplot2}\}, parmi lesquels \texttt{theme\_bw()} (\emph{background} blanc et grilles noires) ou \texttt{theme\_grey()} (\emph{background} gris et grilles blanches) ou encore \texttt{theme\_mini()} (pour un affichage minimaliste).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{theme\_bw}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_axes_theme_3-1} \end{center}

Certains développent des thèmes supplémentaires. Voir par exemple sur ce \emph{github} : \url{https://github.com/jrnold/ggthemes}.

Depuis 2020, il est possible dans \{\texttt{ggplot2}\} de choisir d'afficher le titre du graphique tout à gauche, aligné avec les étiquettes de l'axe des ordonnées, en renseignant à \texttt{"plot"} l'argument \texttt{plot.title.position} de la fonction \texttt{theme()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{plot.title.position =} \StringTok{"plot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_ggplot_axes_theme_title_pos-1} \end{center}

Pour aller plus loin sur la conception des graphiques, je vous propose deux pistes :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  La présentation filmée de William Chase intitulée ``\href{https://rstudio.com/resources/rstudioconf-2020/the-glamour-of-graphics/}{The Glamour of Graphics}'', donnée le 30 janvier 2020 à la conférence RStudio ;
\item
  Un article intitulé ``\href{https://www.aeaweb.org/articles?id=10.1257/jep.28.1.209}{An Economist's Guide to Visualizing Data}'', rédigé par Jonathan A. Schwabish et publié dans Journal of Economic Perspectives (Schwabish \protect\hyperlink{ref-schwabish2014economist}{2014}).
\end{enumerate}

\hypertarget{graphiques_enregistrement}{%
\section{Enregistrement des graphiques}\label{graphiques_enregistrement}}

Pour enregistrer un graphique créé avec la fonction \texttt{qplot()} ou \texttt{ggplot()}, rien de plus simple : la fonction \texttt{ggsave()}. Ses arguments sont les suivants :

\begin{itemize}
\tightlist
\item
  \texttt{filename} : nom du fichier, ou chemin et nom du fichier;
\item
  \texttt{plot} : graphique à sauvegarder (par défaut, le dernier graphique, en faisant appel à la fonction \texttt{last\_plot()};
\item
  \texttt{device} : dispositif à utiliser (automatiquement extrait de l'extension du fichier indiqué à l'argument \texttt{filename});
\item
  \texttt{path} : chemin vers le fichier ;
\item
  \texttt{scale} : facteur d'échelle;
\item
  \texttt{width} : largeur (par défaut, celle de la fenêtre de graphique actuelle) ;
\item
  \texttt{height} : hauteur (par défaut, celle de la fenêtre de graphique actuelle) ;
\item
  \texttt{units} : unité pour la largeur et la longueur (\texttt{"in"}, \texttt{"cm"} ou \texttt{"mm"});
\item
  \texttt{dpi} : nombre de points par pouce, uniquement pour les images matricielles ;
\item
  \texttt{limitsize} : quand \texttt{TRUE} (la valeur par défaut), l'image sauvegardée ne dépassera pas les \(50\times 50\) in.
\end{itemize}

La fonction \texttt{ggsave()} est capable de reconnaître les extensions de fichiers suivants :\texttt{eps/ps}, \texttt{tex}, \texttt{pdf}, \texttt{jpeg}, \texttt{tiff}, \texttt{png}, \texttt{bmp}, \texttt{svg} et \texttt{wmf} (ce dernier étant valable uniquement pour Windows).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ films\_reduit, }
            \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ estimated\_budget,}
                \DataTypeTok{y =}\NormalTok{ gross\_revenue,}
                \DataTypeTok{colour =}\NormalTok{ country)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"Estimated budget"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylab}\NormalTok{(}\StringTok{"Gross Revenue"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{scale\_colour\_discrete}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Country"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{ggtitle}\NormalTok{(}\StringTok{"A small sample of movies"}\NormalTok{)}

\NormalTok{p}

\CommentTok{\# Sauvegarde dans le répertoire de travail,}
\CommentTok{\# au format pdf, le dernier graphique affiché créé via ggplot2,}
\CommentTok{\# aux dimensions égales à la fenêtre des graphiques}
\KeywordTok{ggsave}\NormalTok{(}\StringTok{"estim\_bud.pdf"}\NormalTok{)}


\CommentTok{\# En précisant plus d\textquotesingle{}arguments}
\KeywordTok{ggsave}\NormalTok{(p, }
       \DataTypeTok{file =} \StringTok{"estim\_bud.pdf"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{15}\NormalTok{, }\DataTypeTok{height =} \DecValTok{8}\NormalTok{,}
       \DataTypeTok{unit =} \StringTok{"cm"}\NormalTok{, }\DataTypeTok{scale =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{graphiques_maps}{%
\section{Cartes}\label{graphiques_maps}}

Avec \{\texttt{ggplot2}\}, il est très facile de dessiner des cartes. Il faut cependant charger quelques autres \emph{packages}. Attention, le but de cette section est de montrer des méthodes pour dessiner des cartes. Le lecteur ou la lectrie intéressé•e par les traitements des données spatiales ne trouvera pas satisfaction avec cette introduction à l'utilisation de \texttt{R} et devra plutôt consulter d'autres références (\emph{e.g.}, Bivand, Pebesma, and Gómez-Rubio (\protect\hyperlink{ref-Bivand_2008_Applied}{n.d.})).

\hypertarget{graphiques_maps_recup}{%
\subsection{Récupérer des cartes toutes faites}\label{graphiques_maps_recup}}

La première chose nécessaire à la création d'une carte, est de disposer des données pour pouvoir tracer les frontières. Dans les cas les plus simples, on peut récupérer des jeux de données présents dans des \emph{packages}.

\hypertarget{graphiques_maps_recup_rworldmap}{%
\subsubsection{\texorpdfstring{\emph{Package} \texttt{rworldmap}}{Package rworldmap}}\label{graphiques_maps_recup_rworldmap}}

La fonction \texttt{getMap()} permet d'accéder à une carte stockée dans le \emph{package}. Ensuite, on applique la fonction \texttt{fortify()}, pour transformer le \texttt{SpatialPolygonsDataFrame} qui a été retourné par la fonction \texttt{getMap()} en tableau de données, afin d'avoir un format lisible par la fonction \texttt{ggplot()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}
\KeywordTok{library}\NormalTok{(rworldmap)}

\CommentTok{\# Carte du monde}
\NormalTok{worldMap \textless{}{-}}\StringTok{ }\KeywordTok{getMap}\NormalTok{()}
\CommentTok{\# Format lisible pour ggplot()}
\NormalTok{world\_df \textless{}{-}}\StringTok{ }\KeywordTok{fortify}\NormalTok{(worldMap)}

\KeywordTok{head}\NormalTok{(world\_df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       long      lat order  hole piece          id         group
## 1 61.21082 35.65007     1 FALSE     1 Afghanistan Afghanistan.1
## 2 62.23065 35.27066     2 FALSE     1 Afghanistan Afghanistan.1
## 3 62.98466 35.40404     3 FALSE     1 Afghanistan Afghanistan.1
## 4 63.19354 35.85717     4 FALSE     1 Afghanistan Afghanistan.1
## 5 63.98290 36.00796     5 FALSE     1 Afghanistan Afghanistan.1
## 6 64.54648 36.31207     6 FALSE     1 Afghanistan Afghanistan.1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{worldmap \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ world\_df, }
               \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group =}\NormalTok{ group)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{scale\_y\_continuous}\NormalTok{(}\DataTypeTok{breaks =}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{2}\OperatorTok{:}\DecValTok{2}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{30}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{scale\_x\_continuous}\NormalTok{(}\DataTypeTok{breaks =}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{4}\OperatorTok{:}\DecValTok{4}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{45}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{coord\_equal}\NormalTok{()}

\NormalTok{worldmap}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_maps_recup_rworldmap-1} \end{center}

On peut tout à fait s'amuser avec la fonction \texttt{coord\_map()} pour changer le système de coordonnées.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{worldmap \textless{}{-}}\StringTok{ }\KeywordTok{ggplot}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ world\_df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group =}\NormalTok{ group)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{scale\_y\_continuous}\NormalTok{(}\DataTypeTok{breaks =}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{2}\OperatorTok{:}\DecValTok{2}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{30}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{scale\_x\_continuous}\NormalTok{(}\DataTypeTok{breaks =}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{4}\OperatorTok{:}\DecValTok{4}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{45}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{coord\_map}\NormalTok{(}\StringTok{"ortho"}\NormalTok{, }\DataTypeTok{orientation=}\KeywordTok{c}\NormalTok{(}\DecValTok{61}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{0}\NormalTok{))}
\NormalTok{worldmap}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_maps_2-1} \end{center}

\hypertarget{graphiques_maps_recup_maps}{%
\subsubsection{\texorpdfstring{\emph{Package} \texttt{maps}}{Package }}\label{graphiques_maps_recup_maps}}

Le \emph{package} \texttt{rworldmap} est pratique pour obtenir les frontières des pays, mais si on désire obtenir les \texttt{counties} américains, ou les départements français, il est préférable d'aller voir du côté du \emph{package} \{\texttt{maps}\}. La fonction \texttt{map\_data()} du \emph{package} \{\texttt{ggplot2}\} s'appuie sur les cartes du \emph{package} \{\texttt{maps}\} pour extraire un tableau de données prêt à être employé avec la fonction \texttt{ggplot()}. Il faut lui fournir le nom de la carte voulu, parmi les noms suivants :

\begin{itemize}
\tightlist
\item
  \texttt{county} : carte des \texttt{counties} américains ;
\item
  \texttt{france} : carte de la France;
\item
  \texttt{italy} : carte de l'Italie;
\item
  \texttt{nz} : carte de la Nouvelle-Zélande;
\item
  \texttt{state} : carte des états-Unis avec chaque état ;
\item
  \texttt{usa} : carte des états-Unis avec uniquement les frontières;
\item
  \texttt{world} : carte du monde ;
\item
  \texttt{world2} : carte du monde centrée sur le Pacifique.
\end{itemize}

Si on désire extraire uniquement certains sous-régions, il faut préciser leur nom à l'argument \texttt{region}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{map\_fr \textless{}{-}}\StringTok{ }\KeywordTok{map\_data}\NormalTok{(}\StringTok{"france"}\NormalTok{)}

\CommentTok{\# Le nom des régions}
\KeywordTok{head}\NormalTok{(}\KeywordTok{unique}\NormalTok{(map\_fr}\OperatorTok{$}\NormalTok{region))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Nord"           "Pas-de-Calais"  "Somme"          "Ardennes"      
## [5] "Seine-Maritime" "Aisne"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Carte de la France}
\NormalTok{p\_map\_fr \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ map\_fr,}
         \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group =}\NormalTok{ group, }\DataTypeTok{fill =}\NormalTok{ region)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{coord\_equal}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_fill\_discrete}\NormalTok{(}\DataTypeTok{guide =} \StringTok{"none"}\NormalTok{)}

\NormalTok{p\_map\_fr}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_maps_recup_maps-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Extrayons les données uniquement pour la Bretagne}
\NormalTok{ind\_bzh \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{str\_which}\NormalTok{(}\StringTok{"armor|finis|vilaine|morb"}\NormalTok{,}
       \DataTypeTok{pattern =} \KeywordTok{regex}\NormalTok{(}\KeywordTok{unique}\NormalTok{(map\_fr}\OperatorTok{$}\NormalTok{region), }\DataTypeTok{ignore\_case =} \OtherTok{TRUE}\NormalTok{))}

\CommentTok{\# Voici les noms des départements de la Bretagne, tels qu\textquotesingle{}ils sont}
\CommentTok{\# stockés dans le package maps}
\NormalTok{(dep\_bzh \textless{}{-}}\StringTok{ }\KeywordTok{unique}\NormalTok{(map\_fr}\OperatorTok{$}\NormalTok{region)[ind\_bzh])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Ain"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{map\_fr\_bzh \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{map\_data}\NormalTok{(}\StringTok{"france"}\NormalTok{, }\DataTypeTok{region =}\NormalTok{ dep\_bzh) }\OperatorTok{\%\textgreater{}\%}
\StringTok{  }\KeywordTok{as\_tibble}\NormalTok{()}

\CommentTok{\# Carte de la Bretagne}
\NormalTok{p\_map\_fr\_bzh \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ map\_fr\_bzh,}
         \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group =}\NormalTok{ group, }\DataTypeTok{fill =}\NormalTok{ region)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{coord\_equal}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{scale\_fill\_discrete}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Département"}\NormalTok{)}

\NormalTok{p\_map\_fr\_bzh}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_maps_recup_maps-2} \end{center}

\hypertarget{graphiques_maps_recup_shapefile}{%
\subsubsection{\texorpdfstring{Fichier \emph{shapefile}}{Fichier shapefile}}\label{graphiques_maps_recup_shapefile}}

Il est également possible d'importer un fichier \texttt{shp} et de tracer une carte basée sur son contenu. Il est cependant nécessaire de charger quelques \emph{packages} supplémentaires. Par exemple, pour tracer les quartiers de la ville de Rennes, on peut télécharger et extraire le contenu du fichier \emph{shapefile} zippé disponible sur le site : \url{http://www.data.rennes-metropole.fr}. L'importation dans \texttt{R} se fait comme suit, en ayant placé le répertoire \texttt{"quartiers\_shp\_lamb93"} que l'on vient d'extraire dans le dossier pointé par la fonction \texttt{getwd()}{[}\^{}pour plus de renseignements, voir ce GitHub : \url{https://github.com/hadley/ggplot2/wiki/plotting-polygon-shapefiles}{]}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"rgdal"}\NormalTok{)}
\KeywordTok{library}\NormalTok{(}\StringTok{"maptools"}\NormalTok{)}
\KeywordTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\KeywordTok{library}\NormalTok{(}\StringTok{"plyr"}\NormalTok{)}

\CommentTok{\# Importer les polygones}
\NormalTok{rennes \textless{}{-}}\StringTok{ }\KeywordTok{readOGR}\NormalTok{(}\DataTypeTok{dsn=}\StringTok{"./quartiers\_shp\_lamb93"}\NormalTok{, }\DataTypeTok{layer=}\StringTok{"quartiers"}\NormalTok{)}

\CommentTok{\# Étape pour changer la projection de la carte}
\NormalTok{rennes \textless{}{-}}\StringTok{ }\KeywordTok{spTransform}\NormalTok{(rennes, }\KeywordTok{CRS}\NormalTok{(}\StringTok{"+proj=longlat +ellps=GRS80"}\NormalTok{))}

\CommentTok{\# Pour permettre la jointure des objets géométriques}
\NormalTok{rennes}\OperatorTok{@}\NormalTok{data}\OperatorTok{$}\NormalTok{id \textless{}{-}}\StringTok{ }\KeywordTok{rownames}\NormalTok{(rennes}\OperatorTok{@}\NormalTok{data)}

\CommentTok{\# Transformer en data frame pour fournir à ggplot()}
\NormalTok{rennes\_points \textless{}{-}}\StringTok{ }\KeywordTok{fortify}\NormalTok{(rennes, }\DataTypeTok{region=}\StringTok{"id"}\NormalTok{)}

\CommentTok{\# Permet d\textquotesingle{}éviter des trous éventuels}
\NormalTok{rennes\_df \textless{}{-}}\StringTok{ }\KeywordTok{join}\NormalTok{(rennes\_points, rennes}\OperatorTok{@}\NormalTok{data, }\DataTypeTok{by=}\StringTok{"id"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Il ne reste plus qu'à tracer la carte.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_map\_rennes \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ rennes\_df,}
         \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group =}\NormalTok{ group)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{coord\_equal}\NormalTok{()}

\NormalTok{p\_map\_rennes}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_maps_recup_shapefile_2-1} \end{center}

\hypertarget{graphiques_maps_choroplethe}{%
\subsection{Carte choroplèthe}\label{graphiques_maps_choroplethe}}

Pour réaliser une carte choroplète, c'est-à-dire une carte où les régions sont remplies par une couleur en fonction d'une statistique, il suffit juste d'ajouter une colonne avec la valeur de la statistique dans le tableau de données permettant de dessiner la carte. Appuyons-nous sur la carte de la Bretagne définie en Section~@ref(graphiques\_maps\_recup\_maps).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tx\_chomage\_}\DecValTok{2014}\NormalTok{\_T1 \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{region =} \KeywordTok{c}\NormalTok{(}\StringTok{"Cotes{-}Darmor"}\NormalTok{,}\StringTok{"Finistere"}\NormalTok{,}
             \StringTok{"Ille{-}et{-}Vilaine"}\NormalTok{, }\StringTok{"Morbihan"}\NormalTok{),}
  \DataTypeTok{tx\_chomage\_2014\_T1 =} \KeywordTok{c}\NormalTok{(}\FloatTok{8.8}\NormalTok{, }\FloatTok{8.8}\NormalTok{,}\FloatTok{7.9}\NormalTok{, }\FloatTok{9.1}\NormalTok{))}

\CommentTok{\# Ajout des valeurs pour chaque région}
\NormalTok{map\_fr\_bzh \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{map\_fr\_bzh }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{left\_join}\NormalTok{(}
\NormalTok{    tx\_chomage\_}\DecValTok{2014}\NormalTok{\_T1}
\NormalTok{  )}


\CommentTok{\# Il suffit de faire dépendre le remplissage de tx\_chomage\_2014\_T1}
\NormalTok{p\_map\_fr\_bzh \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ map\_fr\_bzh) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom\_polygon}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group =}\NormalTok{ group,}
             \DataTypeTok{fill =}\NormalTok{ tx\_chomage\_}\DecValTok{2014}\NormalTok{\_T1)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{coord\_equal}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{scale\_fill\_gradient}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Département"}\NormalTok{, }\DataTypeTok{low =}\StringTok{"\#FFFF00"}\NormalTok{, }\DataTypeTok{high =} \StringTok{"\#FF0000"}\NormalTok{)}

\NormalTok{p\_map\_fr\_bzh}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_maps_choroplethe-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Fonction pour trouver le point central du polygone}
\NormalTok{mid\_range \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{(}\KeywordTok{range}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}

\NormalTok{centres \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{map\_fr\_bzh }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{group\_by}\NormalTok{(region) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{lat =} \KeywordTok{mid\_range}\NormalTok{(lat),}
            \DataTypeTok{long =} \KeywordTok{mid\_range}\NormalTok{(long))}


\CommentTok{\# Rajout des taux de chômage}
\NormalTok{centres \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{centres }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{left\_join}\NormalTok{(tx\_chomage\_}\DecValTok{2014}\NormalTok{\_T1) }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{label\_chomage =} \KeywordTok{str\_c}\NormalTok{(tx\_chomage\_}\DecValTok{2014}\NormalTok{\_T1, }\StringTok{"\%"}\NormalTok{))}

\NormalTok{p\_map\_fr\_bzh }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{geom\_label}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{label =}\NormalTok{ label\_chomage),}
             \DataTypeTok{data =}\NormalTok{ centres)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_maps_choroplethe_2-1} \end{center}

\hypertarget{graphiques_3d}{%
\section{Graphiques en 3D}\label{graphiques_3d}}

Le \emph{package} \{\texttt{ggplot2}\} ne permet malheureusement pas (encore) de réaliser des graphiques en 3D. Il faut aller regarder du côté des \emph{packages} \{\texttt{base}\}, \{\texttt{lattice}\} ou encore \{\texttt{rgl}\} pour cela. Le lecteur ou la lectrice intéressé•e par ces options offertes par \texttt{R} est invité•e à consulter les pages d'aide des fonctions, à parcourir les vignettes et les démos.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(MASS)}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{\# Normale bivariée}
\NormalTok{Sigma \textless{}{-}}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{),}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\NormalTok{biv\_n \textless{}{-}}\StringTok{ }\KeywordTok{mvrnorm}\NormalTok{(}\DataTypeTok{n=}\DecValTok{1000}\NormalTok{, }\KeywordTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{), Sigma)}

\CommentTok{\# Estimation par la méthode du noyau de la densité}
\NormalTok{biv\_n\_kde \textless{}{-}}\StringTok{ }\KeywordTok{kde2d}\NormalTok{(biv\_n[,}\DecValTok{1}\NormalTok{], biv\_n[,}\DecValTok{2}\NormalTok{], }\DataTypeTok{n =} \DecValTok{50}\NormalTok{)}

\KeywordTok{persp}\NormalTok{(biv\_n\_kde, }\DataTypeTok{theta =} \DecValTok{10}\NormalTok{, }\DataTypeTok{phi =} \DecValTok{15}\NormalTok{, }\DataTypeTok{xlab =} \StringTok{"X"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/graphiques_3d_persp-1} \end{center}

Une autre fonction, peut-être plus pratique pour visualiser des graphiques en 3d, puisqu'on peut se servir de la souris pour changer d'angle, est \texttt{plot3d()}, du \emph{package} \{\texttt{rgl}\}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rgl)}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{n \textless{}{-}}\StringTok{ }\DecValTok{10000}
\NormalTok{x \textless{}{-}}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(n, }\DataTypeTok{mean =} \DecValTok{38}\NormalTok{)}
\NormalTok{y \textless{}{-}}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(n, }\DataTypeTok{mean =} \DecValTok{42}\NormalTok{)}

\NormalTok{biv\_kde \textless{}{-}}\StringTok{ }\KeywordTok{kde2d}\NormalTok{(x, y, }\DataTypeTok{n =} \DecValTok{50}\NormalTok{)}
\NormalTok{den\_z \textless{}{-}}\StringTok{ }\NormalTok{biv\_kde}\OperatorTok{$}\NormalTok{z}

\KeywordTok{surface3d}\NormalTok{(biv\_kde}\OperatorTok{$}\NormalTok{x,biv\_kde}\OperatorTok{$}\NormalTok{y,den\_z}\OperatorTok{*}\DecValTok{20}\NormalTok{,}\DataTypeTok{color=}\StringTok{"\#FF2222"}\NormalTok{,}\DataTypeTok{alpha=}\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pour les personnes intéressées, l'exécution des lignes ci-après donne un aperçu plus large de ce qu'il est possible de faire avec le \emph{package} \{\texttt{rgl}\}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{demo}\NormalTok{(rgl)}
\KeywordTok{example}\NormalTok{(rgl)}
\end{Highlighting}
\end{Shaded}

\hypertarget{graphiques_exercices}{%
\section{Exercices}\label{graphiques_exercices}}

\begin{exframe}
\textbf{Exercice 1 : créer un graphique simple, modifier son aspect}
1. Charger le \emph{package} \{\texttt{ggplot2}\}, et utiliser la fonction \texttt{data()} pour charger en mémoire le jeu de données \texttt{economics}. Consulter la page d'aide de ce jeu de données pour prendre connaissance de son contenu ;
2. À l'aide de la fonction \texttt{ggplot()}, représenter les dépenses personnelles de consommation (\texttt{pce}) en fonction de la date (\texttt{date}). Les observations doivent être connectées par une ligne.
3. Modifier le graphique de la question précédente de manière à ce que la couleur de la ligne soit \texttt{dodger\ blue} et définir la taille de la ligne à \texttt{0.5}. Stocker le résultat dans un objet que l'on appellera \texttt{p\_1} ;
4. Ajouter une couche au graphique \texttt{p\_1} pour modifier les titres des axes (les retirer), et définir le titre suivant : ``Personal Consumption Expenditures (billions dollars)''.
5. Utiliser la fonction \texttt{date\_breaks()} du \emph{package} \{\texttt{scales}\} pour modifier l'échelle des abscisses de \texttt{p\_1}, afin que les étiquettes des marques soient affichées tous les 5 ans ; à l'aide de la fonction \texttt{date\_format()}, modifier le format de ces étiquettes pour que seule l'année des dates s'affiche.
\end{exframe}

\begin{exframe}
\textbf{Exercice 2 : créer un graphique avec plusieurs courbes, modifier son aspect}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Charger le \emph{package} \{\texttt{ggplot2}\}, et utiliser la fonction \texttt{data()} pour charger en mémoire le jeu de données \texttt{economics}. Consulter la page d'aide de ce jeu de données pour prendre connaissance de son contenu ;
\item
  Charger le \emph{package} \{\texttt{\}tidyverse}\}. Sélectionner les variables \texttt{date}, \texttt{psavert} et \texttt{uempmed} dans le tableau de données \texttt{economics} et utiliser la fonction \texttt{pivot\_longer()} sur le résultat pour obtenir un tableau dans lequel chaque ligne indiquera la valeur (\texttt{value}) pour une variable donnée (\texttt{key}) à une date donnée (\texttt{date}). Stocker le résultat dans un objet que l'on appellera \texttt{df} ;
\item
  Sur un même graphique, représenter à l'aide de lignes, l'évolution dans le temps du taux d'épargne personnelle (\texttt{psavert}) et de la durée médiane en semaines du chômage (\texttt{uempmed}). Stocker le graphique dans un objet que l'on appellera \texttt{p\_2} ;
\item
  Modifier le code ayant servi à construire le graphique \texttt{p\_2} pour que le type de ligne soit différent pour chacune des deux séries représentées. Les deux lignes doivent être tracées en bleu. Stocker le graphique dans un objet que l'on appellera \texttt{p\_3} ;
\item
  À présent, modifier le code ayant servi à construire \texttt{p\_3} pour qu'à la fois la couleur et le type de ligne servent à différencier les deux séries. Stocker le graphique dans un objet que l'on appellera \texttt{p\_4} ;
\item
  Modifier le graphique \texttt{p\_4} en ajoutant une couche d'échelle de couleur pour que le taux d'épargne personnelle (\texttt{psavert}) soit représenté en \texttt{dodger\ blue}, et que la durée de chômage (\texttt{uempmed}) soit représentée en rouge. Par ailleurs, retirer le titre de la légende ;
\item
  Modifier le graphique \texttt{p\_4} en ajoutant une couche d'échelle de type de ligne pour que le taux d'épargne personnelle (\texttt{psavert}) soit représenté par des tirets, et que la durée de chômage (\texttt{uempmed}) soit représentée par une ligne pleine. Par ailleurs, retirer le titre de la légende des types de lignes, afin que les légendes de couleur et de type de ligne soient fusionnées ;
\item
  Créer le tableaux de données \texttt{df\_2}, une copie de \texttt{df}, dans lequel la variable \texttt{key} doit être un facteur dont les niveaux sont \texttt{uempmed} et \texttt{psavert} ;
\item
  Créer le vecteur \texttt{etiq} suivant :

  \texttt{etiq\ \textless{}-\ c("psavert"\ =\ "Pers.\ Saving\ Rate",}
  \texttt{"uempmed"\ =\ "Median\ Duration\ of\ Unemployment\ (weeks)")}

  Ce vecteur contient des valeurs d'étiquettes pour la légende du graphique qu'il va falloir créer.

  Représenter sur un même graphique lévolution dans le temps du taux d'épargne personnelle et de la durée médiane du chômage en semaines, en s'appuyant sur les données contenues dans le tableau \texttt{df\_2}. La courbe du taux d'épargne personnelle doit être composée de tirets et être de couleur \texttt{dodger\ blue} ; la courbe de la durée médiane du taux de chômage doit être une ligne rouge. La légende ne doit pas comporter de titre, et ses étiquettes doivent être modifiées pour que ``Pers. Saving Rate'' s'affiche à la place de ``psavert'', et pour que ``Median Duration of Unemployment (weeks)'' s'affiche à la place de ``uempmed''. Stocker le graphique dans un objet que l'on appellera \texttt{p\_5} ;

  \emph{Note : il s'agit de reprendre le code ayant servi à créer le graphique \texttt{p\_4}, en modifiant légèrement les échelles de couleur et de ligne pour prendre en compte les étiquettes proposées dans le vecteur \texttt{etiq}.}
\item
  Modifier \texttt{p\_5} pour lui ajouter une couche permettant de déplacer la légende en bas du graphique (utiliser la fonction \texttt{theme()}) ;
\item
  Ajouter une couche au graphique \texttt{p\_5} qui permet de définir un thème. Utiliser le thème minimal (`theme\_minimal()). Que se passe-t-il pour la légende ? Repositionner la légende en dessous, et retirer les titres des axes ;
\item
  Sauvegarder le graphique \texttt{p\_5} au format PDF en précisant une largeur de 12 et une hauteur de 8.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 3 : différentes représentations graphiques}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Charger le jeu de données \texttt{mpg} contenu dans le \emph{package} \{\texttt{ggplot2}\} en mémoire, puis consulter la page d'aide du jeu de données pour en prendre connaissance ;
\item
  Représenter à l'aide d'un nuage de points la relation entre la consommation sur autoroute des véhicules de l'échantillon (\texttt{hwy}) et la cylindrée de leur moteur (\texttt{displ})
\item
  Reprendre le code du graphique précédent et modifier la forme des points pour les changer en symbole \texttt{+} ; modifier la couleur des \texttt{+} de manière à la faire dépendre du nombre de cylindres (\texttt{cyl}) ;
\item
  À présent, représenter par des boîtes à moustaches la distribution de la consommation sur autoroute des véhicules (\texttt{hwy}) pour chacune des valeurs possibles du nombre de cylindres (\texttt{cyl}) ;
\item
  Charger le jeu de données \texttt{economics} contenu dans le \emph{package} \{\texttt{ggplot2}\} en mémoire, puis consulter la page d'aide du jeu de données pour en prendre connaissance. Ensuite, ajouter au tableau (les créer) les variables \texttt{u\_rate} et \texttt{e\_rate}, respectivement le taux de chômage et le taux d'emploi (on définira le taux de chômage de manière très grossière ici : nombre de personnes non employées sur la population totale) ;
\item
  Représenter à l'aide de barres l'évolution dans le temps du taux de chômage, et remplir les barres avec la couleur rouge ;
\item
  Reprendre le code du graphique précédent et ajouter une couche permettant de modifier les limites de l'axe des abscisses pour afficher les valeurs uniquement sur la période ``2012-01-01'' à ``2015-01-01'' (utiliser la fonction \texttt{coord\_cartesian()}). Stocker le graphique dans un objet que l'on appellera \texttt{p} ;
\item
  Dans le tableau de données \texttt{economics}, sélectionner les variables \texttt{date}, \texttt{u\_rate} et \texttt{e\_rate}, puis utiliser la fonction \texttt{pivot\_longer()} pour obtenir un tableau dans lequel chaque ligne correspond à la valeur d'une des variables (taux de chômage ou taux d'emploi) à une date donnée. Stocker le résultat dans un objet que l'on appellera \texttt{df\_3} ;
\item
  Utiliser le tableau de données \texttt{df\_3} pour représenter graphiquement à l'aide de barres les taux de chômage et taux d'emploi par mois sur la période ``2012-01-01'' à ``2015-01-01''. Sur le graphique, les barres représentant le taux de chômage et celles représentant le taux d'emploi devront être superposées.

  \emph{Note : il s'agit de modifier légèrement le code ayant permis de réaliser le graphique \texttt{p}.}
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 4 : facettes}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Charger le \emph{package} \{\texttt{WDI}\} (l'installer si nécessaire), puis en utilisant la fonction \texttt{WDI()}, récupérer les données de PIB par tête (\texttt{NY.GDP.PCAP.PP.KD}, PPP, constant 2005 international \$) et de taux de chômage (\texttt{SL.UEM.TOTL.ZS}, total, \% of total labor force) pour la France, l'Allemagne et le Royaume Uni, pour la période allant de 1990 à 2015. Ces données doivent être stockées dans un tableau que l'on appellera \texttt{df} ;
\item
  Transformer le tableau \texttt{df} afin que chaque ligne indique : l'état (\texttt{country}), l'année (\texttt{year}), le nom de la variable (\texttt{variable}) et la valeur (\texttt{valeur}) (utiliser la fonction \texttt{pivot\_longer()}). Puis, modifier la colonne \texttt{variable} afin qu'elle soit de type \texttt{factor}, et que les étiquettes des niveaux \texttt{NY.GDP.PCAP.PP.KD} et \texttt{SL.UEM.TOTL.ZS} deviennent \texttt{GDP} et \texttt{Unemployment} respectivement ;
\item
  Représenter graphiquement l'évolution du PIB et du taux de chômage pour les trois pays. Utiliser la fonction \texttt{facet\_wrap()} afin de regrouper les variables par type : les observations des valeurs du PIB d'un côté du ``tableau'' de graphiques, et celles du taux de chômage de l'autre. Utiliser une représentation en ligne, en faisant dépendre la couleur du pays ;
\item
  Reprendre le code du graphique précédent en le modifiant légèrement afin de libérer les axes des ordonnées ;
\item
  Modifier les arguments esthétiques du graphique afin de faire dépendre le type de ligne des pays de la manière suivante : des points pour la France, des tirets pour l'Allemagne, des tirets longs pour le Royaume Uni. Définir l'épaisseur des lignes à \(1.5\) ;
\item
  Modifier légèrement le code ayant permis de réaliser le graphique de la question précédente pour que la direction ne soit non plus horizontale (par défaut), mais verticale (argument \texttt{dir}, ou à défaut, \texttt{ncol} dans ce cas précis) ;
\item
  En utilisant la fonction \texttt{facet\_wrap()}, créer une grille de graphiques, de sorte que chaque pannel représente l'évolution d'une seule série pour un pays donné ;
\item
  À présent, utiliser la fonction \texttt{facet\_grid()} pour créer une grille de graphiques dans laquelle les lignes correspondent aux pays et les colonnes aux variables. Prendre soin de libérer les échelles ;
\item
  Reprendre la question précédente en faisant cette fois une girlle dans laquelle les lignes correspondent aux variables et les colonnes aux pays.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 5 : annotations}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  En utilisant la fonction \texttt{WDI()} du \emph{package} \texttt{WDI}, récupérer les séries de 2010 du PIB par tête (\texttt{NY.GDP.PCAP.PP.KD}, PPP, constant 2005 international \$) et de l'espérance de vie à la naissance (\texttt{SP.DYN.LE00.IN}, total, years) pour tous les pays. Les données seront stockées dans un tableau que l'on nommera \texttt{df} ;
\item
  Représenter par un nuage de points l'espérance de vie à la naissance en fonction du PIB par tête. Retirer les titres des axes, et ajouter le titre suivant (sur deux lignes) : ``Life Expectancy at birth (years) VS Real GDP per Capita (PPP, contant 2005 international \$'' ;
\item
  Ajouter une courbe de tendance obtenue par lissage Loess (en utilisant une fonction du \emph{package} \{\texttt{ggplot2}\}) ;
\item
  Modifier le tableau \texttt{df} pour lui ajouter la variable \texttt{drapeau} qui prendra la valeur \texttt{TRUE} si l'état de l'observation est soit \texttt{France}, soit \texttt{Luxembourg}, et \texttt{FAUX} sinon ;
\item
  Modifier légèrement le code ayant permis de réaliser le précédent graphique, pour faire dépendre la couleur des points de la variable drapeau (rouge pour \texttt{TRUE} et noir pour \texttt{FALSE}) ;
\item
  Créer un tableau de données que l'on appellera \texttt{df\_fleche} qui contient les observations du tableau \texttt{df} pour la France et le Luxembourg uniquement ;
\item
  Reprendre le code du graphique précédent pour le modifier de façon à ajouter deux flèches : l'une montrant le points de la France et l'autre du Luxembourg. Le nom du pays devra être inscrit à l'origine des deux flèches (utiliser la fonction \texttt{annotate()} et se servir du tableau de données \texttt{df\_fleche}).
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 6 : annotations}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  À l'aide de la fonction \texttt{WDI} du \emph{package} \{\texttt{WDI}\}, récupérer la série de l'inflation (\texttt{FP.CPI.TOTL.ZG}, consumer prices, annual \%) en France sur la période 1960--2015, et stocker ces données dans un tableau que l'on appellera \texttt{inflation\_fr} ;
\item
  Représenter par une ligne l'évolution du taux annuel d'inflation en France sur la période 1960--2015. Retirer les titres d'axes et ajouter le titre suivant : ``Inflation in France (annual \%)'' ;
\item
  Soient les deux vecteurs suivants, qui définissent les dates de début et fin de la période inflationniste et celle de grande modération :
\end{enumerate}
\end{exframe}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{per\_}\DecValTok{1}\NormalTok{ =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1970}\NormalTok{, }\DecValTok{1976}\NormalTok{) }\CommentTok{\# Periode inflationniste}
\NormalTok{per\_}\DecValTok{2}\NormalTok{ =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1976}\NormalTok{, }\DecValTok{1991}\NormalTok{) }\CommentTok{\# Periode de grande moderation}
\end{Highlighting}
\end{Shaded}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Reprendre le code du graphique précédent et ajouter deux rectangles : un premier, rouge, pour mettre en valeur la période inflationniste et un second, bleu, mettant en valeur la période de grande modération. Modifier l'argument de transparence pour le fixer à 0.2 ;
\item
  Ajouter au graphique précédent des lignes grises verticales en tirets pour les années 1973, 1979 et 2008. Modifier également les \texttt{breaks} de l'échelle des abscisses à l'aide de la fonction \texttt{pretty\_breaks()} du \emph{package} scales.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 7 : carte simple}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  À l'aide de la fonction \texttt{WDI()} du \emph{package} \{\texttt{WDI}\}, récupérer la série fournie par la Banque Mondiale du PIB par tête (\texttt{NY.GDP.PCAP.PP.KD}, PPP, constant 2005 international \$) pour tous les pays disponibles pour l'année 2010, et stocker ces données dans un tableau que l'on appellera \texttt{gdp\_capita} ;
\item
  Dans le tableau \texttt{gdp\_capita}, modifier la valeur de la variable \texttt{country} pour l'observation de la Slovaquie, pour qu'elle vaille \texttt{Slovakia} au lieu de \texttt{Slovak\ Republic} ;
\item
  Filtrer les observations du tableau \texttt{gdp\_capita} pour ne conserver que les observations des pays membres de l'Union Européenne dont les noms sont contenus dans le vecteur \texttt{membres\_ue}. Stocker le résultat dans un tableau que l'on nommera \texttt{gdp\_capita\_eu} ;
\end{enumerate}
\end{exframe}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{membres\_ue \textless{}{-}}\KeywordTok{c}\NormalTok{(}\StringTok{"Austria"}\NormalTok{, }\StringTok{"Belgium"}\NormalTok{, }\StringTok{"Bulgaria"}\NormalTok{, }\StringTok{"Cyprus"}\NormalTok{, }\StringTok{"Croatia"}\NormalTok{,}
              \StringTok{"Czech Republic"}\NormalTok{, }\StringTok{"Denmark"}\NormalTok{, }\StringTok{"Estonia"}\NormalTok{, }\StringTok{"Finland"}\NormalTok{, }\StringTok{"France"}\NormalTok{,}
              \StringTok{"Germany"}\NormalTok{, }\StringTok{"Greece"}\NormalTok{, }\StringTok{"Hungary"}\NormalTok{, }\StringTok{"Ireland"}\NormalTok{, }\StringTok{"Italy"}\NormalTok{, }\StringTok{"Latvia"}\NormalTok{,}
              \StringTok{"Lithuania"}\NormalTok{, }\StringTok{"Luxembourg"}\NormalTok{, }\StringTok{"Malta"}\NormalTok{, }\StringTok{"Netherlands"}\NormalTok{, }\StringTok{"Poland"}\NormalTok{,}
              \StringTok{"Portugal"}\NormalTok{, }\StringTok{"Romania"}\NormalTok{, }\StringTok{"Slovakia"}\NormalTok{, }\StringTok{"Slovenia"}\NormalTok{, }\StringTok{"Spain"}\NormalTok{,}
              \StringTok{"Sweden"}\NormalTok{, }\StringTok{"United Kingdom"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Utiliser le \emph{package} \{\texttt{rworldmap}\} pour récupérer les données nécessaires à la réalisation d'une carte du monde ;
\item
  Afficher une carte du monde à l'aide des fonctions contenues dans le \emph{package} \{\texttt{ggplot2}\} ;
\item
  Modifier les échelles des axes pour faire figurer les méridiens de \(-60\) à \(60\) par pas de 30 et les parallèles de \(-180\) à \(180\) par pas de 45. Modifier également la projection cartographique pour choisir la projection orthographique, à l'aide de la fonction \texttt{coord\_map()} ;
\item
  Joindre les informations contenues dans le tableau \texttt{gdp\_capita\_eu} au tableau contenant les données permettant la réalisation des cartes ;
\item
  Réaliser une carte choroplèthe reflétant pour chaque pays membre de l'Union Européenne la valeur du PIB par tête de 2012 ;
\item
  Modifier les couleurs de l'échelle continue de la carte précédente, pour que les faibles valeurs du PIB par tête soient représentées en jaune, et les valeurs les plus hautes en rouge ;
\item
  Modifier les ruptures de l'échelle de couleur pour qu'elles aillent de \(10000\) à \(100000\) ; modifier également l'étiquette de ces ruptures de sorte que \(35000\) soit affiché comme \(35\)k, \(60000\) comme \(60\)k, etc. Enfin, ajouter un titre au graphique et retirer les titres d'axes.
\end{enumerate}
\end{exframe}

\hypertarget{ruxe9gressions-linuxe9aires}{%
\chapter{Régressions linéaires}\label{ruxe9gressions-linuxe9aires}}

\hypertarget{rappels}{%
\section{Rappels}\label{rappels}}

On souhaite étudier la liaison entre une variable \(y\) et une ou plusieurs variables \(x_1, x_2, \ldots, x_m\). La variable \(y\) est appelée \emph{variable à expliquer}, ou \emph{réponse} (ou encore \emph{target}) et les variables \(x_j\), \(j = 1, 2, \ldots, m\) sont appelées variables explicatives (\emph{features}). On suppose que la relation entre la variable à expliquer et les variables explicatives est de la forme \(y = f(x_1, x_2, \ldots, x_m)\), avec \(m\) le nombre de variables explicatives. On émet l'hypothèse que la réponse est linéairement indépendante des variables \(x_j\), avec \(j = 1, \ldots, m\).

Il s'agit d'estimer les coefficients \(\beta_j\) de l'équation à \(m\) variables explicatives \(x_j\), avec \(j=1,2,\cdots, m\), \(\beta_0\) étant la constante, et \(\varepsilon\) un terme d'erreur supposé normal :
\begin{equation}
\boldsymbol y = \beta_0 + \beta_1 \boldsymbol x_1 + \beta_2 \boldsymbol x_2 + \cdots + \beta_j \boldsymbol x_j + \cdots + \beta_m \boldsymbol x_m  + \boldsymbol \varepsilon.\label{eq:chap_5_reg_mult}
\end{equation}

Soit, en termes matriciels
\begin{equation}
  \boldsymbol y = \boldsymbol X \boldsymbol \beta + \boldsymbol \varepsilon,\label{eq:chap_5_reg_mult_mat}
\end{equation}
\begin{align*}
  \textrm{où } \boldsymbol y = \begin{bmatrix}
        y_1 \\ y_2 \\ \vdots \\ y_n
    \end{bmatrix}, \, \boldsymbol X = \begin{bmatrix}
      1 & x_{11} & x_{12} & \cdots & x_{1m} \\
      1 & x_{21} & x_{22} & \cdots & x_{2m} \\
      1 & \vdots  & \vdots  & \ddots & \vdots \\
      1 & x_{n1} & x_{n2} & \cdots & x_{nm}
 \end{bmatrix}, \, \boldsymbol \beta =  \begin{bmatrix}
    \beta_0\\
    \beta_1\\
  \beta_2\\
    \vdots\\
    \beta_m
 \end{bmatrix} \textrm{ et } \boldsymbol \varepsilon = \begin{bmatrix}
   \varepsilon_1\\
   \varepsilon_2\\
    \vdots\\
    \varepsilon_m
 \end{bmatrix}.
\end{align*}

Les coefficients \(\beta_j\) sont inconnus et estimés par \(\hat{\beta}_j\) tels que :
\begin{align*}
  \begin{cases}
    \hat{y_1} &  = \hat{\beta}_{0} +\hat{\beta}_1 x_{11} + \hat{\beta}_2 x_{12} + \cdots + \hat{\beta}_j x_{1j} + \hat{\beta}_m x_{1m}\\
        \hat{y_2} &  = \hat{\beta}_{0} + \hat{\beta}_1 x_{21} + \hat{\beta}_2 x_{22} + \cdots + \hat{\beta}_j x_{2j} + \hat{\beta}_m x_{2m}\\
        \vdots & = \vdots\\
        \hat{y_n} &  = \hat{\beta}_{0} + \hat{\beta}_1 x_{n1} + \hat{\beta}_2 x_{n2} + \cdots + \hat{\beta}_j x_{nj} + \hat{\beta}_m x_{nm}\\
    \end{cases}.
\end{align*}

En termes matriciels, cela donne :
\begin{equation}
  \hat{\boldsymbol y} = \boldsymbol X \hat{\boldsymbol \beta},\label{eq:chap_5_reg_mult_mat_1}
\end{equation}
\begin{align*}
    \textrm{où } \hat{\boldsymbol y} = \begin{bmatrix}
        \hat{y}_1 \\ \hat{y}_2 \\ \vdots \\ \hat{y}_n
    \end{bmatrix}, \, \boldsymbol X = \begin{bmatrix}
      1 & x_{11} & x_{12} & \cdots & x_{1m} \\
      1 & x_{21} & x_{22} & \cdots & x_{2m} \\
      1 & \vdots  & \vdots  & \ddots & \vdots \\
      1 & x_{n1} & x_{n2} & \cdots & x_{nm}
 \end{bmatrix}, \textrm{ et } \hat{\boldsymbol \beta} =  \begin{bmatrix}
  \hat{\beta}_0\\
    \hat{\beta}_1\\
    \hat{\beta}_2\\
    \vdots\\
    \hat{\beta}_m
 \end{bmatrix}.
\end{align*}

Avec la méthode des moindres carrés, l'objectif est de trouver \(\hat{\boldsymbol\beta}\) tels que la somme des carrés des résidus soit minimale. La somme des carrés des résidus est définie par :
\[\mid \mid \boldsymbol y - \boldsymbol X \boldsymbol \beta \mid \mid^2 = \sum_{i=1}^{n} (y_i - x_i \beta)^2.\]

La condition du premier ordre donne\footnote{On utilise les propriétés suivantes : \(\frac{\partial \boldsymbol x^t \boldsymbol A}{\partial \boldsymbol x} = \boldsymbol A^t\), \(\frac{\partial \boldsymbol A \boldsymbol x}{\partial \boldsymbol x} = \boldsymbol A\) et \(\frac{\partial a \boldsymbol \varepsilon}{\partial \boldsymbol x} = a \frac{\partial u}{\partial \boldsymbol x}\), avec \(u = u(\boldsymbol x)\).} :

\begin{empheq}{align}
& \boldsymbol X^t \boldsymbol X\hat{\boldsymbol \beta} - 2 \boldsymbol X^t \boldsymbol X \hat{\boldsymbol \beta} - 2 \boldsymbol X^t \boldsymbol y = 0\notag\\
  \Leftrightarrow \quad & \boldsymbol X^t \boldsymbol X \hat{\boldsymbol\beta} = \boldsymbol X^t \boldsymbol y\notag\\
    \Leftrightarrow \quad & \hat{\boldsymbol\beta} = (\boldsymbol X^t \boldsymbol X)^{-1} \boldsymbol X^t \boldsymbol y.\label{eq:chap_5_betachap}
\end{empheq}

\hypertarget{regressions_donnees}{%
\section{Données de l'exemple}\label{regressions_donnees}}

Nous allons nous appuyer sur des données de naissances à Philadelphie, en 1990 (Elo, Rodgriguez, and Lee \protect\hyperlink{ref-Elo_2001_Racial}{2001}). L'échantillon concerne \(5\%\) des naissances ayant eu lieu dans cette ville en 1990, ce qui représente \(1115\) observations. Chaque enregistrement renseigne sur :

\begin{itemize}
\tightlist
\item
  \texttt{grams} : masse à la naissance (grammes) ;
\item
  \texttt{gestate} : temps de gestation (semaines) ;
\item
  \texttt{educ} : nombre d'années d'éducation de la mère (0--17);
\item
  \texttt{black} : variable indicatrice de la couleur de peau de la mère (1 si oui, 0 sinon);
\item
  \texttt{smoke}indique si la mère a fumé pendant la grossesse (1 si oui, 0 sinon).
\end{itemize}

Attention, ce qui est proposé dans cette section ne constitue pas un fil d'Ariane pour réaliser une analyse sur des données. L'idée est de montrer au lecteur les fonctions principales, pour que ce premier puisse réaliser par lui-même ses analyses. D'excellentes références proposent d'aller plus loin au sujet de la régression (Matzner-Løber \protect\hyperlink{ref-Matzner_2007_Regression}{2007}, @Lafaye\_2011\_Logiciel, @Dalgaard\_2008\_Introductory).

Une très rapide visualisation des données est l'occasion d'introduire ici la fonction \texttt{grid.arrange()} du \emph{package} \{\texttt{gridExtra}\}, qui permet de positionner des graphiques réalisés avec \{\texttt{ggplot2}\} sur une grille.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url \textless{}{-}}\StringTok{ "http://data.princeton.edu/wws509/datasets/phbirths.dat"}
\NormalTok{births \textless{}{-}}\StringTok{ }\KeywordTok{read.table}\NormalTok{(url, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{head}\NormalTok{(births)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   black educ smoke gestate grams
## 1 FALSE    0  TRUE      40  2898
## 2  TRUE    0  TRUE      26   994
## 3 FALSE    2 FALSE      38  3977
## 4 FALSE    2  TRUE      37  3040
## 5 FALSE    2 FALSE      38  3523
## 6 FALSE    5  TRUE      40  3100
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Un aperçu des données}
\KeywordTok{summary}\NormalTok{(births)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    black              educ         smoke            gestate          grams     
##  Mode :logical   Min.   : 0.00   Mode :logical   Min.   :20.00   Min.   : 284  
##  FALSE:453       1st Qu.:11.00   FALSE:846       1st Qu.:38.00   1st Qu.:2900  
##  TRUE :662       Median :12.00   TRUE :269       Median :39.00   Median :3267  
##                  Mean   :12.27                   Mean   :38.84   Mean   :3220  
##                  3rd Qu.:13.00                   3rd Qu.:40.00   3rd Qu.:3630  
##                  Max.   :17.00                   Max.   :43.00   Max.   :4830
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Les corrélations}
\KeywordTok{round}\NormalTok{(}\KeywordTok{cor}\NormalTok{(births), }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##         black  educ smoke gestate grams
## black    1.00 -0.15  0.05   -0.17 -0.26
## educ    -0.15  1.00 -0.23    0.06  0.12
## smoke    0.05 -0.23  1.00   -0.15 -0.23
## gestate -0.17  0.06 -0.15    1.00  0.70
## grams   -0.26  0.12 -0.23    0.70  1.00
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Un aperçu graphique des données}
\KeywordTok{library}\NormalTok{(ggplot2)}
\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, grams, }\DataTypeTok{fill =} \KeywordTok{I}\NormalTok{(}\StringTok{"dodger blue"}\NormalTok{))}
\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, gestate, }\DataTypeTok{fill =} \KeywordTok{I}\NormalTok{(}\StringTok{"dodger blue"}\NormalTok{))}
\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, educ, }\DataTypeTok{fill =} \KeywordTok{I}\NormalTok{(}\StringTok{"dodger blue"}\NormalTok{))}
\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, black, }\DataTypeTok{fill =} \KeywordTok{I}\NormalTok{(}\StringTok{"dodger blue"}\NormalTok{))}
\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, smoke, }\DataTypeTok{fill =} \KeywordTok{I}\NormalTok{(}\StringTok{"dodger blue"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/regressions_estimation_graphiques-1} \includegraphics{_main_files/figure-latex/regressions_estimation_graphiques-2} \includegraphics{_main_files/figure-latex/regressions_estimation_graphiques-3} \includegraphics{_main_files/figure-latex/regressions_estimation_graphiques-4} \includegraphics{_main_files/figure-latex/regressions_estimation_graphiques-5} \end{center}

Si on souhaite regarder les différentes valeurs que prennent chaque variable pour chaque observation, on peut utiliser la petite astuce consistant à utiliser la fonction \texttt{seq\_along()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Pour avoir des nuages de points}
\NormalTok{p\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, }\KeywordTok{seq\_along}\NormalTok{(grams), grams) }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"Index"}\NormalTok{)}
\NormalTok{p\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, }\KeywordTok{seq\_along}\NormalTok{(gestate), gestate) }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"Index"}\NormalTok{)}
\NormalTok{p\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, }\KeywordTok{seq\_along}\NormalTok{(educ), educ) }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"Index"}\NormalTok{)}

\KeywordTok{library}\NormalTok{(gridExtra)}
\KeywordTok{grid.arrange}\NormalTok{(p\_}\DecValTok{1}\NormalTok{, p\_}\DecValTok{2}\NormalTok{, p\_}\DecValTok{3}\NormalTok{, }\DataTypeTok{ncol=}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/regressions_estimation_graphiques_2-1} \end{center}

Pour avoir une idée de la relation possible entre la réponse et chaque variable explicative, il est intéressant de tracer les graphiques suivants.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p\_}\DecValTok{1}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, grams, gestate,}
             \DataTypeTok{geom =} \KeywordTok{c}\NormalTok{(}\StringTok{"point"}\NormalTok{, }\StringTok{"smooth"}\NormalTok{))}
\NormalTok{p\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, educ, gestate, }
             \DataTypeTok{geom =} \KeywordTok{c}\NormalTok{(}\StringTok{"point"}\NormalTok{, }\StringTok{"smooth"}\NormalTok{))}
\NormalTok{p\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, black, gestate, }\DataTypeTok{position =} \StringTok{"jitter"}\NormalTok{)}
\NormalTok{p\_}\DecValTok{4}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{qplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ births, smoke, gestate, }\DataTypeTok{position =} \StringTok{"jitter"}\NormalTok{)}
\KeywordTok{grid.arrange}\NormalTok{(p\_}\DecValTok{1}\NormalTok{, p\_}\DecValTok{2}\NormalTok{, p\_}\DecValTok{3}\NormalTok{, p\_}\DecValTok{4}\NormalTok{, }\DataTypeTok{ncol=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/regressions_estimation_graphiques_3-1} \end{center}

\hypertarget{estimation-des-paramuxe8tres}{%
\section{Estimation des paramètres \{\#\}}\label{estimation-des-paramuxe8tres}}

La fonction permettant de réaliser une régression linéaire avec \texttt{R} se nomme \texttt{lm()}. Il est nécessaire de fournir une formule à l'arguemnt \texttt{formula}. L'argument \texttt{data} indique le tableau de données (la liste, ou un objet convertible en \texttt{data.frame}) dans lequel les variables mentionnées dans la formule se trouvent.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reg \textless{}{-}}\StringTok{ }\KeywordTok{lm}\NormalTok{(grams }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{gestate, }\DataTypeTok{data =}\NormalTok{ births)}
\NormalTok{reg}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Call:
## lm(formula = grams ~ gestate, data = births)
## 
## Coefficients:
## (Intercept)      gestate  
##     -3245.4        166.4
\end{lstlisting}

On lit dans la sortie que le coefficient de la constante vaut -3245.446394 et que le coefficient associé à la variable \texttt{gestate} vaut 166.4462854.

Comme on peut le voir sur les graphiques proposés précédemment, la relation entre la masse du nouveau né et le temps de gestation semble plus quadratique que linéaire. Pour introduire le carré de la durée de gestation, on utilise la fonction \texttt{I()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reg\_}\DecValTok{2}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{lm}\NormalTok{(grams }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{gestate }\OperatorTok{+}\StringTok{ }\KeywordTok{I}\NormalTok{(gestate}\OperatorTok{\^{}}\DecValTok{2}\NormalTok{), }\DataTypeTok{data =}\NormalTok{ births)}
\NormalTok{reg\_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Call:
## lm(formula = grams ~ gestate + I(gestate^2), data = births)
## 
## Coefficients:
##  (Intercept)       gestate  I(gestate^2)  
##    -4545.933       243.159        -1.108
\end{lstlisting}

\hypertarget{regressions_lecture}{%
\section{Lecture des sorties}\label{regressions_lecture}}

Une des fonctions les plus utiles autour de la régression linéaire avec \texttt{R}\textasciitilde est \texttt{summary()}. Elle affiche plusieurs éléments :

\begin{itemize}
\tightlist
\item
  \texttt{Call} : la fomule du modèle ;
\item
  \texttt{Residuals} : des statistiques descriptives des résidus ;
\item
  \texttt{Coefficients} : un tableau à deux entrées où les lignes correspondent aux coefficients associés aux variables explicatives, et les colonnes, dans l'ordre, à l'estimation du coefficient, l'écart-type estimé, la valeur du test de Student de nullité statistique du coefficient et enfin la \emph{p-value} associé à ce test, suivie d'un symbole pour lire rapidement la significativité ;
\item
  \texttt{Signif.\ codes} : les significations des symboles de niveau de significativité ;
\item
  \texttt{Residual\ standard\ error} : estimation de l'écart-type de l'aléa et degré de liberté ;
\item
  \texttt{Multiple\ R-squared} : coefficient de détermination ;
\item
  \texttt{Adjusted\ R-squared} : coefficient de détermination ajusté ;
\item
  \texttt{F-statistic} : valeur de la statistique de Fisher du test de significativité globale, ainsi que les degrés de liberté et la \emph{p-value} associée au test.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(reg)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Call:
## lm(formula = grams ~ gestate, data = births)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1512.41  -302.17   -12.41   285.15  1584.04 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept) -3245.45     197.01  -16.47   <2e-16 ***
## gestate       166.45       5.06   32.89   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 451.3 on 1113 degrees of freedom
## Multiple R-squared:  0.4929, Adjusted R-squared:  0.4925 
## F-statistic:  1082 on 1 and 1113 DF,  p-value: < 2.2e-16
\end{lstlisting}

\hypertarget{regressions_extractions}{%
\section{Extractions}\label{regressions_extractions}}

L'objet retourné par la régression contient plusieurs éléments auxquels il est possible d'accéder. Voici les principaux

\begin{itemize}
\tightlist
\item
  \texttt{coefficients} un vecteur de coefficients (nommé) ;
\item
  \texttt{residuals} les résidus ;
\item
  \texttt{fitted.values} : les valeurs estimées ;
\item
  \texttt{df.residual} : nombre de degrés de liberté.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(reg)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##  [1] "coefficients"  "residuals"     "effects"       "rank"         
##  [5] "fitted.values" "assign"        "qr"            "df.residual"  
##  [9] "xlevels"       "call"          "terms"         "model"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reg}\OperatorTok{$}\NormalTok{coefficients}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (Intercept)     gestate 
##  -3245.4464    166.4463
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Résidus}
\KeywordTok{qplot}\NormalTok{(}\KeywordTok{seq\_along}\NormalTok{(reg}\OperatorTok{$}\NormalTok{residuals), reg}\OperatorTok{$}\NormalTok{residuals) }\OperatorTok{+}
\StringTok{  }\KeywordTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylab}\NormalTok{(}\StringTok{"Résidus"}\NormalTok{)}

\CommentTok{\# Ordonnons les résidus en fonction de la masse des nouveaux{-}nés}
\NormalTok{ind \textless{}{-}}\StringTok{ }\KeywordTok{order}\NormalTok{(births}\OperatorTok{$}\NormalTok{grams)}
\KeywordTok{qplot}\NormalTok{(}\KeywordTok{seq\_along}\NormalTok{(reg}\OperatorTok{$}\NormalTok{residuals[ind]), reg}\OperatorTok{$}\NormalTok{residuals[ind]) }\OperatorTok{+}
\StringTok{  }\KeywordTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylab}\NormalTok{(}\StringTok{"Résidus"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/regressions_estimation_lm_1_summary_2-1} \includegraphics{_main_files/figure-latex/regressions_estimation_lm_1_summary_2-2} \end{center}

Certaines fonctions permettent également d'accéder aux éléments de la régression, comme \texttt{residuals()} (ou \texttt{resid()}), \texttt{fitted()} ou encore \texttt{coefficients()} (ou \texttt{coef()}) qui retournent les résidus, les valeurs estimées et les coefficients de la régression respectivement. Ces fonctions prennent en argument l'objet retourné par \texttt{lm()}. Voici un exemple d'utilisation de \texttt{residuals()}, pour tracer la droite de Henry (QQ-plot).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{qqplot \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(y, }\DataTypeTok{distribution=}\NormalTok{qnorm, }\DataTypeTok{title =} \StringTok{"Droite de Henry"}\NormalTok{,}
                   \DataTypeTok{xlab =} \StringTok{"Quantiles théoriques"}\NormalTok{,}
                   \DataTypeTok{ylab =} \StringTok{"Résidus studentisés"}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{(}\KeywordTok{class}\NormalTok{(y) }\OperatorTok{==}\StringTok{ "lm"}\NormalTok{)\{}
    \CommentTok{\# Résidus}
\NormalTok{    r \textless{}{-}}\StringTok{ }\KeywordTok{residuals}\NormalTok{(y)}
    \CommentTok{\# Résidus studentisés}
\NormalTok{    y \textless{}{-}}\StringTok{ }\NormalTok{r }\OperatorTok{/}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{deviance}\NormalTok{(y) }\OperatorTok{/}\StringTok{ }\KeywordTok{df.residual}\NormalTok{(y))}
\NormalTok{  \}}
\NormalTok{  x \textless{}{-}}\StringTok{ }\KeywordTok{distribution}\NormalTok{(}\KeywordTok{ppoints}\NormalTok{(y))}
\NormalTok{  df \textless{}{-}}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =} \KeywordTok{sort}\NormalTok{(y))}
  \KeywordTok{ggplot}\NormalTok{(df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom\_point}\NormalTok{() }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom\_abline}\NormalTok{(}\DataTypeTok{intercept =} \DecValTok{0}\NormalTok{, }\DataTypeTok{slope =} \DecValTok{1}\NormalTok{, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{ggtitle}\NormalTok{(title) }\OperatorTok{+}
\StringTok{    }\KeywordTok{xlab}\NormalTok{(xlab) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylab}\NormalTok{(ylab)}
\NormalTok{\}}

\KeywordTok{qqplot}\NormalTok{(reg)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/regressions_estimation_lm_1_qqplot-1} \end{center}

\hypertarget{regressions_facteurs}{%
\section{Variables catégorielles}\label{regressions_facteurs}}

En \texttt{R}, les variables catégorielles sont de mode \texttt{factor}. Si on souhaite intégrer une variable catégorielle à un modèle de régression linéaire, il y a deux méthodes. La première, est de définir le type de la variable dans le tableau qui contient les données (\texttt{tibble}, \texttt{data.frame}, \ldots). La seconde est d'utiliser la variable \texttt{factor()} dans la formule, lors de l'appel de la régression. La première méthode possède l'avantage de la lisibilité, surtout lorsque l'on souhaite définir la valeur de référence.

Lorsque la variable est de type \texttt{logical} ou \texttt{character}, la conversion est faite automatiquement par R. Le choix de la classe de référence est aussi effectué automatiquement.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(births}\OperatorTok{$}\NormalTok{smoke)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "logical"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }
\StringTok{          }\KeywordTok{lm}\NormalTok{(grams }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{gestate }\OperatorTok{+}\StringTok{ }\NormalTok{smoke }\OperatorTok{+}\StringTok{ }\NormalTok{black,}
             \DataTypeTok{data =}\NormalTok{ births))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Call:
## lm(formula = grams ~ gestate + smoke + black, data = births)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1464.13  -295.56     1.86   287.70  1611.83 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(>|t|)    
## (Intercept) -2713.653    199.723 -13.587  < 2e-16 ***
## gestate       156.570      5.016  31.213  < 2e-16 ***
## smokeTRUE    -185.015     30.883  -5.991 2.82e-09 ***
## blackTRUE    -174.402     27.027  -6.453 1.64e-10 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 436.3 on 1111 degrees of freedom
## Multiple R-squared:  0.5269, Adjusted R-squared:  0.5256 
## F-statistic: 412.4 on 3 and 1111 DF,  p-value: < 2.2e-16
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Equivalent de }
\KeywordTok{summary}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }
\StringTok{          }\KeywordTok{lm}\NormalTok{(grams }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{gestate }\OperatorTok{+}\StringTok{ }\KeywordTok{factor}\NormalTok{(smoke) }\OperatorTok{+}\StringTok{ }\KeywordTok{factor}\NormalTok{(black),}
             \DataTypeTok{data =}\NormalTok{ births))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Call:
## lm(formula = grams ~ gestate + factor(smoke) + factor(black), 
##     data = births)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1464.13  -295.56     1.86   287.70  1611.83 
## 
## Coefficients:
##                    Estimate Std. Error t value Pr(>|t|)    
## (Intercept)       -2713.653    199.723 -13.587  < 2e-16 ***
## gestate             156.570      5.016  31.213  < 2e-16 ***
## factor(smoke)TRUE  -185.015     30.883  -5.991 2.82e-09 ***
## factor(black)TRUE  -174.402     27.027  -6.453 1.64e-10 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 436.3 on 1111 degrees of freedom
## Multiple R-squared:  0.5269, Adjusted R-squared:  0.5256 
## F-statistic: 412.4 on 3 and 1111 DF,  p-value: < 2.2e-16
\end{lstlisting}

Pour changer la valeur de référence, on peut utiliser la fonction \texttt{fct\_relevel()} de \texttt{\{forcast\}}, ou bien préciser manuellement les niveaux au moment de la créqtion du facteur (le premier niveau énoné devenant la modalité de référence).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{births \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{births }\OperatorTok{\%\textgreater{}\%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{smoke =} \KeywordTok{factor}\NormalTok{(smoke))}

\KeywordTok{levels}\NormalTok{(births}\OperatorTok{$}\NormalTok{smoke)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "FALSE" "TRUE"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{births \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{births }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{smoke =} \KeywordTok{fct\_relevel}\NormalTok{(smoke, }\StringTok{"TRUE"}\NormalTok{))}

\CommentTok{\# Au moment de la création}
\NormalTok{births \textless{}{-}}\StringTok{ }
\StringTok{  }\NormalTok{births }\OperatorTok{\%\textgreater{}\%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{black =} \KeywordTok{factor}\NormalTok{(black, }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"TRUE"}\NormalTok{, }\StringTok{"FALSE"}\NormalTok{),}
                        \DataTypeTok{labels =} \KeywordTok{c}\NormalTok{(}\StringTok{"Black"}\NormalTok{, }\StringTok{"Not Black"}\NormalTok{)))}

\NormalTok{reg\_}\DecValTok{3}\NormalTok{ \textless{}{-}}\StringTok{ }\KeywordTok{lm}\NormalTok{(grams }\OperatorTok{\textasciitilde{}}\StringTok{ }\NormalTok{gestate }\OperatorTok{+}\StringTok{ }\NormalTok{smoke }\OperatorTok{+}\StringTok{ }\NormalTok{black, }\DataTypeTok{data =}\NormalTok{ births)}
\KeywordTok{summary}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Call:
## lm(formula = grams ~ gestate + smoke + black, data = births)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1464.13  -295.56     1.86   287.70  1611.83 
## 
## Coefficients:
##                 Estimate Std. Error t value Pr(>|t|)    
## (Intercept)    -3073.071    191.836 -16.019  < 2e-16 ***
## gestate          156.570      5.016  31.213  < 2e-16 ***
## smokeFALSE       185.015     30.883   5.991 2.82e-09 ***
## blackNot Black   174.402     27.027   6.453 1.64e-10 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 436.3 on 1111 degrees of freedom
## Multiple R-squared:  0.5269, Adjusted R-squared:  0.5256 
## F-statistic: 412.4 on 3 and 1111 DF,  p-value: < 2.2e-16
\end{lstlisting}

Une alternative à \texttt{fct\_relevel()} est la fonction \texttt{relevel()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exemple \textless{}{-}}\StringTok{ }\KeywordTok{relevel}\NormalTok{(births}\OperatorTok{$}\NormalTok{smoke, }\DataTypeTok{ref =} \StringTok{"FALSE"}\NormalTok{)}
\KeywordTok{levels}\NormalTok{(exemple)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "FALSE" "TRUE"
\end{lstlisting}

\hypertarget{regressions_tests}{%
\section{Tests de nullité des coefficients et intervalles de confiance}\label{regressions_tests}}

Soit le problème de test :
\begin{align*}
  \begin{cases}
        H_0 : \beta_i = 0\\
        H_1 : \beta_i \ne 0
    \end{cases}, i = 1, 2, \ldots, m.
\end{align*}

La statistique de test est la suivante :
\begin{align*}
  T = \frac{\hat{\beta}_i - \beta_{i,H_0}}{\hat{\sigma}_{\hat{\beta}_i}} \sim \mathcal{S}t(n-m-1,)
\end{align*}
avec \(\beta_{i,H_0}\) la valeur de \(\beta_j\) sous l'hypothèse nulle, \(\hat{\sigma}_{\hat{\beta}_i}\) l'estimation de l'écart-type de l'estimation du paramètre \(\beta_i\).

Pour effectuer ce test bilatéral, on peut lire dans la table de la loi de Student deux fractiles tels que :
\begin{align*}
    \mathbb{P}\left( -t_{1-\alpha/2} < \frac{\hat{\beta}_i - \alpha_{i,H_0}}{\hat{\sigma}_{\hat{\beta}_i}} < t_{1-\alpha/2} \right) = 1 - \alpha.
\end{align*}
avec \(\alpha\) le risque de première espèce.

à partir des observations, il est possible de calculer :
\begin{align*}
  t_{i,\textrm{obs.}} = \frac{\hat{\beta}_i}{\hat{\sigma}_{\hat{\beta}_i}}.
\end{align*}

La règle de décision est la suivante :

\begin{itemize}
\tightlist
\item
  si \(t_{i,\textrm{obs.}} \in [-t_{1-\alpha/2}, t_{1-\alpha/2}]\), nous somme dans la région d'acceptation, on ne rejette donc pas \(H_0\) au seuil de \(\alpha\), et on considère alors que \(\alpha_i\) n'est pas statistiquement différent de zéro ;
\item
  si en revanche \(t_{i,\textrm{obs.}} \notin [-t_{1-\alpha/2}, t_{1-\alpha/2}]\), nous sommes dans la région critique et cette fois on rejette l'hypothèse nulle en faveur de l'hypothèse alternative. On considère alors qu'avec un risque de première espèce de \(\alpha\), on a \(\alpha_i \ne 0\).
\end{itemize}

Sous \texttt{R}, comme vu dans la Section~@ref(regressions\_lecture), les tests de nullité de chaque coefficients sont effectués lors de l'appel de la fonction \texttt{summary()} sur l'objet retourné par la fonction \texttt{lm()}. Pour obtenir les intervalles de confiance, on peut s'amuser à extraire soi-même les coefficients et les écarts-types associés, pour faire le calcul à la main, ou bien avoir recours à la fonction \texttt{confint()}. Il suffit de lui fournir l'objet retourné par la fonction \texttt{lm()}, et de préciser éventuellement un niveau (le niveau par défaut étant \(95\%\)).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Intervalles de confiance à 95\% pour les paramètres}
\KeywordTok{confint}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##                     2.5 %     97.5 %
## (Intercept)    -3449.4726 -2696.6686
## gestate          146.7278   166.4120
## smokeFALSE       124.4204   245.6101
## blackNot Black   121.3724   227.4324
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Intervalles de confiance à 90\% pour les paramètres}
\KeywordTok{confint}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{, }\DataTypeTok{level =} \FloatTok{0.95}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##                     2.5 %     97.5 %
## (Intercept)    -3449.4726 -2696.6686
## gestate          146.7278   166.4120
## smokeFALSE       124.4204   245.6101
## blackNot Black   121.3724   227.4324
\end{lstlisting}

Voici une fonction qui permet d'afficher les intervalles de confiance pour chaque coefficient.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} @param x : objet issu de lm()}
\NormalTok{confint\_bar \textless{}{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  df \textless{}{-}}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\KeywordTok{confint}\NormalTok{(x))}
  \KeywordTok{colnames}\NormalTok{(df) \textless{}{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\StringTok{"b\_inf"}\NormalTok{, }\StringTok{"b\_sup"}\NormalTok{)}
\NormalTok{  df}\OperatorTok{$}\NormalTok{variable \textless{}{-}}\StringTok{ }\KeywordTok{rownames}\NormalTok{(df)}
  \KeywordTok{rownames}\NormalTok{(df) \textless{}{-}}\StringTok{ }\OtherTok{NULL}
\NormalTok{  df}\OperatorTok{$}\NormalTok{coef \textless{}{-}}\StringTok{ }\KeywordTok{coef}\NormalTok{(x)}
  
  \KeywordTok{ggplot}\NormalTok{(df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{factor}\NormalTok{(}\DecValTok{1}\NormalTok{), }\DataTypeTok{y =}\NormalTok{ coef)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom\_errorbar}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{ymin =}\NormalTok{ b\_inf, }\DataTypeTok{ymax =}\NormalTok{ b\_sup)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom\_point}\NormalTok{(}\DataTypeTok{col =} \StringTok{"dodger blue"}\NormalTok{, }\DataTypeTok{size =} \DecValTok{3}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom\_hline}\NormalTok{(}\DataTypeTok{yintercept =} \DecValTok{0}\NormalTok{, }\DataTypeTok{linetype =} \StringTok{"dashed"}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{facet\_wrap}\NormalTok{(}\OperatorTok{\textasciitilde{}}\NormalTok{variable, }\DataTypeTok{scales =} \StringTok{"free\_y"}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{xlab}\NormalTok{(}\StringTok{""}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{axis.ticks =} \KeywordTok{element\_blank}\NormalTok{(),}
          \DataTypeTok{axis.text.x =} \KeywordTok{element\_blank}\NormalTok{())}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

On peut alors appliquer cette fonction au résultat d'une régression linéaire :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{confint\_bar}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{_main_files/figure-latex/regressions_tests_coef_bar_plot-1} \end{center}

\hypertarget{regressions_previsions}{%
\section{Prévisions}\label{regressions_previsions}}

Une fois que la fonction \texttt{lm()}\footnote{voir l'aide de la fonction \texttt{?predict.lm}} a estimé les paramètres du modèle, il est possible de réutiliser les estimations pour effectuer des prévisions, avec des nouvelles données. On considère un nouvel enregistrement, \(\boldsymbol{x}^\top_{n+1} = \begin{bmatrix}  x_{n+1, 1} & x_{n+1, 2} & \ldots & x_{n+1, m}  \end{bmatrix}\), et l'objectif est de prévoir la valeur de \(y_{n+1}\), en utilisant la relation initiale :
\begin{equation}
y_{n+1} = \beta_0 + \beta_1 \boldsymbol x_{n+1,1} + \beta_2 \boldsymbol x_{n+1,2} + \cdots + \beta_m \boldsymbol x_{n+1,m} + \boldsymbol \varepsilon_{n+1}.\label{eq:regressions_previsions},
\end{equation}
où \(\mathbb{E}[\varepsilon_{n+1}] = 0\), \(\mathbb{V}(\varepsilon_{n+1}) = \sigma^2\) et \(\mathbb{C}ov(\varepsilon_{n+1}, \varepsilon_{i}) = 0\), \(i = 1, 2, \ldots, n\).\textbackslash{}

La valeur prévue, \(\hat y_{n+1}^p\) s'appuie sur les coefficients estimés par le modèle :
\begin{equation}
\hat y_{n+1}^p = \hat\beta_0 + \hat\beta_1 \boldsymbol x_{n+1,1} + \hat\beta_2 \boldsymbol x_{n+1,2} + \cdots + \hat\beta_m \boldsymbol x_{n+1,m}.\label{eq:regressions_previsions_2}
\end{equation}
On note \(z_{n+1} = y_{n+1} - \hat y_{n+1}^p\) l'erreur de prévision. On a :
\begin{align}
  \begin{cases}
  \mathbb{E}[z_{n+1}] = 0\\
  \mathbb{V}(z_{n+1}) = \sigma^2 \times \left( 1 + \boldsymbol {x}^\top_{n+1} (\boldsymbol X^\top \boldsymbol X)^{-1} \boldsymbol x_{n+1}  \right)
  \end{cases}
\end{align}

Comme on émet l'hypothèse que la distribution des \(\varepsilon_i\) est normale, la distribution des \(y_{i}\) et \(\hat y_{i}^p\) l'est aussi. De fait, on a :
\begin{align}
z_i^p \sim \mathcal{N}\left(0,\sqrt{\mathbb{V}(z_i^p)}\right).
\end{align}

On peut estimer la variance inconnue \(\sigma^2_\varepsilon\) par son estimation \(\hat{\sigma}^2_\varepsilon\).

Dès lors, on a :
\begin{align}
\frac{z_i^p - \mathbb{E}(z_i^p)}{\hat{\sigma}_{\varepsilon}} \sim \mathcal{S}t(n-2).
\end{align}

Il est alors possible de construire un intervalle de confiance au seuil de \(\alpha\) pour \(y_i^p\), soit :
\begin{align}
\widehat{\textrm{I.C.}_{y_{n+1}}(1-\alpha)} = \left[ \hat{y}_{n+1}^p \pm t_{1-\alpha/2} \cdot \hat{\sigma}_{z_{n+1}^p} \right],
\end{align}
où \(t_{1-\alpha/2}\) est la valeur du fractile lue dans la table pour \(\alpha\) et \(\gamma = n-2\) degrés de liberté.\textbackslash{}

\texttt{R} propose la fonction \texttt{predict()} pour calculer cet intervalle de prévision. L'objet retourné par la fonction \texttt{lm()} est passé en argument à la fonction \texttt{predict()}. Si aucun autre argument n'est fourni, l'évaluation retourne les valeurs estimées pour la variable à expliquer.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{predict}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{), }\KeywordTok{fitted}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE
\end{lstlisting}

Si en revanche, on ajoute de nouvelles données, en les passant à l'arguemnt \texttt{newdata}, alors le modèle estimé est utilisé à partir de ces nouvelles données pour fournir des prévisions. Il faut toutefois faire attention à ce que les noms des variables du nouveau tableau de données soient identiques à celui passé dans la fonction\texttt{lm()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{donnees\_supl \textless{}{-}}\StringTok{ }
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{black =} \KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{),}
                        \DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{),}
                        \DataTypeTok{labels =} \KeywordTok{c}\NormalTok{(}\StringTok{"Black"}\NormalTok{, }\StringTok{"Not Black"}\NormalTok{)),}
         \DataTypeTok{educ =} \KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{,}\DecValTok{5}\NormalTok{),}
         \DataTypeTok{smoke =} \KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)),}
         \DataTypeTok{gestate =} \KeywordTok{c}\NormalTok{(}\DecValTok{39}\NormalTok{, }\DecValTok{43}\NormalTok{))}
\KeywordTok{predict}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{, }\DataTypeTok{newdata =}\NormalTok{ donnees\_supl)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        1        2 
## 3218.171 4018.853
\end{lstlisting}

Par défaut, les intervalles de prévision de sont pas donnés, il faut forcer leur calcul en donnant la valeur \texttt{"prediction"} à l'arguemnt \texttt{interval}. L'intervalle de confiance pour la valeur prévue est donné pour un risque de première espèce de \(5\%\). Pour un risque de première espèce différent, il faut changer la valeur de l'argument \texttt{level}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# I.C. à 95\% pour la prévision}
\KeywordTok{predict}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{, }\DataTypeTok{newdata =}\NormalTok{ donnees\_supl, }\DataTypeTok{interval =} \StringTok{"prediction"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        fit      lwr      upr
## 1 3218.171 2361.229 4075.113
## 2 4018.853 3161.006 4876.700
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# I.C. à 90\% pour la prévision}
\KeywordTok{predict}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{, }\DataTypeTok{newdata =}\NormalTok{ donnees\_supl, }\DataTypeTok{interval =} \StringTok{"prediction"}\NormalTok{, }\DataTypeTok{level =} \FloatTok{0.9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        fit      lwr      upr
## 1 3218.171 2499.187 3937.155
## 2 4018.853 3299.109 4738.597
\end{lstlisting}

On peut demander d'afficher les valeurs des écarts-types, avec l'argument \texttt{se.fit}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{predict}\NormalTok{(reg\_}\DecValTok{3}\NormalTok{, }\DataTypeTok{newdata =}\NormalTok{ donnees\_supl, }\DataTypeTok{interval =} \StringTok{"prediction"}\NormalTok{, }\DataTypeTok{se.fit =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## $fit
##        fit      lwr      upr
## 1 3218.171 2361.229 4075.113
## 2 4018.853 3161.006 4876.700
## 
## $se.fit
##        1        2 
## 18.79725 27.50835 
## 
## $df
## [1] 1111
## 
## $residual.scale
## [1] 436.3423
\end{lstlisting}

\hypertarget{exercices-sur-la-ruxe9gression}{%
\section{Exercices sur la régression}\label{exercices-sur-la-ruxe9gression}}

\begin{exframe}
\textbf{Exercice 1 : exploration rapide des données}

Cet exercice s'appuie sur un jeu de données de consommation de carburant de 392 véhicules. Il provient de la bibliothèque StatLib, maintenue à la Carnegie Mellon University\footnote{\url{http://archive.ics.uci.edu/ml/datasets/Auto+MPG}}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Charger le jeu de données \texttt{Auto} contenu dans le \emph{package} \texttt{\{ISLR\}}, puis regarder sa page d'aide ;
\item
  Afficher un résumé des différentes variables ;
\item
  En utilisant la fonction \texttt{stargazer()} contenue dans le \emph{package} du même nom, aficher dans la console un tableau de statistiques descriptives en sortie texte ASCII. Prendre soin de limiter à deux le nombre de chiffres des décimales ;
\item
  Exporter ce tableau dans un fichier \texttt{HTML}, en prenant soin d'ajouter le titre suivant : ``Statistiques descriptives''. De plus, changer le séparateur des décimales en une virgule au lieu d'un point ;
\item
  Représenter par un nuage de points la relation entre les variables de puissance (\texttt{horsepower}) et de consommation (\texttt{mpg}), puis sur un autre graphique, la relation entre la masse du véhicule (\texttt{weight}) et sa consommation ;
\item
  Reprendre le code du graphique représentant la consommation en fonction de la masse du véhicule, et faire dépendre la couleur des points du nombre de cylindres (le nombre de cylindres sera considéré comme une variable catégorielle). Puis, ajouter des courbes de tendance pour chaque catégorie de cylindres à l'aide de la fonction \texttt{stat\_smooth()}. Ces courbes de tendance devront être estimées à l'aide d'une régression linéaire.
\item
  Afficher un tableau des corrélations entre chaque variables numériques ;
\item
  En utilisant la fonction \texttt{corrplot.mixed()} du \emph{package} \texttt{\{corrplot\}}, réaliser une visualitation graphique de la matrice de corrélation.
\end{enumerate}
\end{exframe}

\begin{exframe}
\textbf{Exercice 2 : régression linéaire}

Cet exercice s'appuie sur le même jeu de données que le précédent.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Préparer deux tableaux de données : l'un comprenant \(80\%\) des observations, et le second les \(20\%\) restantes. Les observations à conserver dans le tableau contenant \(80\%\) des observations doivent être tirées au hasard ;
\item
  En prenant comme jeu de données la base avec \(80\%\) des observations, régresser la consommation (\texttt{mpg}) sur la puissance (\texttt{horsepower}), la masse (\texttt{weight}) et l'année de mise en circulation (\texttt{year}), en faisant appel à la fonction \texttt{lm()};
\item
  Afficher un résumé de l'estimation à l'aide de la fonction \texttt{summary}, puis extraire uniquement le tableau des coefficients ;
\item
  Observer les graphiques retournés lorsque la fonction \texttt{plot()} est appliquée au résultat de l'estimation ;
\item
  Créer un tableau de données contenant les résidus de la régression, ainsi qu'une colonne indiquant le numéro des lignes de chaque observation (que l'on peut appeler \texttt{index} par exemple) ;
\item
  Tracer les résidus à l'aide d'un nuage de points (les valeurs de la variable \texttt{index} seront représentées en abscisses). Puis, changer la représentation géométrique pour afficher un histogramme des résidus ;
\item
  Construire un intervalle de confiance à \(95\%\) pour chacun des coefficients de la régression. Pour un paramètre \(\alpha\), l'intervalle de confiance est donné par :
  \[\widehat{\textrm{I.C.}_\alpha(1-p)} = \left[ \hat{\alpha} \pm t_{p/2, n-m-1} \times \hat{\sigma}_{\hat{\alpha}}\right],\]
  avec \(p\) le risque associé au test, \(n\) le nombre d'observations, \(m\) le nombre de variables explicatives et \(t_{p/2, n-m-1}\) le quantile d'ordre \(p/2\) de la Student à \(n-m-1\) degrés de liberté.

  Pour réaliser les intervalles de confiance, procéder comme suit :

  \begin{itemize}
  \tightlist
  \item
    récupérer le tableau de coefficients issu du résumé de l'estimation, et le stocker dans un objet de type \texttt{data.frame} que l'on appellera \texttt{coeffs} ;
  \item
    récupérer ensuite le nombre de degrés de libertés associés au test de nullité d'un coefficient ;
  \item
    ajouter dans le tableau \texttt{coeffs} les variables \texttt{b\_inf} et \texttt{b\_sup}, qui correspondent respectivement aux bornes inférieures et supérieures de chaque intervalle.
  \item
    Enfin, comparer les résultats obtenus avec ceux issus de l'application de la fonction \texttt{confint()} à l'objet de la régression ;
  \end{itemize}
\item
  Exporter les résultats de la régression dans un fichier \texttt{html}, en s'appuyant sur la fonction \texttt{stargazer()} ;
\item
  En utilisant le modèle estimé et les données contenues dans la base contenant uniquement \(20\%\) des observations, effectuer des prévisions sur la consommation des véhicules et les comparer aux valeurs réelles ;
\end{enumerate}
\end{exframe}

\hypertarget{regex}{%
\chapter{Expressions régulières}\label{regex}}

La Section~\ref{manip-strings-regex} montre des exemples simples de recherches de chaînes de caractères. Celle-ci s'attarde à présenter un moyen de faire des recherches plus avancées, à l'aide de ce que l'on appelle les \emph{expressions régulières} (ou \emph{regular expressions}, abrégé par \emph{regex}), qui sont des séquences de caractères formant un motif de recherche (ou \emph{search pattern}).

Avant d'aller plus loin, il convient de rappeler au lecteur ou à la lectrice l'existence de l'aide sous \texttt{R}. La page réservée aux \texttt{regex}, accessible en évaluant la commande \texttt{?regex} (\emph{package} \texttt{base}), est un bon aide mémoire. Par ailleurs, le cours intitulé ``\emph{Les expressions régulières}'' sur \emph{OpenClassrooms} est un bon support\footnote{\url{http://fr.openclassrooms.com/informatique/cours/concevez-votre-site-web-avec-php-et-mysql/les-expressions-regulieres-partie-1-2}}. Cependant, \texttt{R} possède quelques terminologiques qui lui sont propres, et qui diffèrent légèrement du cours proposé sur \emph{OpenClassrooms}.

\hypertarget{manip_regex_structure}{%
\section{Les recherches basiques}\label{manip_regex_structure}}

Les fonctions qui emploient les \emph{regex} en R attendent au minimum deux arguments :

\begin{itemize}
\tightlist
\item
  un premier pour indiquer la chaîne de caractères (ou le vecteur de chaînes de caractères) sur lequel (lesquels) les recherches vont être effectuées ;
\item
  un deuxième pour préciser le motif (\emph{pattern}) à rechercher. C'est l'argument qui contient l'expression régulière
\end{itemize}

Lorsque l'expression est trouvée dans une chaîne de caractère, on dit qu'il y a \emph{match} (ou appariement).

Le \emph{package} \texttt{\{base\}} offre de nombreuses fonctions pour effectuer des manipulations de chaînes de caractères à l'aide des expressions régulières. Elles souffrent toutefois quelques légers problèmes : il y a peu d'unité dans la syntaxe de ces fonctions et le nom de certaines d'entre-elles n'est pas immédiatement compréhensible. Aussi, nous ne nous attarderont pas à vous faire part du panorama des fonctions du \emph{package} \texttt{\{base\}} ici. Nous passerons davantage de temps sur les fonctions du \emph{package} \texttt{\{stringr\}}, qui s'appuient, pour la plupart d'entre-elles, sur des fonctions du \emph{package} \{\texttt{base}\}.

Le nom des fonction du \emph{package} \{\texttt{stringr}\} possède le préfixe \texttt{\_}. Les deux arguments principaux indiquant le texte et le vecteur de chaînes de caractères et le motif sont appelés \texttt{string} et \texttt{pattern}. La syntaxe des fonctions de \{\texttt{stringr}\} est donc comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_function}\NormalTok{(string, pattern)}
\end{Highlighting}
\end{Shaded}

\hypertarget{manip_regex_stringr_detect}{%
\subsection{\texorpdfstring{Détection d'un motif avec \texttt{str\_detect()}}{Détection d'un motif avec str\_detect()}}\label{manip_regex_stringr_detect}}

Pour détecter la présence ou l'absence d'un motif dans une chaîne, on peut utiliser la fonction \texttt{str\_detect()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(stringr)}
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"J\textquotesingle{}ai pas le temps, j\textquotesingle{}ai matériellement pas le temps de faire ça"}\NormalTok{,}
           \StringTok{"Y a pas assez d\textquotesingle{}chaises ici ?"}\NormalTok{,}
           \StringTok{"J\textquotesingle{}ai"}\NormalTok{)}

\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"j\textquotesingle{}ai"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En ignorant la casse}
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ textes,}
           \DataTypeTok{pattern =} \KeywordTok{regex}\NormalTok{(}\StringTok{"j\textquotesingle{}ai"}\NormalTok{, }\DataTypeTok{ignore\_case =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE  TRUE
\end{lstlisting}

Si on désire rechercher la présence d'un motif ou d'un autre dans un texte, on peut effectuer à la main des appels multiples à une fonction de recherche, un appel par texte à chercher, ou on peut plus simplement utiliser l'opérateur logique ``Ou'', qui s'écrit \texttt{\textbar{}} en \texttt{R}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{textes  \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"J’accepte votre bonjour, Ashley."}\NormalTok{,}
            \StringTok{"Et je vous l’échange contre un coucou."}\NormalTok{, }
            \StringTok{"Coucou !"}\NormalTok{)}
\NormalTok{motif \textless{}{-}}\StringTok{ "coucou|Ashley"}
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ textes, }\DataTypeTok{pattern =}\NormalTok{ motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE FALSE
\end{lstlisting}

Le premier élément du vecteur \texttt{textes} contient le mot \texttt{"Ashley"} mais pas \texttt{"coucou"}. Il y a bien au moins une des deux sous-chaînes qui a été trouvée. Le troisième élément, en revanche, ne contient ni \texttt{"coucou"}, ni \texttt{"Ashley"} (il ne faut pas oublier que les fonctions traitant les expressions régulières sont par défaut sensibles à la casse en \texttt{R}).

Pour chercher si un motif est présent en début de texte, on fait débuter la sous-chaîne à \emph{matcher} par un accent circonflexe. Pour chercher si un motif est en fin de texte, on termine la sous-chaîne à \emph{matcher} par un symbole dollar.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Mais je ne mange pas, voyons !"}\NormalTok{,}
          \StringTok{"Mais je ne mange pas"}\NormalTok{, }\StringTok{"voyons ! Mais"}\NormalTok{)}
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ textes, }\DataTypeTok{pattern =} \StringTok{"\^{}Mais"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ textes, }\DataTypeTok{pattern =} \StringTok{"je ne mange pas$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE FALSE
\end{lstlisting}

\hypertarget{manip_regex_classes}{%
\section{Les classes de caractères}\label{manip_regex_classes}}

Les classes de caractères sont des listes de caractères appartenant à un ensemble, comme par exemple les caractètres alphabétiques, numériques, alphanumériques, etc. Il est possible de les construire soi-même, ou bien d'utiliser des classes prédéfinies. Elles sont écrites en les plaçant entre des crochets \texttt{{[}classe{]}}.

Par exemple, si on désire chercher s'il y a des occurrences du caractère \texttt{o} ou \texttt{i} entre les sous-chaînes \texttt{Cr} et \texttt{q}, on définit la classe de caractères \texttt{{[}oi{]}} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =} \KeywordTok{c}\NormalTok{(}\StringTok{"Criquette"}\NormalTok{, }\StringTok{"Craquer"}\NormalTok{, }\StringTok{"Croquette"}\NormalTok{),}
           \DataTypeTok{pattern =} \StringTok{"Cr[oi]q"}\NormalTok{, )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE  TRUE
\end{lstlisting}

On a cherché dans chaque élément de \texttt{string}, s'il y avait la chaîne \texttt{Croq} ou \texttt{Criq}.

La construction d'une classe de caractère comme \texttt{{[}oi{]}} ne représente peut-être pas un attrait énorme, mais il est possible d'en créer d'autres plus alléchantes. En effet, en utilisant le tiret (\texttt{-}), on peut définir une séquence de caractère. Ainsi, la classe de caractères \texttt{{[}A-Z{]}} permet de \emph{matcher} les lettres de l'ensemble \texttt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}, tandis que \texttt{{[}0-9{]}} permet de \texttt{matcher} les caractères de l'ensemble \texttt{0123456789}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche une voyelle minuscule}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[aeiou]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche une voyelle majuscule}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[AEIOU]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère numérique}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[0{-}9]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphabétique ASCII majuscule}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[A{-}Z]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE FALSE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphabétique ASCII minuscule}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[a{-}z]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphabétique (majuscule ou minuscule)}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[A{-}Za{-}z]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphanumérique}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[A{-}Za{-}z0{-}9]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE  TRUE  TRUE
\end{lstlisting}

Si l'utilisateur désire rechercher un caractère qui n'appartient pas à une classe de caractères, il suffit de rajouter un accent circonflèxe (\texttt{\^{}}) juste après le crochet ouvrant. Si on désire rechercher la présence de l'accent circonflèxe dans un texte, en utilisant une classe de caractère, il faut placer le symbole autre part que juste après le crochet. Pour chercher un crochet fermant (ouvrant) il faut le faire précéder des doubles barres obliques inverses. Enfin, pour chercher un tiret, il suffit de la placer en premier ou en dernier de la définition de la classe.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Y a{-}t{-}t{-}il autre chose que des chiffres ?}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"911"}\NormalTok{), }\StringTok{"[\^{}0{-}9]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche de l\textquotesingle{}accent circonflèxe ou d\textquotesingle{}un chiffre}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"Allo \^{} accent"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"911"}\NormalTok{), }\StringTok{"[0{-}9\^{}]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE  TRUE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Rechercher un crochet}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"All[o"}\NormalTok{, }\StringTok{"All]o \^{} accent"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"911"}\NormalTok{), }\StringTok{"[}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{[}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Rechercher un tiret ou un i}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"All[o"}\NormalTok{, }\StringTok{"All{-}] \^{} accent"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"9i11"}\NormalTok{), }\StringTok{"[{-}i]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE  TRUE  TRUE  TRUE
\end{lstlisting}

\begin{remarque}
Il ne faut pas confondre l'accent circonflèxe inséré entre les crochets et celui placé au début d'une chaîne pour indiquer que le motif doit commencer par cette chaîne.
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Le texte commence{-}t{-}il par autre chose qu\textquotesingle{}un chiffre ?}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{, }\StringTok{"911"}\NormalTok{), }\StringTok{"\^{}[\^{}0{-}9]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE FALSE FALSE
\end{lstlisting}

\texttt{R} propose la bibliothèque de classes appelée \texttt{POSIX}. Ces classes s'utilisent en faisant appel à leur nom, de la même manière que les classes définies par l'utilisateur, ou les séquences : \texttt{{[}classe{]}}. Il faut toutefois noter que les noms des classes de caractères \texttt{POSIX} sont légèrement différentes en \texttt{R} que dans d'autres langages, comme \texttt{PHP} par exemple. En effet, il faut les entourer de crochets et de deux-points. Ainsi, la classe des alphanumériques sera accessible par son nom \texttt{{[}:alnum:{]}} et utilisée de la sorte : \texttt{{[}{[}:alnum:{]}{]}}. Le fichier d'aide des \emph{regex} de \texttt{R} met en garde l'utilisateur que ces classes de caractères prédéfinies peuvent varier selon les configurations des machines, notamment les configurations linguisitiques. Voici quelques exemples.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère numérique}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[[:digit:]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Rechercher un caractère non{-}numérique}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"911"}\NormalTok{), }\StringTok{"[\^{}[:digit:]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphabétique majuscule}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[[:upper:]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE FALSE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphabétique minuscule}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[[:lower:]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphabétique (majuscule ou minuscule)}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[[:alpha:]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphanumérique}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[[:alnum:]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche une espace ou une tabulation}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo}\CharTok{\textbackslash{}t}\StringTok{"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{), }\StringTok{"[[:blank:]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche d\textquotesingle{}un caractère de ponctuation}
\CommentTok{\# (! " \# $ \% \& \textquotesingle{} ( ) * + , {-} . / : ; \textless{} = \textgreater{} ? @ [ \textbackslash{} ] \^{} \_ \textasciigrave{} \{ | \} \textasciitilde{})}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"[[:punct:]]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE  TRUE  TRUE
\end{lstlisting}

\texttt{R} propose également quelques abréviations pour accéder à certaines classes. On y accède en écrivant une lettre minuscule précédée de deux barre obliques inversées. Si la lettre est en majuscule, il s'agit de la recherche de non appartenance à la classe. Par exemple, \texttt{\textbackslash{}\textbackslash{}d} recherche un caractère numérique (\emph{digital}), et \texttt{\textbackslash{}\textbackslash{}D} recherche un caractère n'étant pas numérique. Voici quelques exemples.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère numérique}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"911"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{d"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE FALSE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un caractère non{-}numérique}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"Allo 9{-}1{-}1"}\NormalTok{, }\StringTok{"911"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{D"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE  TRUE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche un cacractère alphanumérique}
\CommentTok{\# Attention à cette abréviation qui match le trait de soulignement...}
\KeywordTok{str\_detect}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"\_!"}\NormalTok{, }\StringTok{"Allo"}\NormalTok{, }\StringTok{"allo"}\NormalTok{, }\StringTok{"ALLO"}\NormalTok{, }\StringTok{"9{-}1{-}1"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{w"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE TRUE TRUE TRUE TRUE
\end{lstlisting}

Le tableau ci-dessous donne un récapitulatif des classes de caractères prédéfinies.

\begin{longtable}[]{@{}cccl@{}}
\toprule
\begin{minipage}[b]{0.17\columnwidth}\centering
ASCII\strut
\end{minipage} & \begin{minipage}[b]{0.21\columnwidth}\centering
POSIX\strut
\end{minipage} & \begin{minipage}[b]{0.21\columnwidth}\centering
Raccourcis\strut
\end{minipage} & \begin{minipage}[b]{0.29\columnwidth}\raggedright
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:lower:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}a-z{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Lettre minuscule\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:upper:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}A-Z{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Lettre majuscule\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:alpha:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}a-zA-Z{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Lettre minuscule et majuscule\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:digit:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}0-9{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{\textbackslash{}\textbackslash{}d}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Chiffres de 0 à 9\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:alnum:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}a-zA-Z0-9{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Caractère alphanumérique\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:blank:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}\textbackslash{}t{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Espace et tabulation\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:cntrl:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Caractère de contrôle\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:punct:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}{]}!\textbackslash{}"\#\$\textbackslash{}\textbackslash{}\%\&\textbackslash{}\textquotesingle{}\textbackslash{}\textbackslash{}(\textbackslash{}\textbackslash{})*+,-\textbackslash{}\textbackslash{}./:;\textless{}=\textgreater{}\textbackslash{}\textbackslash{}?@\^{}\_\textasciigrave{}\{\textbar{}\}\textasciitilde{}{[}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Ponctuation et symbole\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:space:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}\ \textbackslash{}t\textbackslash{}r\textbackslash{}n\textbackslash{}v\textbackslash{}f{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{\textbackslash{}\textbackslash{}s}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Espace blanc ou séparateur de ligne ou de paragraphe\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:xdigit:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}A-Fa-f0-9{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Chiffre hexadécimal\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:print:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}A-Fa-f0-9{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Caractère visible et espace (tout sauf caractère de contrôle)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\texttt{{[}{[}:graph:{]}{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}\textbackslash{}x20-\textbackslash{}x7E{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Caractère graphique visible (tout sauf espace et caractère de contrôle)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{{[}A-Za-z0-9\_{]}}\strut
\end{minipage} & \begin{minipage}[t]{0.21\columnwidth}\centering
\texttt{\textbackslash{}\textbackslash{}w}\strut
\end{minipage} & \begin{minipage}[t]{0.29\columnwidth}\raggedright
Lettre, chiffre et trait de soulignement\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{manip_regex_quantificateurs}{%
\section{Les quantificateurs}\label{manip_regex_quantificateurs}}

Afin de pouvoir chercher des motifs qui se répètent, dans un nombre défini \emph{a priori} ou non, on peut utiliser ce que l'on appelle des quantificateurs.

Les principaux quantificateurs sont les suivants :

\begin{itemize}
\tightlist
\item
  \texttt{?} : le précédent item est factultatif, et sera donc \emph{matché} \(0\) ou \(1\) fois ;
\item
  \texttt{*} : le précédent item sera \emph{matché} \(0\) fois ou plus ;
\item
  \texttt{+} : le précédent item sera \texttt{matché} \(1\) fois ou plus ;
\item
  \texttt{n} : le précédent item sera \texttt{matché} exactement n fois ;
\item
  \texttt{n,} : le précédent item sera \texttt{matché} \(n\) fois ou plus ;
\item
  \texttt{n,m} : le précédent item sera \texttt{matché} au mois \(n\) fois, mais pas plus de \(m\) fois.
\end{itemize}

Quelques exemple pour se fixer les idées.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La chaîne "travaille " peut être présente 0 ou 1 fois}
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Lolo travaille au skateshop"}\NormalTok{, }\StringTok{"Lolo au skateshop"}\NormalTok{)}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"Lolo (travaille )?au skateshop"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Cherche "ah Sonia", ou "ahah Sonia", ou "ahahah Sonia", etc.}
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"ahahah Sonia"}\NormalTok{, }\StringTok{"ahah Sonia"}\NormalTok{, }\StringTok{"Sonia"}\NormalTok{, }\StringTok{"Amandine"}\NormalTok{)}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"(ah)* Sonia"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE  TRUE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# On souhaite s\textquotesingle{}assurer qu\textquotesingle{}il y a au moins un "ah" suivi de " Stéphanie"}
\CommentTok{\# Mais on peut aussi avoir "ahah Stéphanie" ou "ahahah Stéphanie"}
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Bonjour Stéphanie"}\NormalTok{, }\StringTok{"ah Stéphanie"}\NormalTok{, }\StringTok{"ahah Stéphanie"}\NormalTok{)}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"(ah)+"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a\#maisoui\#maisoui !"}\NormalTok{, }\StringTok{"a\#maisoui !"}\NormalTok{, }\StringTok{"a\#maisoui\#maisoui\#maisoui !"}\NormalTok{,}
           \StringTok{"a\#maisoui\#maisoui\#maisoui\#maisoui !"}\NormalTok{)}

\CommentTok{\# Y a{-}t{-}il une sous chaîne "a\#maisoui\#maisoui !" dans le texte ?}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"a(\#maisoui)\{2\} !"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE FALSE FALSE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Y a{-}t{-}il une sous chaîne "a\#maisoui\#maisoui !", ou}
\CommentTok{\# "a\#maisoui\#maisoui\#maisoui !", etc. dans le texte ?}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"a(\#maisoui)\{2,\} !"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE  TRUE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La chaîne "skate" sera présente entre deux et trois fois}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"a(\#maisoui)\{2,3\} !"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE  TRUE FALSE
\end{lstlisting}

\hypertarget{manip_regex_metacaracteres}{%
\section{Les métacaractères}\label{manip_regex_metacaracteres}}

Les \emph{regex} possèdent quelques caractères spéciaux, qui ont un statut réservé, et qui sont appelés des \emph{métacaractères}. L'accent circonflèxe en fait partie. En effet, l'expression régulière \texttt{\^{}Bonjour} ne recherchera pas la chaîne \texttt{"\^{}Bonjour"}, comme vu plus haut.

La liste des métacaractères est la suivante : \texttt{.\ \textbackslash{}\textbar{}\ (\ )\ {[}\ \{\ \$\ *\ +\ ?}

En \texttt{R} pour pouvoir rechercher ces caractères dans des chaînes, il faut les échapper, à l'aide de deux barres obliques inversées \texttt{\textbackslash{}\textbackslash{}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Clément et Marianne vont chez Thibault."}\NormalTok{,}
           \StringTok{"Clément (et Marianne) vont chez Thibault !"}\NormalTok{)}

\CommentTok{\# Recherche la présence de "et Marianne"}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"(et Marianne)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Recherche la présence de "(et Marianne)"}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{(et Marianne}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] FALSE  TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Le dernier caractère est{-}il n\textquotesingle{}importe quel caractère ?}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{".$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] TRUE TRUE
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Le texte se termine{-}t{-}il par un point ?}
\KeywordTok{str\_detect}\NormalTok{(textes, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{.$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE
\end{lstlisting}

\hypertarget{manip_regex_stringr}{%
\section{\texorpdfstring{Quelques fonctions du \emph{package} \{\texttt{stringr}\}}{Quelques fonctions du package \{stringr\}}}\label{manip_regex_stringr}}

Regardons à présent quelques fonctions de \{\texttt{stringr}\} qui permettent de manipuler des chaînes de caractères à l'aide d'expressions régulières.

\hypertarget{manip_regex_stringr_extract}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_detect()}}{La fonction str\_detect()}}\label{manip_regex_stringr_extract}}

Pour extraire une chaîne qui contient un motif, on peut utiliser la fonction \texttt{str\_extract()}. Le résultat est un vecteur de caractères de la même longueur que celui fourni à l'argument \texttt{string}. Pour les éméments pour lesquels il n'y a pas eu de \emph{match}, la valeur \texttt{NA} est retournée.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{adresses \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"criquette.rockwell@gmail.com"}\NormalTok{,}
              \StringTok{"brett.montgomery@yahoo.fr"}\NormalTok{,}
              \StringTok{"madge\_laposte.net"}\NormalTok{)}
\NormalTok{motif \textless{}{-}}\StringTok{ "\^{}[[:alnum:].{-}]+@[[:alnum:].{-}]+$"}

\CommentTok{\# Extraire les adresses e{-}mail valides}
\KeywordTok{str\_extract}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ adresses, }\DataTypeTok{pattern =}\NormalTok{ motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "criquette.rockwell@gmail.com" "brett.montgomery@yahoo.fr"   
## [3] NA
\end{lstlisting}

\hypertarget{manip_regex_stringr_extract_all}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_extract\_all()}}{La fonction str\_extract\_all()}}\label{manip_regex_stringr_extract_all}}

Alors que la fonction \texttt{str\_extract()} ne permet d'extraire que la première chaîne qui \emph{match} le motif, \texttt{str\_extract\_all()} retourne toutes les occurrences trouvées. Le résultat est une liste de la même longueur que celle du vecteur fourni à l'argument \texttt{string}. Les éléments de cette liste sont des vecteurs de la taille du nombre d'occurrences du motif trouvé. En cas d'absence de \texttt{match}, la valeur \texttt{character(0)} est retournée.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweets \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"@kevin\_ushey yes sure, it was just an example"}\NormalTok{,}
            \StringTok{"@hspter @kwbroman next is to get into \#github streak art."}\NormalTok{)}
\NormalTok{motif \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"@[[:alpha:]]\{1,\}"}\NormalTok{)}

\CommentTok{\# Extraire la première mention trouvée}
\KeywordTok{str\_extract}\NormalTok{(tweets, motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "@kevin"  "@hspter"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Extraire toutes les mentions trouvées}
\KeywordTok{str\_extract\_all}\NormalTok{(tweets, motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "@kevin"
## 
## [[2]]
## [1] "@hspter"   "@kwbroman"
\end{lstlisting}

\hypertarget{manip_regex_stringr_match}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_match()}}{La fonction str\_match()}}\label{manip_regex_stringr_match}}

La fonction \texttt{str\_match()} extrait le premier \emph{groupe} trouvé dans une chaîne. Il est donc nécessaire que l'argument \texttt{pattern} contienne un ou des groupes (définis par les parenthèses \texttt{()}). Le résultat est une matrice dont la première colonne contient le \texttt{match} complet, les suivantes sont les \emph{matches} pour chaque groupe.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{telephones \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"02 23 23 35 45"}\NormalTok{, }\StringTok{"02{-}23{-}23{-}35{-}45"}\NormalTok{, }\StringTok{"Madrid"}\NormalTok{,}
                \StringTok{"02.23.23.35.45"}\NormalTok{, }\StringTok{"0223233545"}\NormalTok{, }\StringTok{"Milan"}\NormalTok{,}
                \StringTok{"02 23 23 35 45  "}\NormalTok{, }\StringTok{" 02 23 23 35 45"}\NormalTok{,}
                \StringTok{"Maison : 02 23 23 35 45"}\NormalTok{)}

\NormalTok{motif\_tel \textless{}{-}}\StringTok{ }\KeywordTok{str\_c}\NormalTok{(}\KeywordTok{str\_dup}\NormalTok{(}\StringTok{"([0{-}9]\{2\})[{-} }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{.]"}\NormalTok{, }\DecValTok{4}\NormalTok{),  }\StringTok{"([0{-}9]\{2\})"}\NormalTok{)}

\CommentTok{\# Extrait les numéros de téléphone}
\KeywordTok{str\_extract}\NormalTok{(telephones, motif\_tel)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "02 23 23 35 45" "02-23-23-35-45" NA               "02.23.23.35.45"
## [5] NA               NA               "02 23 23 35 45" "02 23 23 35 45"
## [9] "02 23 23 35 45"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_match}\NormalTok{(telephones, motif\_tel)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       [,1]             [,2] [,3] [,4] [,5] [,6]
##  [1,] "02 23 23 35 45" "02" "23" "23" "35" "45"
##  [2,] "02-23-23-35-45" "02" "23" "23" "35" "45"
##  [3,] NA               NA   NA   NA   NA   NA  
##  [4,] "02.23.23.35.45" "02" "23" "23" "35" "45"
##  [5,] NA               NA   NA   NA   NA   NA  
##  [6,] NA               NA   NA   NA   NA   NA  
##  [7,] "02 23 23 35 45" "02" "23" "23" "35" "45"
##  [8,] "02 23 23 35 45" "02" "23" "23" "35" "45"
##  [9,] "02 23 23 35 45" "02" "23" "23" "35" "45"
\end{lstlisting}

\hypertarget{manip_regex_stringr_match_all}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_match\_all()}}{La fonction str\_match\_all()}}\label{manip_regex_stringr_match_all}}

Si la chaîne de caractère contient plusieurs \emph{matches}, la fonction \texttt{str\_match()} ne retournera que le premier. Pour les avoir tous, il faut utiliser la fonction \texttt{str\_match\_all()}. Le résultat est une liste de la même longueur que le vecteur fourni à \texttt{string}. Chaque élément de la liste, lorsqu'il y a eu \emph{match} est une matrice comme celle retournée par \texttt{str\_match()}. S'il n'y a pas eu \emph{match}, l'élément de la liste retournée est \texttt{character(0)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{telephones \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"02 23 23 35 45"}\NormalTok{, }\StringTok{"02{-}23{-}23{-}35{-}45 / 02 23 23 35 35"}\NormalTok{,}
                \StringTok{"Madrid"}\NormalTok{, }\StringTok{"Maison : 02.23.23.35.45, Travail : 02 23 23 35 35"}\NormalTok{)}


\NormalTok{motif\_tel \textless{}{-}}\StringTok{ }\KeywordTok{str\_c}\NormalTok{(}\KeywordTok{str\_dup}\NormalTok{(}\StringTok{"([0{-}9]\{2\})[{-} }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{.]"}\NormalTok{, }\DecValTok{4}\NormalTok{),  }\StringTok{"([0{-}9]\{2\})"}\NormalTok{)}

\CommentTok{\# Extrait les numéros de téléphone}
\KeywordTok{str\_extract\_all}\NormalTok{(telephones, motif\_tel)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "02 23 23 35 45"
## 
## [[2]]
## [1] "02-23-23-35-45" "02 23 23 35 35"
## 
## [[3]]
## character(0)
## 
## [[4]]
## [1] "02.23.23.35.45" "02 23 23 35 35"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_match\_all}\NormalTok{(telephones, motif\_tel)[[}\DecValTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1] [,2] [,3] [,4] [,5] [,6]
\end{lstlisting}

\hypertarget{manip_regex_stringr_locate}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_locate()}}{La fonction str\_locate()}}\label{manip_regex_stringr_locate}}

Pour localiser la position de la première occurrence d'un motif dans une chaîne, on peut utiliser la fonction \texttt{str\_locate()}. Le résultat est une matrice d'entiers dont la première colonne indique la position de départ du \emph{match} et la seconde indique la position de fin du \emph{match}. En cas d'absence de \emph{match}, les deux valeurs valent \texttt{NA}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"pomme"}\NormalTok{, }\StringTok{"banane"}\NormalTok{, }\StringTok{"poire"}\NormalTok{, }\StringTok{"ananas"}\NormalTok{)}
\KeywordTok{str\_locate}\NormalTok{(fruits, }\StringTok{"a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      start end
## [1,]    NA  NA
## [2,]     2   2
## [3,]    NA  NA
## [4,]     1   1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# On peut définir le motif pour chaque élément du texte}
\KeywordTok{str\_locate}\NormalTok{(fruits, }\KeywordTok{c}\NormalTok{(}\StringTok{"p"}\NormalTok{, }\StringTok{"o"}\NormalTok{, }\StringTok{"p"}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      start end
## [1,]     1   1
## [2,]    NA  NA
## [3,]     1   1
## [4,]     1   1
\end{lstlisting}

\hypertarget{manip_regex_stringr_locate_all}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_locate\_all()}}{La fonction str\_locate\_all()}}\label{manip_regex_stringr_locate_all}}

Si on désire obtenir la position de toutes les occurrences d'un motif dans une chaîne, on peut utiliser la fonction \texttt{str\_locate\_all()}. Le résultat est une liste de la même longueur que le vecteur fourni à l'argument \texttt{string}. Chaque élément de la liste contient une matrice d'entiers dont la première colonne contient les positions de départ des \emph{matches} et la seconde les positions de fin. Chaque ligne de la matrice correspond à un \emph{match}. En cas d'absence de \emph{match} dans la chaîne, la matrice retournée est \texttt{matrix(0,\ nrow\ =\ 0,\ ncol\ =\ 2)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"pomme"}\NormalTok{, }\StringTok{"banane"}\NormalTok{, }\StringTok{"poire"}\NormalTok{, }\StringTok{"ananas"}\NormalTok{)}
\KeywordTok{str\_locate\_all}\NormalTok{(fruits, }\StringTok{"a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
##      start end
## 
## [[2]]
##      start end
## [1,]     2   2
## [2,]     4   4
## 
## [[3]]
##      start end
## 
## [[4]]
##      start end
## [1,]     1   1
## [2,]     3   3
## [3,]     5   5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# On peut définir le motif pour chaque élément du texte}
\KeywordTok{str\_locate\_all}\NormalTok{(fruits, }\KeywordTok{c}\NormalTok{(}\StringTok{"p"}\NormalTok{, }\StringTok{"o"}\NormalTok{, }\StringTok{"p"}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
##      start end
## [1,]     1   1
## 
## [[2]]
##      start end
## 
## [[3]]
##      start end
## [1,]     1   1
## 
## [[4]]
##      start end
## [1,]     1   1
## [2,]     3   3
## [3,]     5   5
\end{lstlisting}

\hypertarget{manip_regex_stringr_replace}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_replace()}}{La fonction str\_replace()}}\label{manip_regex_stringr_replace}}

La fonction \texttt{str\_replace()} remplace la première occurrence d'un motif \emph{matché} par la chaîne indiquée à l'argument \texttt{replacement}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{telephones \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"02/23/23/35/45"}\NormalTok{, }\StringTok{"02.23.23.35.45"}\NormalTok{, }\StringTok{"02 23 23 35 45"}\NormalTok{)}

\CommentTok{\# Remplacer la première occurrence du motif trouvée par un tiret}
\KeywordTok{str\_replace}\NormalTok{(telephones, }\StringTok{"[/ }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{.]"}\NormalTok{, }\StringTok{"{-}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "02-23/23/35/45" "02-23.23.35.45" "02-23 23 35 45"
\end{lstlisting}

Lorsqu'il y a des groupes (définis par des parenthèses), on peut faire référence aux groupes \emph{matchés} à l'aide de deux barres obliques inversées suivies du rang du groupe. Ainsi \texttt{\textbackslash{}\textbackslash{}1} fera référence au premier groupe matché.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"01. pomme"}\NormalTok{, }\StringTok{"02. pêches"}\NormalTok{, }\StringTok{"Maison"}\NormalTok{, }\StringTok{"03. bananes"}\NormalTok{)}
\KeywordTok{str\_replace}\NormalTok{(fruits, }\StringTok{"([0{-}9]\{2\}}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{. )([a{-}z])"}\NormalTok{, }\StringTok{"Debut}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{1Bonjour}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{2Fin"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "Debut01. BonjourpFinomme"   "Debut02. BonjourpFinêches" 
## [3] "Maison"                     "Debut03. BonjourbFinananes"
\end{lstlisting}

\hypertarget{manip_regex_stringr_replace_all}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_replace\_all()}}{La fonction str\_replace\_all()}}\label{manip_regex_stringr_replace_all}}

La fonction \texttt{str\_replace\_all()} permet de remplacer toutes les occurrences du motif trouvé par une chaîne de remplacement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{telephones \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"02/23/23/35/45"}\NormalTok{, }\StringTok{"02.23.23.35.45"}\NormalTok{, }\StringTok{"02 23 23 35 45"}\NormalTok{)}

\CommentTok{\# Remplacer toute les occurrences du motif trouvées par un tiret}
\KeywordTok{str\_replace\_all}\NormalTok{(telephones, }\StringTok{"[/ }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{.]"}\NormalTok{, }\StringTok{"{-}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] "02-23-23-35-45" "02-23-23-35-45" "02-23-23-35-45"
\end{lstlisting}

\hypertarget{manip_regex_stringr_split}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_split()}}{La fonction str\_split()}}\label{manip_regex_stringr_split}}

La fonction \texttt{str\_split()} permet de séparer une chaîne de caractères en plusieurs morceaux, suivant un motif donné. On peut préciser le nombre maximum de morceaux à retourner à l'aide de l'argument \texttt{n}. Cet argument vaut \texttt{Inf} par défaut, et retourne donc tous les morceaux qu"il est possible de trouver. Si la valeur donnée à \texttt{n} est plus petite que lon nombre de morceaux qu'il est possible de faire, le dernier élément du vecteur de caractères retourné contient encore des occurrences du motif. Si par contre la valeur fournie à \texttt{n} est plus grande, il n'y a pas de rajouts effectués par \texttt{R}.

Le résultat est une liste de la même longueur que le vecteur passé à l'argument \texttt{string}. Chaque élément de la liste contient les morceaux. Si l'argument \texttt{pattern} vaut \texttt{NA}, le résultat est le texte original, si \texttt{pattern} vaut \texttt{""}, le texte original est séparé par caractères.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"manger des chips"}\NormalTok{, }\StringTok{"José"}\NormalTok{,}
            \StringTok{"Considère qu\textquotesingle{}on n\textquotesingle{}est plus amis, Abitbol !"}\NormalTok{)}

\KeywordTok{str\_split}\NormalTok{(textes, }\StringTok{" "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "manger" "des"    "chips" 
## 
## [[2]]
## [1] "José"
## 
## [[3]]
## [1] "Considère" "qu'on"     "n'est"     "plus"      "amis,"     "Abitbol"  
## [7] "!"
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Avec n plus grand}
\KeywordTok{str\_split}\NormalTok{(textes, }\StringTok{" "}\NormalTok{, }\DataTypeTok{n =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] "manger" "des"    "chips" 
## 
## [[2]]
## [1] "José"
## 
## [[3]]
## [1] "Considère"            "qu'on"                "n'est"               
## [4] "plus amis, Abitbol !"
\end{lstlisting}

\hypertarget{manip_regex_stringr_split_fixed}{%
\subsection{\texorpdfstring{La fonction \texttt{str\_string\_fixed()}}{La fonction str\_string\_fixed()}}\label{manip_regex_stringr_split_fixed}}

Pour briser une chaîne de caractères en un nombre \texttt{n} de morceaux fixe en fonction d'un motif \texttt{pattern}, on peut utiliser la fonction \texttt{str\_string\_fixed()}. Le résultat est une matrice à \texttt{n}, colonnes. Chaque colonne de la matrice retournée correspond à un morceau. Si \texttt{n} est supérieur au nombre de morceaux qu'il est possible de créer, les colonnes de la matrice retournée sont complétées par la chaine vide \texttt{""}. En revanche, si \texttt{n} est inférieur au nombre de morceaux que l'on peut créer, la dernière colonne contiendra le reste de la chaîne n'ayant pas encore été découpée.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"manger des chips"}\NormalTok{, }\StringTok{"José"}\NormalTok{,}
            \StringTok{"Considère qu\textquotesingle{}on n\textquotesingle{}est plus amis, Abitbol !"}\NormalTok{)}

\CommentTok{\# Avec 4 morceaux}
\KeywordTok{str\_split\_fixed}\NormalTok{(textes, }\StringTok{" "}\NormalTok{, }\DataTypeTok{n =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      [,1]        [,2]    [,3]    [,4]                  
## [1,] "manger"    "des"   "chips" ""                    
## [2,] "José"      ""      ""      ""                    
## [3,] "Considère" "qu'on" "n'est" "plus amis, Abitbol !"
\end{lstlisting}

\hypertarget{manip_regex_base}{%
\section{\texorpdfstring{Quelques fonctions du \emph{package} \{\texttt{base}\}}{Quelques fonctions du package \{base\}}}\label{manip_regex_base}}

À titre informatif, le tableau ci-dessous présente les fonctions du \emph{package} \texttt{\{base\}} les plus importantes lorsque l'on manipule des expressions régulières. Les deux arguments principaux de texte et de motif sont nommés \texttt{text} et \texttt{pattern}, respectivement. Lorsqu'elle existe, la fonction équivalente dans \{\texttt{stringr}\} est donnée.

\begin{longtable}[]{@{}lll@{}}
\toprule
\begin{minipage}[b]{0.30\columnwidth}\raggedright
Fonction dans \{\texttt{string}\}\strut
\end{minipage} & \begin{minipage}[b]{0.30\columnwidth}\raggedright
Fonction dans \{\texttt{base}\}\strut
\end{minipage} & \begin{minipage}[b]{0.30\columnwidth}\raggedright
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\texttt{str\_which()}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\texttt{grep()}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
Retourne les indices des éléments du vecteur de texte pour lequel il y a un \emph{match}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\texttt{str\_detect()}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\texttt{grepl()}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
Retourne un vecteur de valeurs logiques de la même longueur que le vecteur \texttt{text}, qui indique, pour chaque élément, s'il y a eu \emph{match}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
Proche de \texttt{str\_locate()}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\texttt{regexpr()}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
Retourne un vecteur d'entiers de la même taille que \texttt{text} donnant la position du premier \emph{match} (ou \texttt{-1} s'il n'y a pas eu de \emph{match}), avec l'attribut \texttt{match.length}, un vecteur d'entiers donnant la longueur du text \emph{match} (ou \texttt{-1} si pas de \emph{match}).\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
Proche de \texttt{str\_locate\_all}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\texttt{gregexpr()}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
Même chose que \texttt{regexpr()}, mais le résultat est sous forme de liste, dont chaque élément correspond à la recherche du motif dans l'élément de \texttt{text} correspondant. Par ailleurs, les positions de départ de chaque \emph{match} sont données, et non pas seulement le premier rencontré. Il en est de même pour l'attribut \texttt{match.length}.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\texttt{regexec()}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
Retourne une liste de la même taille que \texttt{text} dont chaque élément est soit \texttt{-1} s'il n'y a pas eu de \texttt{match}, ou une séquence d'entiers avec les positions de début de \texttt{match} de toutes les sous-chaînes correspondant aux sous-expressions parenthésées de l'argument \texttt{pattern}, avec l'attribut \texttt{match.length}, qui est un vecteur donnant la longueu de chaque \emph{match}, ou \texttt{-1} s'il n'y en a pas eu.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Pour se fixer les idées, voici quelques exemples. La fonction \texttt{str\_which()}, qui permet d'indiquer les positions des éléments du vecteur donné en argument à \texttt{string} dans lesquels le motif est repéré :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{textes \textless{}{-}}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Je m’évanouis avant d’avoir pu vous révéler"}\NormalTok{,}
          \StringTok{"le nom du kidnappeur"}\NormalTok{, }\StringTok{"et/ou de la kidnappeuse"}\NormalTok{,}
          \StringTok{"du petit Doug Doug !"}\NormalTok{)}
\NormalTok{motif \textless{}{-}}\StringTok{ "ou"}

\KeywordTok{str\_which}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ textes, }\DataTypeTok{pattern =}\NormalTok{ motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] 1 3 4
\end{lstlisting}

La fonction \texttt{str\_detect()} qui retourne un vecteur de logique indiquant pour chaque élément du vecteur donné en argument à \texttt{string} si le motif a été trouvé :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_detect}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ textes, }\DataTypeTok{pattern =}\NormalTok{ motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1]  TRUE FALSE  TRUE  TRUE
\end{lstlisting}

La fonction \texttt{regexpr()} (dans \{\texttt{base}\}, donne un résultat relativement proche de celui de \texttt{str\_locate()} de \{\texttt{stringr}\}) :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{regexpr}\NormalTok{(}\DataTypeTok{pattern =}\NormalTok{ textes, }\DataTypeTok{text =}\NormalTok{ motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1] -1
## attr(,"match.length")
## [1] -1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_locate}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ textes, }\DataTypeTok{pattern =}\NormalTok{ motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      start end
## [1,]    10  11
## [2,]    NA  NA
## [3,]     4   5
## [4,]    11  12
\end{lstlisting}

La fonction \texttt{gregexpr()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gregexpr}\NormalTok{(}\DataTypeTok{pattern =}\NormalTok{ motif, }\DataTypeTok{text =}\NormalTok{ textes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] 10 33
## attr(,"match.length")
## [1] 2 2
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## 
## [[3]]
## [1] 4
## attr(,"match.length")
## [1] 2
## 
## [[4]]
## [1] 11 16
## attr(,"match.length")
## [1] 2 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str\_locate\_all}\NormalTok{(}\DataTypeTok{string =}\NormalTok{ textes, }\DataTypeTok{pattern =}\NormalTok{ motif)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
##      start end
## [1,]    10  11
## [2,]    33  34
## 
## [[2]]
##      start end
## 
## [[3]]
##      start end
## [1,]     4   5
## 
## [[4]]
##      start end
## [1,]    11  12
## [2,]    16  17
\end{lstlisting}

Et enfin, la fonction \texttt{regexec()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{regexec}\NormalTok{(}\DataTypeTok{pattern =}\NormalTok{ motif, }\DataTypeTok{text =}\NormalTok{ textes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1]]
## [1] 10
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 4
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
## 
## [[4]]
## [1] 11
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
\end{lstlisting}

\hypertarget{pour-aller-plus-loin}{%
\chapter{Pour aller plus loin}\label{pour-aller-plus-loin}}

Pour aller plus loin dans la pratique de R, voici quelques recommandations. Cette partie est très succincte, et sera (je l'espère) complétée à l'avenir. Il s'agit surtout pour moi d'un pense-bête pour les futures versions de ces notes de cours. Si vous pensez qu'il manque une partie crutiale pour la pratique de R (en se limitant à la manipulation de données, je ne tiens pas à faire figurer de méthodes statistiques avancées dans ces notes), n'hésitez pas à m'envoyer un e-mail pour m'en faire part.

\hypertarget{travailler-par-projets-avec-rstudio}{%
\section{Travailler par projets, avec RStudio}\label{travailler-par-projets-avec-rstudio}}

Pour travailler sereinement avec R, la pratique qui me convient le mieux est de créer des fichiers de projets sur RStudio. Ce faisant, il est plus facile de partager ses codes au sein d'un groupe. Il n'est plus nécessaire de soucier d'éventuels changements de liens pour charger des documents dans R. Pas de problèmes non plus pour sauvegarder au bon endroit des résultats issus d'analyses réalisées avec R.

Par ailleurs, il est possible de lancer plusieurs projets sur la même machine (pratique quand on doit travailler avec plusieurs groupes sur des sujets différents).

Pour plus de détails : \url{https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects}

\hypertarget{r-markdown}{%
\section{R Markdown}\label{r-markdown}}

Ces notes de cours ont été rédigées directement dans RStudio. Le langage d'écriture est le Rmarkdown. Pour réaliser des rapports, ce langage est très utile. Il permet de rédiger le contenu du rapport en alternant du texte et des résutats d'analyses menées sous R, le tout dans le même environnement.

Avec R markdown, il est possible d'exécuter des codes dans de nombreux langages (comme du Python, du D3, du SQL, etc.). Il est même possible d'écrire des formules en LaTeX (sans souffrir de la syntaxe horrible propre à ce langage).

Pour plus de détails : \url{https://rmarkdown.rstudio.com/}

\hypertarget{modification-de-plusieurs-colonnes}{%
\section{Modification de plusieurs colonnes}\label{modification-de-plusieurs-colonnes}}

Il existe dans l'environnement \texttt{tidyverse} une fonction qui permet de modifier plusieurs colonne d'un coup : \texttt{across()}. L'utilisation de cette fonction devrait faire l'objet d'une partie dans cette ouvrage.

\url{https://dplyr.tidyverse.org/reference/across.html}

\hypertarget{pense-buxeate}{%
\chapter{Pense-bête}\label{pense-buxeate}}

Cette dernière partie propose des codes R que j'utilise régulièrement mais dont j'oublie systématiquement les détails. Il s'agit de fait d'une partie très destructurée de ces notes et se destinent plutôt à mon usage personnel.

\hypertarget{installer-un-package-depuis-sa-source}{%
\section{\texorpdfstring{Installer un \emph{package} depuis sa source}{Installer un package depuis sa source}}\label{installer-un-package-depuis-sa-source}}

Parfois, un \emph{package} n'est plus disponible sur CRAN ou GitHub, mais il est toutefois possible de l'installer directement depuis sa source. Dans ce cas, je télécharge la source et utilise le code suivant :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"chemin\_vers\_source"}\NormalTok{, }\DataTypeTok{repos =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{type =} \StringTok{"source"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{references}{%
\chapter*{References}\label{references}}
\addcontentsline{toc}{chapter}{References}

\hypertarget{refs}{}
\begin{cslreferences}
\leavevmode\hypertarget{ref-Anderson_2012_A_Quick}{}%
Anderson, Sean. 2012. ``A Quick Introduction to Plyr.'' \url{http://seananderson.ca/courses/12-plyr/plyr_2012.pdf}.

\leavevmode\hypertarget{ref-Bivand_2008_Applied}{}%
Bivand, Roger S, Edzer J Pebesma, and Virgilio Gómez-Rubio. n.d. \emph{Applied Spatial Data Analysis with R}. Vol. 747248717. Springer.

\leavevmode\hypertarget{ref-Burns_2011_R}{}%
Burns, Patrick. 2011. ``The R Inferno.'' \url{http://www.burns-stat.com/pages/Tutor/R_inferno.pdf}.

\leavevmode\hypertarget{ref-Chang_2013_R}{}%
Chang, W. 2013. \emph{\texttt{R} Graphics Cookbook}. Oreilly and Associate Series. O'Reilly Media, Incorporated.

\leavevmode\hypertarget{ref-Charpentier_2014_Computational}{}%
Charpentier, Arthur. 2014. \emph{Computational Actuarial Science with \texttt{R}}. Chapman; Hall.

\leavevmode\hypertarget{ref-Dalgaard_2008_Introductory}{}%
Dalgaard, P. 2008. \emph{Introductory Statistics with R}. Statistics and Computing. Springer. \url{http://books.google.fr/books?id=YI0kT8cuiVUC}.

\leavevmode\hypertarget{ref-Elo_2001_Racial}{}%
Elo, IT, G Rodgriguez, and H Lee. 2001. ``Racial and Neighborhood Disparities in Birth Weight in Philadelphia.'' In \emph{Annual Meeting of the Populations Association of America, Washington Dc. Paper Presented, Under Revision for Publication}.

\leavevmode\hypertarget{ref-Farnsworth_2008_Econometrics}{}%
Farnsworth, Grant V. 2008. ``Econometrics in \texttt{R}.'' \url{http://cran.r-project.org/doc/contrib/Farnsworth-EconometricsInR.pdf}.

\leavevmode\hypertarget{ref-Goulet_2014_Introduction}{}%
Goulet, Vincent. 2014. \emph{Introduction à La Programmation En \texttt{R}}. \url{http://cran.r-project.org/doc/contrib/Goulet_introduction_programmation_R.pdf}.

\leavevmode\hypertarget{ref-grolemund_2018_r}{}%
Grolemund, Garrett, and Hadley Wickham. 2018. \emph{R for Data Science}. O'Reilly Media, Incorporated.

\leavevmode\hypertarget{ref-Lafaye_2011_Logiciel}{}%
Lafaye de Micheaux, P., R. Drouilhet, and B. Liquet. 2011. \emph{Le Logiciel \texttt{R}: Maîtriser Le Langage - Effectuer Des Analyses Statistiques}. Statistique et Probabilités Appliquées. Springer.

\leavevmode\hypertarget{ref-Lovelace_2014_Consistent}{}%
Lovelace, Robin. 2014. ``Consistent Naming Conventions in R.'' \url{http://robinlovelace.net/r/2014/07/15/naming-conventions-r.html}.

\leavevmode\hypertarget{ref-Matzner_2007_Regression}{}%
Matzner-Løber, É. 2007. \emph{Régression: Théorie et Applications}. Statistique et Probabilités Appliquées. Physica-Verlag. \url{http://books.google.fr/books?id=Kz-cgsn634kC}.

\leavevmode\hypertarget{ref-Paradis_2002_R}{}%
Paradis, Emmanuel. 2002. ``R Pour Les débutants.'' \url{http://cran.r-project.org/doc/contrib/Paradis-rdebuts_fr.pdf}.

\leavevmode\hypertarget{ref-Ross_2014_Vectorization}{}%
Ross, Noam. 2014. ``Vectorization in R: Why?'' \url{http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html}.

\leavevmode\hypertarget{ref-Sanchez_2013_Handling}{}%
Sanchez, Gaston. 2013. \emph{Handling and Processing Strings in \texttt{R}}. Berkeley: Trowchez Editions. \url{http://gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf}.

\leavevmode\hypertarget{ref-schwabish2014economist}{}%
Schwabish, Jonathan A. 2014. ``An Economist's Guide to Visualizing Data.'' \emph{Journal of Economic Perspectives} 28 (1): 209--34.

\leavevmode\hypertarget{ref-Wickham_2011_Split}{}%
Wickham, Hadley. 2011. ``The Split-Apply-Combine Strategy for Data Analysis.''

\leavevmode\hypertarget{ref-Wickham_2014_Advanced_R_Functionals}{}%
---------. 2014. ``Functionals.'' In \emph{Advanced \texttt{R}}. \url{http://adv-r.had.co.nz/Functionals.html}.

\leavevmode\hypertarget{ref-Xie_r2014_require}{}%
Xie, Yihui. 2014. ``Library() Vs Require() in R. R-Bloggers.'' \url{http://www.r-bloggers.com/library-vs-require-in-r/}.

\leavevmode\hypertarget{ref-Zuur_2009_Beginner}{}%
Zuur, Alain, Elena N Ieno, and Erik Meesters. 2009. \emph{A Beginner's Guide to \texttt{R}}. Springer.
\end{cslreferences}

\end{document}
