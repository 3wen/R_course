---
title: "Notes de cours de R - Version 2"
author: "Ewen Gallic"
date: "Septembre 2020"
knit: "bookdown::render_book"
documentclass: book
bibliography: [biblio.bib]
biblio-style: apalike
link-citations: yes
colorlinks: yes
lot: yes
lof: yes
fontsize: 11pt
monofont: "Source Code Pro"
monofontoptions: "Scale=0.7"
github-repo: 3wen/R_course
site: bookdown::bookdown_site
repo: https://github.com/3wen/R_course
output:
  bookdown::gitbook:
    css: styles/style.css
    highlight: default
    config:
      toc_depth: 5
      toc:
        collapse: subsubsection
        scroll_highlight: yes
        before: null
        after: null
      search: yes
      edit: https://github.com/3wen/R_course/edit/master/%s
      sharing: 
        github: yes
  bookdown::pdf_book:
    toc_depth: 4
    highlight: default
    keep_tex: yes
    includes:
      in_header: styles/mystyle_books.tex
  bookdown::epub_book:
    stylesheet: styles/style.css
---

```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}

library(knitr)
library(tidyverse)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               # comment=NA,
               message=FALSE,
               warning=FALSE,
               size="scriptsize",
               tidy.opts=list(width.cutoff=80))
opts_knit$set(width=80)


options(bookdown.post.latex = function(x) {
  # x is the content of the LaTeX output file
  gsub('^\\\\(begin|end)\\{verbatim\\}$', '\\\\\\1{lstlisting}', x)
})


```



# Avant Propos {-}

<!-- ```{r, echo=F} -->
<!-- invisible(py_config()) -->
<!-- ``` -->

Ces notes de cours ont été réalisées dans le cadre d'un enseignement à R adressé à des étudiants en Économie. La première version remonte à 2014. Le contenu était proposé à des étudiant•e•s de Master à la Faculté de Sciences Economiques de l'Université de Rennes 1. En six ans, le langage R a beaucoupé évolué, notamment avec l'émergence d'une collection de packages à destination de la _data science_ : [`tidyverse`](https://www.tidyverse.org/). Les notes de cours de la première version se devaient être dépoussiérées pour présenter ce que j'appelle les nouveautés du langage. Cette refonte partielle de la première version s'effectue dans le cadre d'un enseignement à destination des étudiant•e•s de 3e année de Licence et Economie et Gestion à la [Faculté d'Economie et de Gestion](https://feg.univ-amu.fr/) d'Aix-Marseille Université.


## Objectifs

Cet ouvrage a pour but l'initiation au logiciel statistique et au langage informatique portant le même nom, R, afin d'être capable de s'en servir de manière efficace et autonome. Le lecteur ou la lectrice peut exécuter tous les exemples fournis (et est vivement encouragé•e à le faire). Les exercices viennent clore certains chapitres. Les corrections sont disponibles à l'adresse suivante : [http://egallic.fr/enseignement/](http://egallic.fr/enseignement/).

## À qui s'adressent ces notes ?

Dans un premier temps, cet ouvrage s'adresse aux débutant•e•s qui souhaitent apprendre les bases du langage et du logiciel R. Le lecteur ou la lectrice initié•e peut également s'appuyer sur ces note afin de retrouver des rappels sur des notions basiques.

## Remerciements

Ce manuel est le produit de plusieurs années de pratique, qui ont débutées en 2011 grâce à Christophe Cariou, que je tiens à remercier pour m'avoir soufflé l'idée d'utiliser R pour réaliser des projets amusants sur lesquels nous avons travaillés. Un énorme merci à Arthur Charpentier pour la quantité de savoir et d'astuces fournis sur l'utilisation de R, et qui est à l'origine de nombreux exemples présents dans ces notes de cours. Merci aussi à François Briatte de m'avoir introduit à de nouveaux horizons dans le langage, et aussi à Gauthier Vermandel pour ses nombreux conseils. Merci également à Julien-Yacine Chaqra pour ses suggestions et relectures. Je remercie également les étudiant•e•s qui au fil des années permettent de modifier le contenu de ce cours. Enfin, merci à toute la communauté R d'exister et de proposer ce partage de savoir librement et gratuitement.


# Introduction

Ce document est construit principalement à l'aide des références suivantes :

- @grolemund_2018_r, @Lafaye_2011_Logiciel, @Farnsworth_2008_Econometrics, @Charpentier_2014_Computational, @Paradis_2002_R, @Zuur_2009_Beginner, @Goulet_2014_Introduction

## Historique

Dans le milieu des années 1970, une équipe de chercheurs de AT&T Bell Laboratories, composée de John Chambers, Douglas Bates, Rick Becker, Bill Cleveland, Trevor Hastie, Daryl Pregibon et Allan Wilks, développe un langage de programmation appelé `S` (la lettre `S` faisant référence à _statistics_). Il s'agit d'un langage permettant de manipuler les données et d'effectuer des analyses statistiques et graphiques. Dans le milieu des années 1990, Ross Ihaka et Robert Gentleman créént le `R` au département de Statistiques de l'Université d'Auckland. Ce langage et logiciel, inspiré du `S` et de `Scheme` est distribué sous les termes de la GNU _General Public Licence_. La `R` Development Core Team} se charge de distribuer et de développer le logiciel `R`. De nombreux contributeurs à travers le monde participent au développement de `R`.

## Présentation de l'espace de travail

### La console et les fenêtres de script

`R` est un langage interprété, c'est-à-dire qu'il nécessite un interprète pour exécuter les commandes, et n'a pas de phase de compilation. Il existe plusieurs façons de travailler avec `R` : soit directement dans la console (qui est un interprète), soit dans une fenêtre de script (Fig~\@ref(fig:intro-script)). La seconde méthode est fortement conseillée, puisqu'elle permet de sauvegarder le code et d'y accéder facilement pour une utilisation utlérieure. De plus, il existe souvent des raccourcis claviers, en fonction de l'éditeur utilisé, qui permettent de soumettre le code de la fenêtre de script à l'interprète. Les fichiers de code que l'on sauvegardent possèdent l'extension `.R`.



```{r intro-script, echo=F, out.width = "40%", fig.cap="Fenêtre de script sous Mac OS Catalina", fig.align='center', fig.pos='H'}
include_graphics("figs/fenetre_script.png")
```

```{r intro-console, echo=F, out.width = "40%", fig.cap="Console sous Mac OS Catalina", fig.align='center', fig.pos='H'}
include_graphics("figs/console_mac.png")
```

Dans la console (Fig~\@ref(fig:intro-console)), à la fin de l'affichage d'ouverture de session R, se trouve le caractère `>` (_prompt_), invitant l'utilisateur•trice à inscrire une commande. Les expressions sont évaluées une fois qu'elle sont soumises (à l'aide de la touche `ENTREE`) et le résultat est donné, lorsqu'il n'y a pas d'erreur dans le code, juste en dessous :
```{r intro_premiere_commande}
2+1
```


Par la suite, le symbole d'invite de commande ne sera plus affichée dans les cadres de code, afin de permettre au lecteur ou à la lectrice de reproduire facilement les résultats obtenus en copiant et collant les instructions. Par ailleurs, dans ce document, contrairement à ce que l'on peut observer dans la console `R`, le résultat de l'évalutation de l'expression `2+1` est précédé de deux croisillons. Le croisillon `#` indique à `R` de ne pas evaluer le code qui suit, jusqu'à la fin de la ligne. Il permet donc de placer des lignes en commentaires.
```{r}
# Des commentaires
2+1 # +1
```

Lorsqu'on travaille dans une fenêtre de script, la combinaison de touches pour soumettre le code dépend du système d'exploitation et de l'éditeur de texte utilisé (`CTRL+R` sous Windows, `CMD+ENTER` sous Mac OS).


### Les variables

#### Assignation

De base, le résultat d'une évaluation n'est pas enregistré, et est de fait perdu une fois affiché. Cependant, dans la plupart des cas, il est utile de conserver la sortie dans une variable. Il suffit alors d'attribuer un nom et un contenu à un objet. La flèche d'affectation `<-` permet cela. L'affichage du contenu de l'objet `x` se fait en inscrivant son nom et en l'évaluant.

```{r intro_stock}
x <- 2+1
x
```

```{block2, type='remarque', echo=TRUE}
Il est possible d'afficher le contenu de l'objet en entourant l'expression de son affectation à une valeur par des parenthèses. La syntaxe est la suivante :

`(x <- 2+1)`

```

```{block2, type='remarque', echo=TRUE}
Comme de nombreux langages de programmation utilisent le symbole `=` pour assigner une valeur à un objet, cette pratique est permise dans beaucoup de cas en `R`, mais il arrive qu'elle ne produise pas l'effet escompté dans d'autres cas de figures.

```

#### Conventions de nommage {#introduction-espace-nommage}

Le nom d'une variable doit être composé de caractères alphanumériques ou du point ou du trait de soulignement uniquement. Il ne doit pas commencer par un chiffre ou contenir d'espace, sauf s'il est entouré par des guillemets. Il est important de noter que ces noms sont sensibles à la casse, c'est à dire qu'une distinction entre les majuscules et les minuscules a lieu. Il existe plusieurs pratiques pour nommer des variables, et il n'est pas rare de voir des combinaisons de ces pratiques. Un billet de Robin Lovelace explique les différences entre les méthodes et propose d'en adopter une seule @Lovelace_2014_Consistent :

- tout en minuscule : `nomvariable` ;
- séparation par un point : `nom.variable` ;
- séparation par un trait de soulignement : `nom_variable` ;
- lowerCamelCase, avec la première lettre en minuscule : `nomVariable` ;
- PascalCase, avec la première lettre en majuscule : `NomVariable`.


Robin Lovelace propose d'avoir recours aux traits de soulignement, pour la facilité de lecture qu'ils permettent, et par leur emploi par quelques grands noms de la communauté `R` (comme Hadley Wickham^[[http://had.co.nz/](http://had.co.nz/)] ou Yihui Xie^[[http://yihui.name/](http://yihui.name/)]).

#### Les objets en mémoire


Pour lister les éléments de la session `R` stockés en mémoire de l'ordinateur, il faut appeler la fonction `ls()` :
```{r}
ls()
```

#### Modidification, suppression

Il est important de noter que l'assignation du contenu d'un objet à un autre objet permet d'obtenir deux objets distincts. Ainsi, si un des deux objets est modifié, cela n'affecte pas l'autre.
```{r intro_copie}
premier_objet <- 2+1
second_objet <- premier_objet # Assigne la valeur de premier_objet
# à second_objet
premier_objet <- 2+2 # Change la valeur de premier_objet
# Puis affiche le contenu des deux objets :
premier_objet # Le résultat doit être 4
second_objet # Le résultat doit être 3
```

Pour supprimer un objet, il faut utiliser la fonction `rm()` :

```{r intro_rm, error=TRUE}
premier_objet # L'objet existe
rm(premier_objet) # Suppression
premier_objet # Son affichage provoque un message d'erreur
```



### Les _packages_

Les fonctions de base de `R` sont contenues dans un _package_ nommé `{base}` (lorsque qu"un nom de _package_ sera mentionné dans ces notes, il sera entouré d'accolades). Celui-ci est chargé automatiquement à l'ouverture de `R`, en même temps qu'une poignée d'autres. Les _packages_ sont des jeux de fonctions, accompagnés de fichiers d'aides, parfois de jeux de données, qui sont mis à disposition des utilisateur•rice•s. La liste des _packages_ chargés en mémoire par défaut s'obtient par l'instruction suivante :
```{r intro_package}
getOption("defaultPackages")
```

Les fonctions qui ne sont pas dans les _packages_ en mémoire nécessitent d'être chargées. Mais avant de pouvoir le faire, encore faut-il que le _package_ soit installé. Si ce n'est pas le cas, il suffit de faire appel à l'instruction _install.packages()_, puis de choisir, selon l'éditeur utilisé, un site miroir. Par exemple, pour installer le _package_ {`ggplot2`}, qui permet de réaliser des graphiques plus ou moins sophistiqués, l'instruction est la suivante :
```{r, eval=FALSE}
install.packages("ggplot2")
```

Pour charger le _package_ en mémoire et ainsi avoir accès aux fonctions que celui-ci contient, l'instruction est `library()`.
```{r intro_package_library}
library("ggplot2")
```

L'instruction `require()`, qui tente de charger le _package_ et retourne une valeur logique indiquant le succès ou l'échec de l'opération, est utilisée par certains, mais Yihui Xie indique sur un billet publié sur le site R-bloggers @Xie_r2014_require que lors d'un échec du chargement du _package_ en début de fichier, l'emploi des fonctions contenues dans ce _package_ échouera, tout simplement.



```{r intro-require, echo=F, out.width = "40%", fig.cap="require() versus library().", fig.align='center', fig.pos='H'}
include_graphics("figs/require_vs_library.png")
```


Certains _packages_ ne sont pas disponible sur CRAN (soit ils ne le seront jamais, soit il sont en cours de développement). Ils peuvent en revanche être mis à disposition sur GitHub. Pour installer un _package_ depuis GitHub, on peut faire appel à la fonction `install_github()` du _package_ {`devtools`} (il faut au préalable avoir installé {`devtool`} depuis CRAN). Admettons que le _package_ `rJordan` à installer depuis GitHub est mis à disposition sur un répertoire de l'utilisateur•trice `toto`, la syntaxe à respecter est la suivante :
```{r install_git, eval=FALSE}
# install.packages("devtools) # Installer devtools si necessaire
devtools::install_github("toto/rJordan")
```


### L'aide

Pour conclure cette introduction, il semble important de mentionner la présence de l'aide en ligne. L'accès aux fichiers d'aide pour une fonction dont on connaît le nom, par exemple la fonction logarithme, peut se faire de plusieurs manières :

```{r intro_aide}
?log # Première manière
help(log) # Seconde manière
help("log") # Troisième manière
```

Pour trouver toutes les fonctions dont le nom contient une cha^iine de cractètres donnée, on peut utiliser la fonction `apropos()` :
```{r intro_a_propos}
apropos("log")
```

Les fichiers sont souvent riches d'informations, très bien décrits, et proposent des exemples d'utilisation.

Par ailleurs, la communauté `R` est importante, et rares sont les questions sans réponses sur les _mailing-lists_ ou les pages de [Stack Overflow](http://stackoverflow.com/questions/tagged/r)}. Si vous n'arrivez pas à résoudre un problème après avoir parcouru StackOverflow, vous pouvez toujours y poser une question pour que la communauté tente de vous aider. Vous pouvez également rejoindre le groupe de discussion des utilisateur•rice•s de R francophones sur Slack : [Grrr](https://r-grrr.slack.com/). Dans les deux cas, pour permettre aux autres de vous aider : proposez un exemple reproductible. Pour ce faire, veuillez consulter par exemple ce [tutoriel](https://www.tidyverse.org/help/). N'hésitez pas à suivre les résolutions de problèmes des autres, cela favorise l'apprentissage de techniques efficaces et fais progresser la pratique du langage.

## Un environnement de développement : RStudio



Bien qu'il soit possible d'utiliser `R` _via_ le terminal, ou _via_ l'éditeur installé par défaut, il est également possible d'utiliser un environnement de développement, comme RStudio. La version _desktop_, gratuite et en _open source_, est téléchargeable à l'adresse suivante : https://www.rstudio.com/.

Pour utiliser RStudio, il est nécessaire d'avoir au préalable installé R.

La figure ci-dessous montre l'interface graphique proposée par RStudio. Cette interface est composée de quatre panneaux : un éditeur, une console, une fenêtre historique et environnement, et une dernière avec divers onglets (fichiers, graphiques, _packages_, aide et un navigateur interne).

```{r intro-rstudio, echo=F, out.width = "100%", fig.cap="Interface graphique de RStudio.", fig.align='center', fig.pos='H'}
include_graphics("figs/rstudio.png")
```


On peut noter que RStudio dispose d'un colorateur syntaxique et propose l'auto-complétion (à l'aide de la touche `TAB`).


# Données

L'objectif de R étant d'analyser des données, il est tout aussi important de connaître les différents types qu'elles peuvent prendre que de savoir les manipuler. Ce chapitre présente dans un premier temps les objets en R, puis s'intéresse à l'importation et à l'exportation de données, et finit par la manièere de créer et de manipuler les différents types de données.

## Types de données


R gère des objets, qui sont caractérisés par un *nom*, un *mode*, une *longueur* et un *contenu*.


### Mode {#donnees-mode}


Le mode d'un objet est la nature des éléments qui le composent, leur type. On y accède par la fonction `mode()` ou encore `typeof()`.
```{r donnees_mode}
a <- 2
mode(a)
```

Il existe quatre principaux types :

- _numeric_ (numérique) :
    On distingue deux types numériques, à savoir les _integers_ (entiers) et les _double_ ou _real_ (réels).
    ```{r donnees_type_num}
    a <- 2.0
    typeof(a)
    is.integer(a) # a est un réel, pas un entier.
    b <- 2
    typeof(b)
    c <- as.integer(b)
    typeof(c)
    is.numeric(c) # c est bien un numérique.
    ```
    La variable `c` a la même valeur que la variable `b`, mais elle nécessite un stockage en mémoire moins important [@Lafaye_2011_Logiciel]. La fonction `is.integer()` retourne `TRUE` lorsque l'objet qui est fourni en argument est un entier, `FALSE` sinon. De manière plus générale, les instructions commençant par `as.` et suivies du nom d'un mode permettent de tester si l'objet indiqué en argument est de ce mode.
- _character_  (caractère) :
    Les chaînes de caractères sont placées entre guillemets simples `'` ou doubles `"`.
    ```{r donnees_type_char}
    a <- "Hello world!"
    a
    typeof(a)
    ```
- _logical_ (logique, booléen) :
    Les données de type logique peuvent prendre deux valeurs : `TRUE` ou `FALSE`. Elles répondent à une condition logique.
    ```{r donnees_type_logique}
    a <- 1 ; b <- 2
    a < b
    a == 1 # Test d'égalité
    a != 1 # Test d'inégalité
    is.character(a)
    (a <- TRUE)
    (a <- T)
    ```
    Comme le montre l'exemple ci-dessus, il est possible d'abréger `TRUE` en `T` ; il en est de même pour `FALSE`, qui peut s'abéger en `F`.

```{block2, type='remarque', echo=TRUE}
Il peut parfois être pratique d'utiliser le fait que `TRUE` peut être automatiquement converti en 1 et `FALSE` en 0.
`TRUE + TRUE + FALSE + TRUE*TRUE` retournera 3.

```

- _complex_ (complexe) :
    Les nombres complexes sont caractérisés par leur partie réelle, que l'on peut obtenir à l'aide de la fonction `Re()` ; et par leur partie imaginaire, que l'on obtient grâce à la fonction `Im()`. On créé un nombre complexe à l'aide de la lettre `i`.
    ```{r donnees_types_complexe}
    1i
    z <- 2+3i
    Re(z) # Partie réelle de z
    Im(z) # Partie imaginaire de z
    Mod(z) # Module de z
    Arg(z) # Argument de z
    ```

### Longueur

La longueur d'un objet correspond au nombre d'éléments qu'il contient. On utilise la fonction `length()` pour connaître la longueur d'un objet.
```{r donnees_longueur}
a <- 1
length(a)
```

Les données manquantes `NA` (_not available_) sont considérées comme étant de type `logical` par R.

```{r donnees_na}
typeof(x)
is.na(x)
```

### L'objet vide


L'objet `NULL` représente le vide en R. Il est de mode `NULL` et de longueur 0. Il ne faut cependant pas le confondre avec un objet vide.
```{r donnees_null}
x <- NULL
typeof(x)
length(x)
is.null(x)
is.null(list()) # La liste vide n'est pas NULL
```

## Structure des données {#structures}


Il existe de nombreuses structures servant à organiser les données dans R. Cette introduction à R n'a pas pour vocation de lister toutes celles qui existantent, aussi, seules quelques unes (les principales à mes yeux) sont présentées dans cette section. Pour connaître la structure d'un objet, il est possible d'utiliser la fonction ` `class()`.

### Structures de base

#### Vecteurs

Les vecteurs sont extrêmement employés en R, et sont composés de données de mêmes types. La création d'un vecteur peut se faire à l'aide de la fonction de concaténation `c()`.
```{r donnees_vecteurs}
c(1,2,3)
```
```{block2, type='remarque', echo=TRUE}
Dans l'affichage de la console, `[1]` indique le rang de l'élément qui le suit dans le vecteur dont le contenu est affiché. La Section\ \@ref(manip-acces)) permettra de mieux comprendre cet affichage.
```

Il est possible d'attribuer un nom aux éléments d'un vecteur, soit lors de la création, soit _a posteriori_, en utilisant la fonction `names()`.
```{r donnees_vecteurs_noms}
a <- c(nom = "Piketty", prenom = "Thomas", annee_naissance = "1971")
a
b <- c("Piketty", "Thomas", "1971")
b
names(b) <- c("nom", "prenom", "annee_naissance")
b
```

Lorsque plusieurs types de données sont mélangés lors de la création du vecteur, R convertit les données dans le type le plus général.
```{r donnees_vecteurs_conv}
c("deux", 1, TRUE)
```

La fonction `is.vector()` retourne `TRUE` si l'objet passé en argument est un vecteur.
```{r donnees_vecteurs_test}
a <- c(2,1)
is.vector(a)
```


La fonction `length()` donne le nombre d'éléments qui composent le vecteur.
```{r donnees_vecteurs_test_2}
a <- c(2,1)
length(a)
```

#### Facteurs

Les travaux d'économétrie requièrent souvent l'emploi de variables *qualitatives*. R possède une structure qui gère ces variables : `factor`. On utilise la fonction `factor()` pour encoder un vecteur en facteur.
```{r donnees_facteurs}
pays <- factor(c("France", "France", "Chine", "Espagne", "Chine"))
pays
class(pays)
```

La fonction `levels()` retourne les niveaux du facteur.
```{r donnees_facteurs_levels}
levels(pays)
```

Lors des analyses, il arrive de vouloir choisir la modalité de réféfence plutôt que de laisser R le faire automatiquement. Il suffit alors d'utiliser la fonction `relevel()`. Il faut toutefois ne pas oublier de réassigner le résultat à l'objet !
```{r donnees_facteurs_relevel}
pays <- relevel(pays, ref = "Espagne")
pays
```


Si les variables catégorielles sont ordonnées, R propose la fonction `ordered()`.
```{r donnees_facteurs_ordered, tidy=TRUE}
revenus <- 
  ordered(c("<1500", ">2000", ">2000", "1500-2000", ">2000", "<1500"),
          levels = c("<1500", "1500-2000", ">2000"))
revenus
```


#### Dates {#structure-dates}

On note trois principales classes pour représenter des dates en R :

- *Date* : adapté pour les dates, uniquement celles pour lesquelles on ne possède pas d'informations à propos de l'heure (e.g., `1977-05-27`);
- *POSIXct* et *POSIXlt* : pour les dates avec des heures (e.g., `1977-05-27 20:00:00`).

##### Dates


Les dates sont stoquées comme le nombre de jours depuis `1970-01-01`, avec des valeurs négatives pour des dates antérieures. Le format d'affichage est celui du calendrier grégorien.


La fonction `as.Date()` convertit une chaîne de caratcères en date. Si le format est de la forme `%Y-%m-%d` ou `%Y/%m/%d` (avec `%Y` l'année avec le siècle, `%m` le mois sur deux chiffres et `%d` le jour sur deux chiffres), il n'est pas nécessaire de renseigner l'argument `format` de la fonction. L'argument `origin` permet quant à lui de préciser une origine différente de `1970-01-01`.
```{r manip_dates_classes}
(d <- as.Date("2020-10-21"))
class(d)
unclass(d)

# La date du jour
as.Date(Sys.time())

# Avec un format non standard
(d <- as.Date("2020 21 10", format = ("%Y %d %m")))
(d <- as.Date("21 Octobre, 2020", format = ("%d %B, %Y")))
```


La fonction `unclass()` utilisée dans le précédent exemple permet de voir la valeur stockée en interne.

Comme on peut le voir dans le précédent exemple, l'argument `format` a été utilisé. Cet argument permet de préciser comment la date est écrite dans la chaîne de caractères, pour que la conversion en objet de classe `date` soit possible. Cette conversion est réalisée, en interne, par la fonction`strptime()`. La page d'aide de cette fonction (`?strptime`) donne les différents codes qui spécifient les formats de date. Attention, certains de ces formats dépendent d'arguments locaux à la machine (des exemples sont donnés plus loin).

```{r manip_dates_classes_exemple, echo=FALSE}
d <- as.POSIXct("2020-10-21 13:55:44")
```

Les codes spécifiant les formats de date sont consignés dans le tableau suivant.

| Code | Description | Exemple |
|------|-------------|---------|
| `%a` | Abréviation du jour de la semaine (dépend du lieu) | `r format(d, "%a")` |
| `%A` | Jour de la semaine complet (dépend du lieu) | `r format(d, "%A")` |
| `%b` | Abréviation du mois (dépend du lieu)  | `r format(d, "%b")` |
| `%B` | Nom du mois complet (dépend du lieu)  | `r format(d, "%B")` |
| `%c`| Date et heure (dépend du lieu) au format `%a %e %b %H:%M:%S %Y` |  `r format(d, "%c")` |
`%C` | Siècle (00-99) -1 (partie entière de la division de l'année par 100) | `r format(d, "%C")` |
| `%d`  | Jour du mois (01–31)  | `r format(d, "%d")` |
| `%D` | Date au format `%m/%d/%y`  | `r format(d, "%D")` |
`%e` | Jour du mois en nombre décimal (1--31) | `r format(d, "%e")` |
| 
| `%F` | Date au format `%Y-%m-%d` | `r format(d, "%F")` |
| `%h` | Même chose que `%b`  | `r format(d, "%h")` |
| `%H` | Heure (00–24)  | `r format(d, "%H")` |
| `%I` | Heure (01--12) | `r format(d, "%I")` |
| `%j` | Jour de l'année (001--366) | `r format(d, "%j")` |
| `%m` | Mois (01–12)   | `r format(d, "%m")` |
| `%M` | Minute (00-59) | `r format(d, "%M")` |
| `%n` | Retour à la ligne en _output_, caractère blanc en _input_ | `r format(d, "%n")`|
| `%p` | AM/PM | `r format(d, "%p")` |
| `%r` | Heure au format 12 AM/PM | `format(d, "%r")` |
| `%R` | Même chose que `%H:%M` | `r format(d, "%R")` |
| `%S` | Seconde (00-61)  | `r format(d, "%S")` |
| `%t` | Tabulation en _output_, caractère blanc en _input_ | `r format(d, "%t")` |
| `%T` | Même chose que `%H:%M:%S` | `r format(d, "%T")` |
| `%u` | Jour de la semaine (1--7), commence le lundi | `r format(d, "%u")` |
| `%U` | Semaine de l'anné (00--53), dimanche comme début de semaine, et le premier dimanche de l'année définit la semaine 1 | `r format(d, "%U")` |
| `%V` | Semaine de l'année (00-53). Si la semaine (qui commence un lundi) qui contient le  $1^\textrm{er}$ janvier a quatre jours ou plus dans la nouvelle année, alors elle est considérée comme la semaine 1. Sinon, elle est considérée comme la dernière de l'année précédente, et la semaine suivante est considérée comme semaine 1 (norme ISO 8601) | `r format(d, "%V")` |
| `%w` | Jour de la semaine (0--6), dimanche étant 0 | `r format(d, "%w")` |
| `%W` | Semaine de l'année (00--53), le lundi étant le premier jour de la semaine, et typiquement, le premier lundi de l'année définit la semaine 1 (conviention G.B.) | `r format(d, "%W")` |
| `%x` | Date (dépend du lieu) | `r format(d, "%x")` |
| `%X` | Heure (dépend du lieu) | `r format(d, "%X")` |
| `%y` | Année sans le siècle (00--99) | `r format(d, "%y")` |
| `%Y` | Année (en input, uniquement de 0 à 9999)  | `r format(d, "%Y")` |
| `%z` | offset en heures et minutes par rapport au temps UTC | `r format(d, "%z")` |
| `%Z` | Abréviation du fuseau horraire (en output seulement) | `r format(d, "%Z")` |



##### POSIXct et POSIXlt {#dates-POSIXct}

Si les dates à représenter contiennent des heures, il faut préférer le format *POSIXct* ou *POSIXlt*. Avec *POSIXct*, les dates sont stockées en secondes depuis les débuts d'Unix (`1970-01-01 01:00:00`). Avec *POSIXlt*, les dates sont stockées sous forme de liste dont les éléments correspondent à différentes composantes de la date (voir le tableau ci-dessous). Les fonctions `as.POSIXct()` et `as.POSIXlt()` permettent de convertir une chaîne de caractère représentant une date en objet `POSIXct` ou `POSIXlt`. à nouveau, la fonction `strptime()` est utilisée en interne pour réaliser la conversion des chaînes de caractères en dates.
```{r manip_dates_classes_POSIXct}
# POSIXct
d <- as.POSIXct("2015-10-21 13:55:44")
unclass(d)

unclass(as.POSIXct("1970-01-01 01:00:00"))

# POSIXlt
d <- as.POSIXlt("2015-10-21 13:55:44")
unlist(unclass(d))
```

Les éléments de la liste d'un objet de classe `POSIXlt` sont répertoriés dans le tableau suivant (voir page d'aide `?DateTimeClasses`).

| Code | Description |
| :----- | :----------------------- |
| `sec` | secondes (0--61) |
| `min` | minutes (0--59) |
| `hour` | heures (0--23) |
| `mday` | jour du mois (1--31) |
| `mon` | mois après le premier de l'année (0--11) |
| `year` | années depuis 1900 |
| `wday` | jour de la semaine (0--6), début de semaine le dimanche |
| `yday` | jour de l'année (0--365) |
| `isdst` | indicateur d'heure d'été (positif si appliquable, zéro sinon ; néi inconnu) |
| `zone` | Abréviation du fuseau horaire local (`""` si inconnu, ou UTC) |
| `gmtoff` | décalage en minutes par rapport au temps GMT (`NA` ou | `0` si inconnu) |


Le _package_ {`lubridate`} propose également des fonctions pour gérer les dates. Il est pratique de charger le _package_ en mémoire.

Pour convertir une chaîne de caractères représentant une date, il suffit d'utiliser une des trois fonctions suivantes : `ymd()`, `mdy()` et `dmy()`. Les trois lettres de ces fonctions font référence à l'année (`y` – _year_), le mois (`m` – _month_) et le jour (`d` – _day_). La position de ces lettres dans le nom de la fonction doit correspondre à celui des éléments correspondants dans la chaîne de caractères. Ainsi, `ymd()` s'attend à trouver d'abord l'année, puis le mois et enfin le jour dans la chaîne de caractères. Le gros avantage de ces fonctions est qu'il n'est pas nécessaire de préciser les séparateurs, une analyse est faite automatiquement pour le deviner.
```{r manip_dates_lubridate_package_fonctions}
library(lubridate)
ymd("2015-10-21")
mdy("10.21-15")
dmy("21 oct 2015")
```

Il est possible de préciser le fuseau horaire (à condition que le nom soit reconnu par le système d'exploitation), en renseignant l'argument `tz`.
```{r manip_dates_lubridate_package_fonctions_tz}
ymd("2015-10-21", tz = "Pacific/Auckland")
```

```{block2, type='remarque', echo=TRUE}
La fonction `OlsonNames()` retourne un vecteur contenant tous les fuseaux horaires disponibles.
```

S'il y a des informations d'heures dans les chaînes de caractères repésentant les dates, il suffit d'ajouter `h` (heures), ou `hm` (heures et minutes) ou `hms` (heures, minutes et secondes) au nom de la fonction, en séparant par un trait de soulignement.
```{r manip_dates_lubridate_package_fonctions_2}
ymd_hms("2015-10-21 10:00:50")
```




#### Matrices {#structures-base-matrices}

Les matrices sont des vecteurs auxquels un attribut `dim` de dimension est ajouté. Une matrice est un vecteur pour lequel l'attribut `dim` est de longueur 2. La fonction `matrix()` permet de créer une matrice en R. Le code ci-après stoque dans `X ` une matrice de 3 lignes (`nrow = 3`) et de 2 colonnes (`ncol = 2`). Cette matrice est remplie par colonnes successives par les éléments du vecteur `1:6`.
```{r donnees_matrices}
X <- matrix(1:6, ncol = 2, nrow = 3)
X
```

Pour que la matrice soit remplie par lignes successives plutôt que par colonne, il suffit d'ajouter l'argument `byrow` à la fonction `matrix()` et de lui donner la valeur `TRUE`.
```{r donnees_matrices_byrow}
Y <- matrix(1:6, ncol = 2, nrow = 3, byrow = TRUE)
Y
```

Lorsque la dimension dépasse 2, on parle de tableau (_array_). Par exemple, le code ci-après permet de créer un tableau de dimension $2\times 4 \times 3$.
```{r donnees_array}
Z <- array(1:24, dim = c(2, 4, 3))
Z
```


Pour les matrices comme pour les tableaux, les données doivent toutes être du même type.

Les fonctions `nrow()` et `ncol()` donnent le nombre de lignes (`rows`) et de colonnes (`columns`) d'une matrice. La fonction `dim()` donne un vecteur contenant les dimensions de la matrice ou du tableau donné en argument.
```{r donnees_matrice_dim}
X <- matrix(1:6, ncol = 2, nrow = 3)
dim(X)
nrow(X)
ncol(X)
```

#### Listes


Les listes dans R sont les structures les moins rigides. Elles peuvent contenir des éléments de modes différents, y compris des listes. Le mode des éléments de la liste n'est pas altéré, ce qui peut s'avérer utile dans certains cas.
```{r donnees_listes}
(personne <- list("Piketty", "Thomas", "1971"))
class(personne)
```

Comme pour les vecteurs, il est possible de nommer les éléments de la liste, ce qui permet une meilleure lecture et un accès aux données parfois plus pratique. La Section\ \@ref(donnees_manipulation) apportera plus de détails à ce propos.
```{r donnees_listes_noms}
personne <- list("nom de famille" = "Piketty",
                 prenom = "Thomas",
                 annee = 1971)
personne
```

Pour aplatir une liste, R propose une fonction : `unlist()`. Cette fonction retourne un vecteur contenant tous les composants de la liste. Il faut toutefois garder à l'esprit que R se charge alors de convertir tous les éléments dans le mode le plus général. De fait, si cette fonction peut s'avérer pratique dans le cas de scalaires par exemple, elle peut également être destructrice lorsque mal employée.
```{r donnees_listes_unlist}
unlist(personne)
```
### Tableaux de données


#### Data Frames

Les tableaux de données sont au cœur de nombreuses procédures dans R notemment lorsqu'on estimes des modèles économétriques.

Traditionnellement, la structure adaptée aux données rectangulaires (variables en colonnes et observations en lignes) est ce que l'on appelle les _data frames_. Du fait de l'évolution des besoins ces dernières années, les _data frames_, bien qu'elles demeurent largement utilisées, tendent à être remplacées par les _tibbles_ (cf La Section\ \@ref(donnees-tibbles) pour découvrir cette structure similaire et comprendre pourquoi les _tibbles_ remplacent progressivement les _data frames_).

Un _data frame_ est une liste composée d'un ou plusieurs vecteurs de même longueur. Le mode des vecteurs n'est pas nécessairement identique à celui des autres. Une manière simple de se représenter les tableaux de données est de penser à une matrice dans laquelle les lignes représentent des individus et les colonnes des caractéristiques propres à ces individus. La création d'un tableau de données se fait _via_ la fonction _data.frame()_. La fonction _as.data.frame()_ permet quant à elle de convertir un objet d'un autre type en _data frame_.

L'exemple ci-après utilise les données du _dataset_ `women`, présent dans le _package_ {`datasets`}. Il s'agit de la taille (en pouces) et du poids (en livres) moyen des femmes américaines âgées entre 30 et 39 ans.
```{r donnees_df}
femmes <- 
  data.frame(height = c(58, 59, 60, 61, 62, 63, 64,
                        65, 66, 67, 68, 69, 70, 71, 72),
           weight = c(115, 117, 120, 123, 126, 129,132, 
                      135, 139, 142, 146, 150, 154, 159, 164))
femmes
is.data.frame(femmes)
class(femmes)
```


Comme pour les matrices, on peut obtenir les dimensions d'un _data frame_ avec la fonction `dim()`, le nombre de lignes avec `nrow()` et le nombre de colonnes avec `ncol()`.



#### Tibbles {#donees-tibbles}

Lorsque le volume des données devient conséquent, les _data frames_ deviennt désagréables à manipuler. Par exemple, lorque l'on tente d'appeler un _data frame_ dans la console, R tente d'aficher un maximum de lignes, puis finit par s'arrêter à la millième. Lorsque le nombre d'observation est important, il n'est pas rare que cet affichage provoque un très long temps d'attente. Une strucutre plus récente, les _tibbles_, gère ce genre de soucis en affichant uniquement un extrait plus court. Les _tibbles_ (_package_ {`tibble`}) font partie de l'ensemble de _packages_ de l'environnement  _tidyverse_.


La création d'un _tibble_ est similaire à celle d'un _data.frame_.

```{r, warnings=FALSE, message=FALSE}
library(tidyverse)
femmes_tibble <- tibble(height = c(58, 59, 60, 61, 62, 63, 64, 65,
                                66, 67, 68, 69, 70, 71, 72),
                     weight = c(115, 117, 120, 123, 126, 129, 132,
                                135, 139, 142, 146, 150, 154, 159, 164))
femmes_tibble
```

Lorsqu'un _tibble_ est créé, le nom des colonnes n'est pas modifié s'il ne respecte pas les anciennes règles de nommage (à condition d'utiliser les accents graves pour définir le nom).

```{r}
tibble(`1essai!` = c(1, 2, 3, 4, 5))
```


Les lignes ne sont pas nommées, elles sont simplement numérotées.


On peut noter que les vecteurs de longueur 1 seront recyclés, c'est-à-dire que la valeur sera répétée le nombre de lignes du tableau final.
```{r}
tibble(col_deux = c(6, 7, 8, 9, 10),
       col_trois = 0,)
```

Il est intéressant de noter qu'il est possible de faire appel au nom d'une colonne qui vient d'être créée, lors de la création d'un _tibble_, ce qui n'est pas réalisable avec un _data frame_.

```{r}
tibble(
  `1essai!` = c(1, 2, 3, 4, 5),
  col_deux = c(6, 7, 8, 9, 10),
  col_trois = 0,
  test = `1essai!` + col_deux)
```

Un _data frame_ peut aisément être converti en _tibble_, à l'aide de la fonction `as_tibble()`.
```{r tibble_convert}
femmes_tibble_2 <- as_tibble(femmes)
femmes_tibble_2
class(femmes_tibble_2)
```

Pour comprendre pourquoi les _tibbles_ ont tendance à remplacer les _data frames_, il est possible d'avancer les raisons suivantes (il en existe d'autres, mais à ce stade de la lecture de ces notes, cela ferait intervenir des concepts qui ne seront abordés que plus loin) :

- Lorsque l'on affiche un _tibble_ en évaluant son nom dans la console, R n'affichera que les 10 premières lignes et l'ensemble des colonnes qui peuvent s'afficher sur l'écran ;
- Le mode des colonnes est décrit lors de l'affichage ;
- Une coloration syntaxique est proposée pour visualiser plus facilement les contenus.

Si l'on désire afficher davantage de lignes d'un _tibbles_ dans la console que ce qui est proposé par défaut, il est possible de modifier les options de R, à l'aide de la fonction `options()`.

Si le _tibble_ est composé de plus de `n` lignes et que l'on souhaite afficher les `m` premières, il faut procéder comme suit :
```{r, eval=FALSE}
options(tibble.print_max = n, tibble.print_min = m)
```

L'affichage restreint le nombre de colonnes dans la console. Pour en afficher davantage, il faut modifier l'argument `tibble.width`. Par exemple, pour retourner toutes les colonnes, il faut procéder comme suit (attention, le code suivant n'est pas adapté en présence de volumes de données avec un nombre de variables très important) :
```{r, eval=FALSE}
options(tibble.width = Inf)
```

#### Data table



Le _package_ {`data.table`} propose une structure de données appelée _data.table_[^La vignette d'introduction qui accompagne le _package_ est très bien faite : https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html.], qui se veut être une alternative aux objets _data frame_ et _tibbles_. Il faut toutefois noter qu'un objet de classe _data.table_ est également un _data.frame_. L'idée derrière les _data.table_ est de réduire la longueur du code, de proposer une syntatxe plus facile à écrire et lire, mais aussi de réduire drastiquement les temps de calculs en présence de volumes de données massifs. La syntaxe se rapproche un peu du SQL, mais évite pas mal de lourdeurs de ce langage.

Pour utiliser les fonctions du _packages_, il est pratique de charger ce dernier.
```{r}
library(data.table)
femmes <- 
  data.table(height = c(58, 59, 60, 61, 62, 63, 64, 65, 66, 
                        67, 68, 69, 70, 71, 72),
           weight = c(115, 117, 120, 123, 126, 129, 132, 135, 
                      139, 142, 146, 150, 154, 159, 164))
femmes
is.data.frame(femmes)
is.data.table(femmes)
class(femmes)
```


## Importation, exportation et création de données

Pour pouvoir analyser des données, il faut pourvoir les charger en mémoire. Heureusement, il n'est pas nécessaire de les rentrer à la main, il existe des fonctions qui permettent de les importer, depuis divers formats. Il est également possible d'enregistrer les données dans plusieurs formats. Puisqu'il est souvent utile de créer des données à l'intérieur de la session (par exemple des années, des variables indicatrices, des noms de mois, etc.), cette section présente quelques fonctions utiles à la création de données.

Avant toute chose, il convient de préciser qu'un environnement de travail (_working directory_) est assigné à R. Si R est lancé depuis un terminal, l'environnement de travail sera par défaut le répertoire courant à partir duquel la commande de lancement de R a été évaluée. C'est dans ce répertoire, dont on peut se rappeler le chemin grâce à l'instruction `getwd()` que R ira chercher les fichiers à importer et enregistrer les données lors de l'exportation. Si on souhaite lire des fichiers qui sont hors de ce répertoire, il est nécessaire d'indiquer à R leur chemin (relatif ou absolu). Pour changer de répertoire courant, il est possible d'utiliser la fonction `setwd()`. 
```{r, donnees_getwd, echo=3}
wd <- getwd()
setwd("/Users/ewengallic/Documents")
getwd()
setwd(wd)
```


*Attention*, l'utilisation de la fonction `setwd()` est considérée comme une *mauvaise pratique*. Deux exemples permettent de comprendre que l'utilisation de cette fonction peut s'avérer très pénible :

- lors d'un travail en collaboration, il est fort probable que la ou les personnes avec qui l'on travaille ne s'appellent pas comme nous ; de fait, le chemin indiquant le répertoire courant sera faux ;
- lors de l'acquisition d'un nouvel ordinateur, il est fort possible que l'arborescence ne soit pas exactement la même ; à nouveau, le chemin indiquant le répertoire de travail ne sera plus le bon.


Quelle pratique adopter, dans ce cas ? La réponse est simple : travailler à l'aide de projets. RStudio propose cette alternative[^Menu `File` > `New Project...`.], et dans ce cas, le chemin vers le répertoire de travail est défini à l'extérieur, par RStudio. Il suffit alors d'utiliser des chemins relatifs lors de l'importation ou l'exportation de données, graphiques, etc., plutôt que des chemins absolus. Les deux problèmes mentionnés plus haut n'apparaitront pas.


```{block2, type='remarque', echo=TRUE}
La fonction `list.files()` est très pratique : elle permet de lister tous les documents et répertoires contenus dans le répertoire de travail, ou dans n'importe quel répertoire si l'argument `path` renseigne le chemin.
```

### Importation



Lorsque les données sont présentes dans un fichier texte (ASCII), R propose deux fonctions : `read.table()` et `scan()`. Pour les données stockées dans des fichiers aux formats différents, il est nécessaire de s'appuyer sur d'autres fonctions, non contenues dans le `package` {`base`}. C'est le cas pour les fichiers Excel, SAS~ou STATA.


#### La fonction `read.table`


Cette fonction est très pratique lorsque les données sont déjà organisées dans un tableau dans le fichier à importer. Elle crée alors un _data frame_ contenant les données. Dans l'exemple fictif ci-dessous, les données du fichier _fichier.txt_ sont stockées dans le _data frame_ `df`. Les variables seront nommées par défaut `V1`, `V2`,...
```{r donnees_importation, eval=FALSE}
df <- read.table("fichier.txt")
```


Il existe de nombreux arguments pour la fonction `read.table()`. Seuls les principaux seront abordés ici. Le lecteur ou la lectrice pourra consulter l'aide `?read.table()` pour obtenir de plus amples détails.

| Argument | Description |
| :------- | :---------------------------------|
| `file` |  Le nom du fichier, doit être une chaîne de caractères. Il peut être précédé du chemin relatif ou absolu. Attention (utile pour les utilisateur•rice•s de Windows) le caractère `\` est proscrit, et doit être remplacé par `/` ou bien `\\`. à noter qu'il est possible de saisir une adresse web (URL) en guise de chaîne de caractère.|
| `header` | Valeur logique (`header=FALSE` par défaut) indiquant si la première ligne contient les noms de variables.||
| `sep` |  Le séparateur de champ dans le fichier (chaîne vide par défaut, ce qui est au final traduit par une espace comme séparation). Par exmple, `sep=";"` si les champs sont séparés par un point-virgule, ou encore `sep="\textbackslash t"` s'ils sont séparés par une tabulation.|
| `dec` | Le caractère employé pour les décimales (par défaut, `dec="."`).|
| `row.names` | Un vecteur contenant le nom des lignes (de type caractère), ou bien le numéro ou le nom d'une variable du fichier. En omettant cet argument, les lignes sont numérotées. |
| `na.strings` | Une chaîne de caractère (ou un vecteur de chaînes de caractères) indiquant la valeur des données manquantes (par défaut, `na.strings="NA"`). Ces données manquantes seront converties en `NA`. |
| `colClasses` | Un vecteur de caractères indiquant les modes des colonnes. |



```{block2, type='remarque', echo=TRUE}
Il est possible d'employer l'instruction `file.choose()` pour ouvrir une boîte de dialogue au lieu d'écrire le chemin complet vers le fichier de données. Bien que cette interface puisse paraître agréable à l'utilisateur•trice novice, elle risque de vite devenir contraignante si le fichier R est amené à être exécuté plusieurs fois, puisqu'à chaque appel, la boîte de dialogue s'ouvrira.

`df <- read.table(file.choose())`
```


```{block2, type='remarque', echo=TRUE}
Il existe des variantes de `read.table()` qui s'appuient sur cette fonction pour proposer à l'utilisateur•trice des fonctions directement capables de lire leur fichier de données, sans avoir à changer les arguments `sep` et `decim`.

| Fonction | Séparateur de champs | Séparateur décimal |
| ---------|:--------------------:|:------------------:|
| `read.csv()`    | "`,`"   | "`.`" | 
| `read.csv2()`   | "`;`"   | "`,`" | 
| `read.delim()`  | "`\t`"  | "`.`" | 
| `read.delim2()` | "`\t`"  | "`,`" | 
```


```{block2, type='remarque', echo=TRUE}
Le _package_ {`readr`} propose des alternatives extrêmement rapides aux fonctions `read.table()` et dérivées. L'équivalent de `read.table()` est `read_delim()`. Il suffit de lui préciser le séparateur de champ (`delim`), le séparateur des miliers étant automatiquement détecté. Attention, une ligne d'en-tête doit être présente dans le fichier de données.

`df <- read_delim("data.csv", ";")`

| Fonction | Séparateur de champs | Séparateur décimal |
| ---------|:--------------------:|:------------------:|
| `read_csv()`    | "`,`"   | "`.`" | 
| `read_csv2()`   | "`;`"   | "`,`" | 
| `read_delim()`  | "`\t`"  | "`.`" | 
| `read_delim2()` | "`\t`"  | "`,`" | 
```

#### La fonction `scan`



La fonction `scan()` est beaucoup plus souple que `read.table()`. Son emploi est requis dès que les données ne sont pas organisées comme un tableau. La nature des variables peut être spécifiée en renseignant l'argument `what`. On retrouve la plupart des arguments de la fonction `read.table()`. Le tableau ci-dessous présente les principaux; le lecteur ou la lectrice est invité•e à se reporter au fichier d'aide (`?scan`) pour obtenir de plus amples détails.

| Argument | Description |
| ----------|:-----------|
| `file`    | Nom de fichier ou chemin complet vers le fichier (peut être une URL) |
| `what`    | Type des données lues |
| `nmax`    | Nombre de données maximum à lire |
| `n`       | Nombre de données à lire (pas de limite par défaut) |
| `sep`     | Champ de séparation (caractère blanc par défaut)|
| `dec`     | Caractère pour les décimales ("`.`" par défaut) |
| `skio`    | Nombre de lignes à omettre avant de débuter l'importation |
| `na.strings`  | Vecteur de chaînes de caractères indiquant les valeurs manquantes (`NA` par défaut) |
| `flush`  | Si `TRUE`, commence l'importation de la ligne suivante après le dernier champs requis (permet d'avoir des commentaires après le dernier champ) |


```{block2, type='remarque', echo=TRUE}
Si dans l'appel de `scan()`, l'argument `file` est comme suit : `file=""`, l'utilisateur•trice est invité•e à entrer les données au clavier. Pour clore la saisie, il suffit de terminer par une ligne blanche.
```

#### La fonction _read.fwf_


Parfois, les données que l'on récupère sont dans un format à largeur fixée (_fixed width format_). C'est le cas par exemple pour les données météorologiques issues du site de la _National Oceanic and Atmospheric Administration_ (NOAA). R propose une fonction pour importer rapidement ce type de données : _read.fwf()_. Un argument fait son apparition par rapport à la fonction _read.table()_, il s'agit de _widths_, qui permet d'indiquer la largeur de chaque champ.

Prenons un exemple. Si le fichier de données est nommé `data_fwf.txt` et est présent dans le répertoire de travail, et qu'il contient les données suivantes : 

> FRANCEFR14.01
> FRANCEFR23.02
> FRANCEFR32.96
> ITALIEIT15.90
> ITALIEIT25.48
> ITALIEIT34.32


alors, l'importation de ces données dans R pourra se faire de la manière suivante :
```{r donnees_importation_fwf, eval=FALSE}
(df_fwf <- read.fwf("data_fwf.txt", widths = c(6,2,4)))
```

```{block2, type='remarque', echo=TRUE}
La fonction `read_fwf()` du _package_ {`readr`} est une alternative à la fonction `read.fwf()`.
```

#### Importation depuis Excel©


Nous allons voir comment importer des données directement depuis un fichier à l'extension `.xls` ou `.xlsx`. Il existe plusieurs méthodes, qui sont bien expliquées dans les documents de référence de ce document. Nous allons uniquement aborder la manière à l'aide des fonctions `read.xls()` et `read_excel()` contenues dans les _packages_ {`gdata`} et {`readxl`} respectivement. Par souci de reproductibilité, nous allons nous appuyer sur le fichier `iris.xls`, contenu dans le répertoire du _package_ {`gdata`}.
```{r donnees_importation_xls_1, echo = FALSE, include = FALSE}
library("gdata")
```

```{r donnees_importation_xls, tidy=TRUE}
library("gdata")
# Récupérer le lien vers le fichier iris.xls
xlsfile <- file.path(path.package('gdata'),'xls','iris.xls')
iris <- read.xls(xlsfile) # Créé un fichier csv temporaire
head(iris)
```

Par défaut, la fonction `read.xls()` importe les données de la première feuille. L'argument `sheet` permet d'indiquer la feuille souhaitée, en la référençant soit par son numéro, soit par son nom.

```{block2, type='remarque', echo=TRUE}
En pratique, si le fichier contient des formules, il est préférable d'utiliser la fonction 'collage spécial' d'Excel pour coller les valeurs dans un nouveau fichier, ou bien d'enregistrer le fichier sous un format `.txt` dans Excel.
```

```{block2, type='remarque', echo=TRUE}
Pour les utilisateur•rice•s sous Windows, il est peut-être nécessaire d'indiquer le chemin vers l'interprète perl (le fichier se nomme `perl.exe` )

`perl <- "C:\\Program Files\\FusionInventory-Agent\\perl\\bin\\perl.exe"`

`iris <- read.xls(xlsfile, perl = perl) # Créé un fichier csv temporaire`
```


Avec `read_xl()`, la procédure est identique :
```{r donnees_importation_xl_1, echo = FALSE, include = FALSE, warning=FALSE, message=FALSE}
library("readxl")
```
```{r donnees_importation_xl, tidy=TRUE}
library("readxl")
# Récupérer le lien vers le fichier iris.xls
xlsfile <- file.path(path.package('gdata'),'xls','iris.xls')
iris <- read_excel(xlsfile)
```

#### Importation depuis d'autres formats

Le _package_ {`foreign`}, installé de base sous Windows, mais non chargé automatiquement en mémoire, permet de lire des données stockées dans de nombreux formats (par exemple DBF, STATA, SPSS, etc.). Pour les fichiers `sas7bdat`, produits par SAS©, on peut utiliser la fonction `read.sas7bdat()` du _package_ {`sas7bdat`}.

### Exportation



Pour enregistrer des données depuis un _tibble_, un _data frame_, un vecteur ou une matrice, la fonction `write.table()` peut être utilisée. Par exemple, si le _tibble_ se nomme `donnees`, l'instruction ressemble à :
```{r donnees_exportation, tidy=TRUE, eval = FALSE}
write.table(donnees, file = "nom_fichier.txt", sep = ";")
```

Il existe d'autres arguments, que le lecteur ou la lectrice pourra consulter dans l'aide de la fonction `write.table()`.

```{block2, type='remarque', echo=TRUE}
La fonction `write_csv()` du _package_ {`readr`} est une alternative à la fonction `write.csv()`.
```

La fonction `save()` permet elle aussi de sauvegarder des données en dehors de la session R, et cette fois, n'importe quelle classe d'objet peut être sauvegardée. Par exemple, si l'utilisateur•rice souhaite sauvegarder les objets `d1`, `d2` et `d3`, il lui suffit de rentrer l'instruction suivante :
```{r donnees_exportation_save, eval = FALSE}
save(d1, d2, d3, file = "nom_fichier.RData")
```

Pour charger les fichiers d'extention `.RData`, il faut utiliser la fonction `load()` :
```{r donnees_exportation_load, eval = FALSE}
load("nom_fichier.RData")
```

```{block2, type='remarque', echo=TRUE}
Pour sauvegarder tous les éléments de la session R, la fonction `save.image()` peut être appelée, ce qui revient au même que d'évaluer l'instruction `save(list = ls(all=TRUE), file=".RData")`.
```

### Génération


#### Séquences régulières


La fonction de concaténation, abordée précédemment est un moyen simple de créer un vecteur de données.
```{r donnees_generation_c}
c(1,2,3)
```


La fonction `seq()` est extrêmement utile. Elle crée un vecteur de séquences de nombres. Le premier argument définit la valeur du début de séquence, tandis que le second argument définit la valeur finale. L'argument `by` définit l'incrément, et vaut 1 par défaut. L'argument `length.out` permet quant à lui de définir la longueur souhaitée de la séquence, et définit donc automatiquement la valeur de l'incrément. Il faut noter que `by` et `length.out` ne peuvent évidemment pas être utilisés en même temps.
```{r donnees_vecteurs_seq}
(a <- 2:4)
seq(1,3)
seq(1,3, by = 0.5)
seq(1,3, length.out = 10)
```

La fonction `:()` génère une séquence de données espacées d'une unité. Attention, cette fonction, que l'on peut voir comme un opérateur, est prioritaire sur les opérations arithmétiques.
```{r donnees_generation_deux_points}
1:10
1.5:10
```


Comme mentionné en Section\ \@ref(donnees-mode), le stockage des données de mode _integer_ prend moins de place que celles de type _numeric_. Avec les fonctions `seq()` ou `:()`, les données sont de type `integer`.
```{r donnees_generation_seq_type}
class(c(2,3,4))
class(seq(2,4))
```


Pour créer une séquence de valeurs avec duplication du premier argument, on peut utiliser la fonction `rep()`. En jouant avec les arguments, on peut créer des réplications différentes. Voici quelques exemples.
```{r donnees_generation}
rep(1, 3) # Répète trois fois la valeur 1
rep(1:2, 3) # Répète trois fois la séquence 1:2
rep(1:2, each = 3) # Répète chaque élément de la séquence 1:2 trois fois
# Répète deux fois la séquence dans laquelle
# les éléments de la séquence 1:2 sont répétés trois fois
rep(1:2, 2, each = 3)
# Répète la séquence 1:2 jusqu'à ce que
# la longueur du résultat soit égale à 3 (le résultat peut être tronqué)
rep(1:2, length.out = 3)
```


La fonction `seq_len()` crée une suite de nombres entiers allant de 1 au nombre passé à l'unique argument `length.out`.
```{r donnees_generation_seq_len}
seq_len(4)
```




La fonction `sequence()` génère une suite de nombres. Pour chaque élément passé à l'argument `nvec`, une séquence de nombre allant de 1 à cet élément, est créée. Les séquences d'entiers ainsi créées sont concaténées.
```{r donnees_generation_sequence}
sequence(2:4)
sequence(c(3,5))
```

La fonction `gl()` permet de créer des séries de facteurs. Elle requière deux arguments : `n`, pour indiquer le nombre de niveaux souhaité, et `k` pour indiquer le nombre de réplications voulu. Il est possible de définir les étiquettes pour chacun des niveaux, en renseignant l'argument `labels` ou encore de préciser si les niveaux des facteurs doivent être ordonnés, avec l'argument logique `ordered`. L'argument `length` permet quant à lui de définir la longueur souhaitée du résultat.
```{r donnees_generation_gl}
gl(2, 4)
gl(2, 4, length = 10)
gl(2, 4, labels = c("Oui", "Non"))
```


Enfin, `expand.grid()` est une fonction très utile pour générer toutes les combinaisons possibles des vecteurs donnés en arguments.
```{r donnees_generation_expand_grid, tidy=TRUE}
expand.grid(age = seq(18, 20), genre = c("Femme", "Homme"), fumeur = c("Oui", "Non"))
```

#### Séquences pseudo-aléatoires



R propose des fonctions pour de nombreuses distributions de probabilité. Pour chaque distribution de probabilité, il y a en général quatre fonctions, dont le nom commence par une des quatre lettres suivantes : `r` (_random_), `d` (_density_), `p` (_probability_) et `q` (_quantile_). Les fonctions commençant par la lettre `r` permettent de générer des données issues d'une loi de probabilité donnée ; celles commençant par la lettre `d` correspondent aux densités de probabilité (ou fonctions de masse dans le cas d'une variable aléatoire discrète) ; celles dont la première lettre est un `p` donnent la densité de probabilité cumulée (fonctions de répartition) ; et enfin celles commençant par la lettre `q` donnent les valeur de quantiles (fonctions quantiles).

Prenons un exemple avec la loi $\mathcal{N}(0,1)$ :
```{r donnees_generation_rnorm}
rnorm(n = 1, mean = 0, sd = 1)
dnorm(1) == 1/sqrt(2*pi) * exp(-1/2)
pnorm(1.96)
qnorm(0.025) ; qnorm(0.975)
```


R propose des fonctions pour les lois de probabilité discrètes suivantes (liste non exhaustive) :

- Binomiale : `rbinom(n, size, prob)` ;
- Poisson : `rpois(n, lambda)` ;
- Géométrique : `rgeom(n, prob)` ;
- Hyper-géométrique : `rhyper(nn, m, n, k)` ;
- Binomiale négative : `rnbinom(n, size, prob, mu)`.


R propose des fonctions pour les lois de probabilité continues suivantes (liste non exhaustive) :

- Normale : `rnorm(n, mean = 0, sd = 1)`
- Student : `rt(n, df, ncp)`
- Khi-deux : `rchisq(n, df, ncp = 0)`
- Fisher : `rf(n, df1, df2, ncp)`
- Exponentielle : `rexp(n, rate = 1)`
- Uniforme : `runif(n, min = 0, max = 1)`
- Beta : `rbeta(n, shape1, shape2, ncp = 0)`
- Logistique : `rlogis(n, location = 0, scale = 1)`
- Log-Normale : `rlnorm(n, meanlog = 0, sdlog = 1)`
- Gamma : `rgamma(n, shape, rate = 1, scale = 1/rate)`
- Weibull : `rweibull(n, shape, scale = 1)`

## Manipulation des données

Dans la Section\ \@ref(structures), nous avons vu comment créer différents objets en R. Cette section présente d'abord les opérateurs, puis les façons d'accéder aux données en fonction du type d'objet, les calculs sur les listes et vecteurs, et enfin les calculs matriciels.

### Opérateurs


Il existe trois sortes d'opérateurs en R, à savoir arithmétiques, de comparaison et logiques.

#### Opérateurs arithmétiques



Les opérateurs arithmétiques agissent sur des vecteurs ou des matrices. Ils opèrent sur des objets de type numérique, complèxe ou logique. En voici la liste :
```{r donnees_manip_operateurs_arithmetiques}
x <- c(1, 2, 3, 4, 5)
y <- c(2, 5, 2, 8, 1)
x + y  # Addition
x - y  # Soustraction
x * y	# Multiplication
x / y	# Division
x^y  # Puissance
x %% y	# Modulo
x %/% y	# Division entière
```

#### Opérateurs de comparaison

Les opérateurs de comparaison agissent sur des vecteurs, des matrices, des tableaux de données et des listes. Le type de données n'est pas restreint comme pour les opérateurs arithmétiques.
```{r}
x <- seq_len(5)
x < 2  # Inférieur à
x <= 2	# Inférieur ou égal à
x > 2	# Supérieur à
x >= 2	# Supérieur ou égal à
x == 2	# Égal à
x != 2	# Différent de
```

Attention, il faut être prudent avec la fonction d'égalité. En effet, un exemple simple (voir @Paradis_2002_R) montre que deux objets qui nous semblent identiques ne le sont pas aux yeux de la machine, à cause des approximations effectuées lors des calculs. Il convient alors dans certains cas d'utiliser la fonction `all.equal()` plutôt que l'opérateur logique `==` ou la fonction `identical()`.
```{r donnees_manip_operateurs_comparaison_pb}
0.9 == (1 - 0.1)
all.equal(0.9, 1-0.1)
identical(0.9, 1 - 0.1)
0.9 == (1.1 - 0.2)
all.equal(0.9, 1.1-0.2)
identical(0.9, 1.1-0.2)
```


En fait, la fonction `all.equal()` donne une égalité approximative, à l'aide d'un seuil de tolérance !
```{r donnees_manip_operateurs_comparaison_pb_2}
all.equal(0.9, 1.1-0.2, tolerance = 1e-16)
```

#### Opérateurs logiques


Les opérateurs logiques opèrent sur un ou deux objets de type logique. Les opérateurs `ET` et `OU` existent en R sous deux formes : la forme simple (`&` et `|`) et la forme double (`&&` et `||`). La forme simple opère sur chaque élément des objets, et retourne le résultat de l'opération pour chaque élément. La forme double, quant à elle, opère uniquement sur le premier élément des objets.
```{r donnees_manip_operateurs_logiques}
x <- c(TRUE, TRUE, FALSE, FALSE)
y <- c(TRUE, FALSE, TRUE, FALSE)
!x  # 'Non' logique
x&y	# 'Et' logique
x&&y	# 'Et' logique (revient à faire x[1] & y[1])
x|y	# 'Ou' logique
x||y	# 'Ou' logique (revient à faire x[1] | y[1])
xor(x, y)	# 'Ou' exlusif
```


Il existe deux fonctions importantes pour les vecteurs de type `logical` : `any()` et `all()` qui indiquent respectivement, si au moins un des éléments du vecteur vaut `TRUE` et si tous les éléments du vecteur valent `TRUE`.
```{r donnees_manip_operateurs_logiques_any}
x <- c(TRUE, FALSE)
any(x)
y <- c(FALSE, FALSE)
any(y)
all(!y)
```

#### Attention au recyclage



Jusqu'ici, les exemples fournis au sujet des opérateurs ne concernaient que des objets de même longueur. Dans le cas des *vecteurs*, si un des deux objets concernés par l'opération est de taille inférieure à celle de l'autre, R effectue un recyclage, c'est à dire qu'il va compléter le vecteur le plus court à l'aide des valeurs de ce même vecteur, afin d'obtenir deux objets de même taille. On peut voir que R affiche un message d'avertissement lors d'une telle opération.
```{r donnees_manip_operateurs_recyclage}
x <- c(1, 2, 3)
y <- c(1, 2, 3, 4, 5, 6, 7)
x + y
# R a ajouté le vecteur c(1, 2, 3, 1, 2, 3, 1) à y
```

### Accès aux valeurs, modifications {#manip-acces}



Pour accéder aux éléments d'un objet, R propose plusieurs méthodes, qui peuvent varier selon le type d'objet.


#### Accès par indices


Un moyen simple d'accéder aux éléments d'un objet est d'utiliser le système d'indexation. Cette indexation peut être de type numérique ou logique. Dans le cas d'un vecteur, on extrait une composante en utilisant la fonction `"["()`, dont les arguments en dehors du vecteur pour lequel on souhaite réaliser une extraction peuvent être un vecteur d'indices d'éléments à extraire ou ne pas extraire, un vecteur d'éléments de type logique indiquant si l'élément doit être extrait ou non.
```{r donnees_manip_acces_indices}
x <- c(4, 7, 3, 5, 0)
"["(x, 2)  # Extraire le second élément de x
x[2]	# Une écriture plus commode pour extraire le second élément de x
x[-2]	# Tous les éléments de x sauf le second
x[3:4]	# Les troisième et quatrième éléments de x
i <- 3:4
x[i] # On peut utiliser une variable contenant un vecteur d'indices
x[c(F, T, F, F, F)]	# Le second élément de x
x[x<1]	# Les éléments de x inférieurs à 1
x<1	# Il s'agit bien d'un vecteur de logiques
```


La fonction `which()` retourne les positions des éléments d'un vecteur logique pour lesquels la valeur vaut `TRUE`. Les fonctions `which.min()` et `which.max()` retournent respectivement la position du (premier) minimum et du premier maximum d'un vecteur numérique ou logique.
```{r donnees_manip_acces_indices_which}
x <- c(2, 4, 5, 1, 7, 6)
which(x < 7 & x > 2)
which.min(x)
which.max(x)
x[which.max(x)]
```



Le remplacement d'un élément s'effectue simplement en utilisant la flèche d'assignation. On peut modifir plusieurs éléments à la fois.
```{r donnees_manip_acces_indices_assign}
x <- seq_len(5)
x[2] <- 3
x
x[2] <- x[3] <- 0
x
x[which(x == 0)] <- 10
x
```


Pour les *matrices* ou les *tableaux de données*, l'extraction par indice se fait dans le même esprit, mais il faut indiquer un vecteur d'indices (`i`) pour les lignes et un pour les colonnes (`j`), de la manière suivante : `x[i, j]`, avec `x` la matrice ou le tableau de donnée. En omettant le vecteur d'indices pour les lignes ou les colonnes, R retourne toutes les lignes ou les colonnes respectivement. Enfin, en ajoutant le symbole "moins" (`-`) devant le vecteur d'indices de lignes ou de colonnes, on demande à R de ne pas retourner les éléments dont les indices sont mentionnés.
```{r donnees_manip_acces_indices_matrice}
(x <- matrix(1:9, ncol = 3, nrow = 3))
x[1, 2]  # Élément de la ligne 1 et de la colonne 2
i <- c(1,3) ; j <- 3
x[i,j]	# Éléments des lignes 1 et 3 de la troisième colonne
x[, 2]	# Éléments de la seconde colonne
x[1 ,]	# Éléments de la première ligne
x[, -c(1,3)]	# x sans les colonnes 1 et 3
```


Avec le dernier exemple, on voit que R retourne un vecteur et non une matrice. Si on souhaite obtenir une matrice à une seule colonne, il suffit d'ajouter l'argument `drop` auquel on donne la valeur `FALSE`.
```{r}
x[, -c(1,3), drop = FALSE]
```



Pour modifier une valeur, c'est à nouveau avec la flèche d'assignation.
```{r}
x <- matrix(1:9, ncol = 3, nrow = 3)
x[1,2] <- 0
x
```

On peut noter qu'en utilisant `which()` sur une matrice, on peut demander à R de retourner les indices sous forme de couples :
```{r donnees_manip_acces_indices_matrice_2_rem}
which(x > 5, arr.ind = TRUE)
```


Il est également possible d'utiliser des vecteurs logiques.
```{r donnees_manip_acces_indices_matrice_3}
(x_logique <- matrix(c(TRUE, FALSE), ncol = 3, nrow = 3))
x[x_logique]
```

Comme indiqué dans la Section\ \@ref(structures-base-matrices), les matrices et les tableaux sont des vecteurs, qui correspondent à un empilement des vecteurs colonnes. Ainsi, on peut extraire les éléments de la matrice à l'aide d'un vecteur d'indices ou de valeurs logiques.
```{r donnees_manip_acces_indices_matrice_4}
x[c(1,3,7)]
```


Pour les *tableaux de dimension supérieure à 2*, il suffit juste d'ajouter un argument par dimension supplémentaire. Voici un exemple avec un tableau de dimension 3 :
```{r donnees_manip_acces_indices_array}
z <-array(1:24, dim =c(2, 4, 3))
z[2,4,3]  # Élément de la ligne 2, colonne 4 de la dimension 3
```

Enfin, pour les *listes*, l'emploi de la fonction `"["()` retourne une liste, puisque les listes sont constituées de listes.
```{r donnees_manip_acces_indices_liste}
personne <- list("Piketty", "Thomas", "1971")
personne[1]
class(personne[1])
personne[c(1,3)]
```

Pour obtenir le contenu d'un ou plusieurs éléments de la liste, on fait donc appel à une autre fonction : `"[["()`. Comme pour la fonction avec les crochets simples, on peut l'employer d'une manière plus commode en l'accolant au nom de la liste contenant les éléments que l'on souhaite extraire.
```{r donnees_manip_acces_indices_liste_2, error=TRUE}
"[["(personne, 1)  # Premier élément de la liste
personne[[1]]	# idem
personne[[1,2]]	# Ne fonctionne pas
personne[[c(1,2)]]	# Ne fonctionne pas non plus ici
personne[1,2] # Ne fonctionne pas
personne[c(1,2)]	# Retourne une liste de dim 2 contenant :
	# - le premier élément de la liste
	# - le second élément de la liste
```

Grâce à la propriété d'indexation récursive, il est possible d'accéder aux éléments des objets de la liste. Par exemple, si le troisième élément de la liste `l` est un vecteur, et que l'on souhaite récupérer son premier élément, on peut écrire procéder de deux manières :
```{r}
(l <- list("foo_1", "foo_2", c("foo_3", "foo_4")))
l[[3]]  # Troisième élément de la liste
l[[c(3,1)]]	# Premier élément du troisième élément
l[[3]][1]	# Premier élément du troisième élément
```


Pour modifier l'élément d'une liste ou son contenu, on utilise encore la flèche d'assignation. Attention, ceci peut être destructif. En effet, si on indique à R que l'on souhaite modifier le contenu d'un élément, en utilisant la fonction `"[["()`, le résultat sera le même qu'en utilisant la fonction `"["()`.
```{r}
l <- list(1, TRUE, "foo", list(matrix(1:4, ncol = 2), "foo_2"))
l[[4]] <- 2
l  # La liste en position 4 a été remplacée par un vecteur de longueur 1
```

#### Accès par noms


Comme précisé dans la Section\ \@ref(structures), les éléments d'un *vecteur* peuvent posséder un nom. Il est alors possible d'accéder à un élément par son nom.
```{r donnees_manip_acces_noms_1}
personne <- c(nom = "Piketty", prenom = "Thomas", "annee de naissance" = "1971")
personne["nom"]
names(personne)  # Accès aux noms des éléments du vecteur
names(personne) <- c("nom", "prenom", "naissance")	# Modification des noms
personne
names(personne) <- NULL	# Suppression des noms
personne
```


Si l'objet est une *liste* ou un *tableau de données*, on peut aussi utiliser le symbole dollar (`$`).
```{r donnees_manip_acces_noms_2}
personne_liste <- 
  list('nom de famille' = "Piketty", prenom = "Thomas", annee = 1971)
personne_liste[["nom de famille"]]
personne_liste$"nom de famille"  # Le nom contenant au moins une espace,
	# Il est nécessaire d'employer des guillemets
personne_liste$prenom
names(personne_liste)  # Accès aux noms des éléments de la liste
```



Dans le cas des *matrices* et des *tableaux de données*, il est possible de donner un nom aux lignes (pas avec les _tibbles_) et aux colonnes, avec les fonctions `rownames()` et `colnames()` respectivement. La fonction `dimnames()` retourne une liste dont le premier élément est une liste contenant le vecteur des noms de lignes, et le second élément une liste contenant le vecteur des noms de colonnes.
```{r}
femmes <-
  tibble(height =c(58, 59, 60, 61, 62, 63, 64, 65, 66,
                   67, 68,69, 70, 71, 72),
         weight =c(115, 117, 120, 123, 126, 129, 132, 
                   135, 139,142, 146, 150, 154, 159, 164))
colnames(femmes)
rownames(femmes)
dimnames(femmes)
```


```{block2, type='remarque', echo=TRUE}
Lorsqu'on extrait des éléments d'un objet à l'aide des noms, les attributs de l'objet d'origine ne sont pas altérés.
```

Pour remplacer des valeurs, on utilise encore la flèche d'assignation. R produit un message d'erreur si l'élément de remplacement n'est pas de la bonne longueur pour le _tibble_ ou le _data frame_.
```{r donnees_manip_acces_noms_4, error=TRUE}
tb <- tibble(x = seq_len(3), y = rep(2,3), z = c(1,4,3))
tb$x <- rep(NA, 3)
tb
tb$x <- rep(1, 4)
tb  # La modification n'a pas été faite
# Attention
is.list(tb$x)
tb$x <- list(4,3,2)
tb$x	# La colonne "x" a changé de structure !
```

### Chaînes de caractères

Savoir manipuler les chaînes de caractères permet de gagner énormément de temps dans le traitement de données texte, mais permet également de produire des sorties, graphiques ou non, plus lisibles et compréhensibles que les affichages par défaut proposés par R. Le lecteur ou la lectrice intéressé•e par la manipulation avancée des chaînes de caractères en R est invité à consulter l'_ebook_ de Gaston Sanchez [@Sanchez_2013_Handling]. Une excellente visualisation de la manipulation des chaînes de caractères est également proposée dans l'e-book de Lise Vaudor : [https://perso.ens-lyon.fr/lise.vaudor/Descriptoire/_book/manipuler-des-strings-package-stringr.html](Le Descriptoire: Recueil et analyse de texte avec R).

#### Concaténation


La fonction `cat()` concatène et affiche à l'écran des objets. Les arguments qui sont fournis sont convertis en vecteurs de chaînes de caractères, qui sont ensuite concaténés en un seul vecteur de caractères. Les éléments de ce vecteur sont ensuite joints entre eux, et éventuellement séparés par un caractère différent de l'espace, si l'argument `sep` est modifié.
```{r}
cat("Hello", "World", "!")
# En ajoutant un passage à la ligne entre chaque élément
cat("Hello", "World", "!", sep = "\n")
cat(matrix(1:6))
```



```{block2, type='remarque', echo=TRUE}
Le caractère `\` (barre oblique inversée, ou _backslash_) est le caractère d'échappement en R. Il permet d'afficher certains caractères, comme les guillemets dans une chaîne elle-même définie à l'aide de guillemets, ou bien les caractères de contrôle, comme la tabulation, le saut de ligne, etc. Le fichier d'aide \texttt{?Quotes} de R fournir de plus amples détails. Le tableau ci-dessous fournit quelques exemple courants.

| Caractère | Description             | Caractère | Description       |
| ----------|-------------------------|-----------|-------------------|
| `\n`      | Nouvelle ligne          | `\r`      | Retour à la ligne |
| `\t`      | Tabulation              |`\b`       | Retour arrière    |
| `\\`      | Barre olbique inversée  | `\'`      | Apostrophe        |
| `\"`      | Apostrophe double       |`\‘`       | Accent grave      |

```



La fonction `str_c()` du _package_ {`stringr`} convertit en chaîne de caractères les éléments passés en argument puis les concatène. Il est tout à fait possible de stocker le résultat dans un objet, dans la mesure où le résultat de l'évaluation de `str_c()`, contrairement à celui de l'évaluation de `cat()` est une chaîne de caractères. L'argument `sep` permet de définir la chaîne de caractères séparant les termes (rien par défaut).

Il est nécessaire de charger le _package_ avant d'appeler les fonctions qu'il contient (et de l'installer lors de la première utilisation).
```{r donnees_manip_strings_paste}
library(stringr)
x <- str_c("Hello", "World", "!", sep = " ")
x
```


La fonction `str_c()` dispose aussi de l'argument `collapse`, qui est utile pour joindre les éléments d'un vecteur dans une même chaîne de caractères.
```{r donnees_manip_strings_paste_collapse}
str_c(c("Marseille", "Bouches-du-Rhône"))
# Il n'y a qu'un argument, donc le séparateur est inutile !
str_c(c("Marseille", "Bouches-du-Rhône"), sep = ", ")
# En ajoutant l'argument collapse
str_c(c("Marseille", "Bouches-du-Rhône"), collapse = ", ")
```


```{block2, type='remarque', echo=TRUE}
La fonction `str_c()` s'appuie en fait sur la fonction `paste()` du _package_ {`base`}. Par défaut, la chaîne de séparation utilisée dans `paste()` est une espace. La fonction `paste0()` permet quant à elle de concaténer les chaînes sans séparateur.
Il existe cependant de légères différences entre les deux fonctions, comme la festion des éléments `NULL` et `character(0)` :
```

```{r donnees_manip_strings_paste_differences}
paste("You", "shall", character(0), "not", NULL, "pass")
str_c("You", "shall", character(0), "not", NULL, "pass", sep = " ")
```



Si les objets donnés en argument à la fonction `str_c()` sont de tailles différentes, un recyclage est effectué par R.
```{r}
str_c("Hello", c("Julien-Yacine", "Sonia", "Victor"))
```



Attention, R convertit les valeurs manquantes (`NA`) en chaînes de caractères `"NA"`.
```{r donnees_manip_strings_paste_na}
str_c("Hello", NA)
```

```{block2, type='remarque', echo=TRUE}
Quand on souhaite accéder à une variable en renseignant son nom en utilisant la fonction `str_c()`, il faut faire appel à la fonction `get()`.
```

```{r}
variable_1 <- 5
# Affiche la chaîne "variable_1"
str_c("variable_", 1)
# Affiche le contenu de la variable nommée "variable_1"
get(str_c("variable_", 1))
```

#### Conversion en majuscules ou minuscules

Afin de passer une chaîne de caractères en majuscules ou en minuscules, le _package_ {`stringr`} propose les fonctions `str_to_upper()` et `str_to_lower()`.
```{r}
x <- "Bonjour !"
str_to_upper(x)
str_to_lower(x)
```

#### Compter le nombre de caractères d'une chaîne

La fonction `str_length()` du _package_ {`stringr`} indique le nombre de caractères contenus dans une chaîne.
```{r donnees_manip_strings_nchar}
str_length("Bonjour")
```

La fonction `str_length()` s'appuie sur la fonction `nchar()` du _package_ {`base`}. On peut noter que la longueur de `NA` vaut NA avec `str_length()` et `2` avec la fonction native `nchar()`.

```{donnees_manip_strings_stringr_length}
texte <- c("Mais enfin", "c'est quoi", "un gigowatt ?", NA)
str_length(string = texte)
nchar(x = texte)
```

#### Extraction de sous-chaînes

Pour extraire une sous-chaîne, on peut utiliser la fonction `str_sub()` du _package_ {`stringr`}, qui prend en arguments une chaîne de caractères, la position du début et celle de la fin de l'élément à extraire. Attention, l'indice du premier élément, tout comme pour les vecteurs, est 1 en R.
```{r donnees_manip_strings_substr}
x <- "Debt is one person's liability, but another person's asset."
str_sub(x, 1, 4)
```


Il est possible d'utiliser la flèche d'assignation après la fonction `str_sub()` pour remplacer la sous-chaîne extraite par une autre. Si la chaîne de remplacement est trop longue, elle n'est pas tronquée pour avoir la même longueur que celle qui est extraite.
```{r donnees_manip_strings_substr_2}
str_sub(x, 1, 4) <- "Remplacement"
x
```

L'argument `string` de la fonction `str_sub()` peut être un vecteur. Dans ce cas, la fonction est appliquée à chaque élément du vecteur.
```{r donnees_manip_strings_substr_3}
str_sub(c("Rouge", "Vert", "Bleu"), 2, 3)
```


Lors du remplacement, R peut avoir recours au recyclage.
```{r donnees_manip_strings_substr_recyclage}
x <- c("Rouge", "Vert", "Bleu")
str_sub(x, 2, 3) <- c("!!", "@@")
x
```


En fournissant aux arguments `start` et `end` des valeurs négatives, on indique à R de lire la chaîne à l'envers :
```{r donnees_manip_strings_stringr_sub}
texte <- "le train de tes injures roule sur le rail de mon indifférence"
str_sub(string = texte, start = 4, end = 8)

# Compter à partir du dernier caractère
str_sub(string = texte, start = -12, end = -1)
str_sub(string = texte, start = -16)
```


La fonction `str_sub()` s'appuie sur la fonction `substr()` du _package_ {`base`}, mais propose quelques améliorations.

Dans le cas du remplacement d'une chaîne extraitre par une autre, on distingue trois cas :

- la chaîne de remplacement est de même longueur que celle extraite : `str_sub()` et `substr()` se comportent de la même manière ;
- a chaîne de remplacement est plus courte que celle extraite : avec `substr()`, la chaîne de remplacement est complétée par la fin de celle extraite, tandis qu'avec `str_sub()`, la chaîne extraite est retirée et remplacée par celle de remplacement ;
-  la chaîne de remplacement est plus longue que celle extraite : avec `substr()`, la chaîne de remplacement est tronquée, tandis qu'elle ne l'est pas avec `str_sub()`.

```{r donnees_manip_strings_stringr_sub_2}
texte <- "le train de tes injures roule sur le rail de mon indifférence"
# On copie le contenu de texte dans une nouvelle variable
texte_2 <- texte

# Remplacement plus court que la chaîne extraite
str_sub(string = texte, start = 17, end = 23)
str_sub(string = texte, start = 17, end = 23) <- "jurons"
substr(x = texte_2, start = 17, stop = 23) <- "jurons"
texte ; texte_2

# Remplacement plus long que la chaîne extraite
str_sub(string = texte, start = 1, end = 8)
str_sub(string = texte, start = 1, end = 8) <- "la locomotive"
substr(x = texte_2, start = 1, stop = 8) <- "la locomotive"
texte ; texte_2
```

#### Recherche de chaînes de caractères {#manip-strings-regex}

Quand on souhaite trouver un motif (_pattern_) dans un vecteur de chaînes de caractères, on peut utiliser la fonction `str_detect()` du _package_ `stringr`. Elle retourne les indices des éléments du vecteur dans lesquels le motif a été trouvé.
```{r donnees_manip_strings_grep}
str_detect(string = c("Pomme", "Poire", "Ananas"), pattern = "o")
```

Pour remplacer la première occurrence du motif trouvé par une autre chaîne (qui n'est pas tenue d'être de la même longueur de caractères), on peut utiliser la fonction `str_replace()`.
```{r donnees_manip_strings_sub}
str_replace(string = c("Pomme", "Poire", "Ananas"), pattern = "a", replacement = "@@")
```

Si on désire remplacer toutes les occurrences trouvées, il faut alors utiliser la fonction `str_replace_all()`.
```{r donnees_manip_strings_gsub}
str_replace_all(string = c("Pomme", "Poire", "Ananas"), pattern = "a", replacement = "@@")
```


Si on souhaite ignorer la casse, il suffit de faire appel à la fonction `regex()` en précisant à l'aide de l'argument `ignore_case` que l'on souhaite ne pas prendre en compte la casse :
```{r donnees_manip_strings_ignore_case}
str_detect(string = c("Obi-Wan Kenobi", "Darth Vader"), pattern = "w")
str_detect(string = c("Obi-Wan Kenobi", "Darth Vader"), 
           pattern = regex("w", ignore_case = TRUE))
```



Pour briser une chaîne en fonction d'un motif, le _package_ {`stringr`} propose la fonction `str_split()`.
```{r donnees_manip_strings_ignore_splitstr}
x = "Criquette ! Vous, ici ? Dans votre propre salle de bain ? Quelle surprise !"
str_split(string = x, pattern = " ")
```


Une des rares fonctions du _package_ `stringr` ne commençant pas par le préfixe `str` est la fonction `word()`. Comme son nom le laisse présager, elle permet d'extraire des mots dans une phrase. Les mots sont repérés par défaut par une espace, mais il est possible de préciser un séparateur différent avec l'argument `sep`. L'argument `start` attend une valeur entière donnant la position du premier mot à extraire (celle du premier mot de la phrase, par défaut). Si la valeur est négative, le comptage s'effectue de la droite vers la gauche. L'argument `end` attend l'entier donnant la position du dernier mot à extraire (vaut la valeur de `start` s'il est omis). Encore une fois, si la valeur est négative, le comptage s'effectue de la droite vers la gauche.
```{r donnees_manip_strings_stringr_word}
phrase <- c("Mademoiselle Deray, il est interdit de manger de la choucroute ici.",
            "Oh si si, prenez un chewing-gum, Émile.")
word(phrase) # Extraction du premier mot
word(phrase, 2) # Extraction du second mot
word(phrase, -1) # Extraction du dernier mot
word(phrase, 2, -1) # Extraction du second au dernier mot

# Du premier au dernier mot, du second au dernier, et du troisième au dernier
# pour le premier élément de phrase
word(phrase[1], 1:3, -1)

# Premier mot, Premier et second mot, Premier et troisième mot
# pour le second élément de phrase
word(phrase[2], 1, 1:3)
```


```{block2, type='remarque', echo=TRUE}
La fonction `str_detect()` s'appuie sur la fonction `grepl()` du _package_ {base} ; les fonctions `str_replace()` et `str_replace_all()` sur la fonction `sub()` du _package_ {`base`}. La fonction `str_split()` correspond à la fonction `strsplit()` du _package_ {`base`}.
```

Des recherches bien plus complèxes et puissantes peuvent être effectuées avec R, et sont présentées dans la Section\ \@ref(regex).


#### Nettoyage, complétion

##### La fonction `str_dup()`



La fonction `str_dup()` du _package_ {`stringr`} permet de dupliquer du texte. Elle est vectorisée à la fois pour le vecteur de texte à fournir à l'argument `string` et au vecteur d'entiers à fournir à l'argument `times`.
```{r donnees_manip_strings_stringr_dup}
texte <- c("bla", "ah", "eh")
str_dup(texte, 2)
str_dup(texte, 1:3)
```

##### La fonction `str_pad()`


Certains fichiers de données ont des largeurs fixes pour chaque colonne. Si on désire créer facilement ce genre de fichiers, la fonction `str_pad()` du _package_ `stringr` peut se révéler très pratique. En effet, elle permet de définir un caractère à insérer avant ou après une chaîne, ou bien avant et après, et de le répéter un nombre donné de fois. On précise la longueur des chaînes retournées avec l'argument `width`, le caractère à insérer pour éventuellement compléter la chaîne avec l'argument `pad` et le côté sur lequel insérer ce caractère avec l'argument `side` pouvant prendre les valeurs `"left"`, `"right"` ou `"both"`.
```{r donnees_manip_strings_stringr_pad}
coords <- c(lat = "48.11", long = "-1.6794")
str_pad(string = coords, width = 7, side = "left", pad = " ")

# Les chaînes plus longues que la valeur fournie à width sont inchangées
str_pad(c("Gauthier", "Pascaline"), 3)
```

Cette fonction est également utile lorsque l'on veut créer des noms de fichiers préfixés par un nombre, de manière à permettre leur rangement par ordre croissant dans l'explorateur de fichier (`10.txt` viendra avant `9.txt` tandis que `09.txt` viendra avant `10.txt`).

##### La fonction `str_trim()`



Pour retirer des caractères blancs (e.g., espaces, sauts de ligne, retours à la ligne, quadratins, etc.), on peut utiliser des méthodes abordées dans la Section\ \@ref(manip_strings_regex), ou bien la fonction `str_trim()` du _package_ {`stringr`}. Elle retire tous les caractères blancs à gauche et à droite d'une chaîne de caractères. L'argument `side` permet de choisir le côté pour lequel on désire retirer les caractères blancs. Il peut prendre les valeurs `both` (par défaut), `left` ou `right`.
```{r donnees_manip_strings_stringr_trim}
texte <- c("\n\nPardon, du sucre ?", "Oui, seize   \n ", "...\t\t...\t")
str_trim(texte, side = "both")
```


### Dates



Comme indiqué dans la Section\ \@ref(structure-dates), les dates en R peuvent être de trois classes différentes, `Date`, `POSIXct` et `POSIXlt`. Dans cette Section, nous allons voir comment manipuler ces dates, à l'aide des fonctions du _package_ {`lubridate`}.


#### Extraction

Le _package_ {`lubridate`} propose quelques fonctions pour accéder aux éléments d'une date.

| Fonction | Extraction |
|----------|------------|
| `second()` | secondes (0–59) |
| `minute()` | minutes (0–59) |
| `hour()` | heures (0–23) |
| `day()`, `mday()` | jour du mois (1–31) |
| `wday()` | jour de la semaine (1–7), le dimanche étant le 1 |
| `yday()` | jour de l'année (1–366) |
| `week()` | numéro de la semaine dans l'année. Les semaines sont définies comme les pé- riodes complètes de 7 jours s'étant déroulées depuis le premier janvier, plus 1 |
| `isoweek()` | Semaine de l'année (00-53). Si la semaine (qui commence un lundi) qui contient le 1er janvier a 4 jours ou plus dans la nouvelle année, alors elle est considérée comme la semaine 1. Sinon, elle est considérée comme la dernière de l'année précédente, et la suivante est considérée comme semaine 1 |
| `month()` | mois (1–12) |
| `year()` | année, uniquement celles après l'an 1 |
| `tz()` | fuseau horraire |

Les fonctions `wday()` et `month()` permettent aussi d'afficher le jour de la semaine et le mois, respectivement, en chaîne de caractères, en donnant leur nom dans le langage par défaut de votre session R. Pour cela, il faut attribuer la valeur `TRUE` a l'argument `label`. Si on souhaite les abréviations, il faut donner la valeur `TRUE` à l'argument `abbr` en sus.

```{r manip_dates_lubridate_package_extraction, messages=FALSE, warning=FALSE}
library(lubridate)
(d <- ymd_hms("2020-03-17 23:59:59"))

lubridate::wday(d, label = TRUE)
lubridate::wday(d, label = TRUE, abbr = TRUE)
```

Il arrive que l'on préfère obtenir ces noms dans une autre langue (lorsque l'on doit réaliser des graphiques en anglais, par exemple). Deux options simples peuvent être mises en place : la traduction "à la main", en créant un tableau de correspondande entre la langue par défaut de la session R et celle désirée. La seconde solution est plus pratique. Elle consiste à faire appel à l'argument `locale`  des fonctions de {`lubridate`}. Il suffit de fournir à cet argument le nom du local à utiliser. Le seul hic, est que ce nom est dépendant du système... Il faut donc le prendre en compte lors de la rédaction de codes, pour que le script puisse être lancé sur un système Unix ou Windows.

Sous Unix, on peut afficher l'ensemble des noms disponibles avec la commande système suivante (évaluée directement depuis la console R) :

```{r get_system_locale, eval=FALSE}
system("locale -a", intern = TRUE)
```

Pour Windows, il faut consulter la liste des noms est disponible sur la documentation en ligne de Microsoft : il faut chercher dans un moteur de recherche l'expression : `"MSDN Language Strings"`[^comme indiqué sur [cette réponse](https://stackoverflow.com/a/26604195) sur StakOverflow.].

Ainsi, pour obtenir l'affichage du nom du jour de la semaine en anglais, on écrira :

- Sous Unix :
```{r, eval=FALSE}
wday(ymd("2020-03-17"), label = TRUE, abbr = FALSE,
     locale = "en_US")
```

- Sous Windows:
```{r, eval=FALSE}
wday(ymd("2020-03-17"), label = TRUE, abbr = FALSE,
     locale = "english_us")
```


Si on désire que le script soit exportable sur différents systèmes d'exploitation, on peut prévoir, à l'aide d'une instruction conditionnelle (ces aspects seront abordés dans un autre chapitre), les deux cas de figure : Unix ou Windows. En effet, l'expression `.Platform$OS.type` permet d'afficher le type de système d'exploitation :
```{r afficher_OS}
.Platform$OS.type
```

Aussi, pour que le code soit exportable, on peut écrire :
```{r, eval=FALSE}
if(.Platform$OS.type == "unix"){
  wday(ymd("2020-03-17"), label = TRUE, abbr = FALSE,
     locale = "en_US")
}else{
  wday(ymd("2020-03-17"), label = TRUE, abbr = FALSE,
     locale = "english_us")
}
```


Lorsque les formats de dates ne respectent pas les standards habituels (c'est le cas par exemple avec des dates que l'on peut obtenir _via_ l'API de Twitter), les fonctions du type `ymd_hms()` ne parviendront pas à reconnaître le format. Le _package_ {`lubridate`} dispose d'une fonction qui permettra de définir soi-même le format de la date : `parse_date_time()`

Admettons que nous ayons une date sous forme de chaîne de caractères écrite de la sorte :
```{r}
x <- "Fri Dec 25 20:12:00 +0001 2020"
```

Il faut indiquer à l'argument `orders` l'ordre dans lequel les différents éléments composant la date apparaissent. La Section\ \ref(dates-POSIXct) recense tous les éléments de dates dans un tableau. Ces éléments sont utiles ici. On comprend que la date contient le jour de la semaine abrégé (`%a`), le mois abrégé (`%b`), puis le numéro du jour dans le mois (`%d`) etc. De plus, les abréviations correspondent au local anglais, il faut dont indquer à l'argument `locale` que la date est rédigée en anglais.

```{r}
parse_date_time(x, orders = "%a %b %d %H:%M:%S %z %Y", locale = "en_US")
```




#### Opérations

Avant de présenter quelques exemples, créons quelques variables de dates. Rappelons-nous qu'avec les fonctions ne prenant pas en compte l'heure, la minute et la seconde, les objets créés avec les fonctions du _package_ {`lubridate`} sont de classe `Date`. Si ces éléments sont pris en compte, les objets sont de type `POSIXct`.

```{r manip_dates_operations}
# Quelques dates
d_date_1 <- ymd("2019-09-01")
d_date_2 <- ymd("2020-10-21")
class(d_date_1)

d_posix_ct_1 <- ymd_hms("2020-03-17 12:32:28")
d_posix_ct_2 <- ymd_hms("2020-05-11 13:55:44")
class(d_posix_ct_1)
```


Pour ajouter ou retirer des durées de temps, il faut se rappeler comment sont stockées les dates. Avec les objets de mode `Date`, il s'agit d'un nombre de jours. Aussi, additioner un nombre $n$ à un objet de type `date` retourne la date $n$ jours plus tard. Pour les objets de classe `POSIXct` ou `POSIXlt`, comme R stock la date en secondes, l'ajout d'un nombre $n$ retourne la date augmentée de $n$ secondes.
```{r manip_dates_operations_diff_addition}
d_date_2
d_date_2 + 10
d_date_2 - 10

d_posix_ct_2
d_posix_ct_2 + 10
d_posix_ct_2 - 10
```


Toujours dû à ce stockage interne en jours ou secondes,  il est possible de comparer facilement deux dates entre-elles, avec les opérateurs classiques.
```{r manip_dates_operations_comparaison}
d_date_1 > d_date_2
d_posix_ct_2 > d_posix_ct_1
d_posix_ct_2 == d_posix_ct_1
```

#### Intervalles de dates

La fonction `interval()` du _package_ `lubridate` crée un intervalle de temps entre deux dates. On peut également utiliser l'opérateur  `%--%`.
```{r manip_dates_lubridate_package_tz_intervalle}
debut <- ymd_hms("2020-03-17 07:00:00", tz = "Australia/Perth")
fin <- ymd_hms("2020-05-11 23:00:00", tz = "Australia/Perth")

(intervalle_1 <- interval(debut, fin))
debut %--% fin
```

La durée d'un intervalle s'obtient avec la fonction `int_length()`. Le résultat est exprimé en secondes.
```{r manip_dates_lubridate_package_tz_intervalle_length}
int_length(intervalle_1)
```

Pour exprimer cette différence de dates dans un format plus compréhensible pour un humain, {`lubridate`} propose deux approches : les durées (_durations_) et les époques (_periods_). La différence entre les deux est que les _durations_ ne tiennent pas en compte des fluctuations de la ligne du temps, comme les années bissextiles, tandis que les _periods_ le font.


Les fonctions qui crééent les durées possèdent le nom au pluriel de ces durées précédé du préfixe `d` ; les fonctions qui créent les époques laissent quant à elle tomber le préxixe.

```{r manip_dates_lubridate_package_durees}
minutes(10)
dminutes(10)
```


Pour illustrer la différence entre les _durations_ et les _periods_, regardons un exemple avec la fonction `leap_year()` qui retourne un logique indiquant si l'année passée en argument est bissextile.
```{r manip_dates_lubridate_package_durees_leap}
leap_year(2000) # 2000 était une année bissextile

# Ajout d'une durée d'un an, soit 365 jours
ymd("2000-01-01") + dyears(1)

# Ajout d'une période d'un an, soit 366 jours dans ce cas
ymd("2000-01-01") + years(1)
```


Après ce détour, nous pouvons revenir à ce qui nous intéresse à l'origine : obtenir la durée d'un intervalle entre deux dates exprimée dans un format plus compréhensible pour un humain. On peut obtenir la durée d'un intervalle exprimée en jours, en mois, en semaines, etc. en le divisant par une durée.
```{r manip_dates_lubridate_package_durees_div, tidy.opts=list(width.cutoff=70)}
intervalle <- interval(ymd_hms("2020-03-17 10:00:00"),
                           ymd_hms("2020-05-11 08:00:00"))
# Nombre de jours de confinement durant la pandémie de Covid-19
intervalle / ddays(1)

# Nombre de durées de 2 jours
intervalle / ddays(2)

# Nombre d'heures
intervalle / dhours(1)
```

L'ensemble des _durations_ est donné dans le tableau ci-dessous.

| Fonction | Description |
| :---------- | :------------- |
| | dseconds() | Secondes |
| dminutes() | Minutes |
| dhours() | Heures |
| ddays() | Jours |
| dweeks() | Semaines |
| dmonths() | Mois |
| dyears() | Années |
| dmilliseconds() | Milisecondes  |
| dmicroseconds() | Microsecondes |
| dnanoseconds() | Nanosecondes |
| dpicoseconds() | Picosecondes |


On peut chercher si deux intervalles se chevauchent, avec la fonction `int_overlaps()`.
```{r manip_dates_lubridate_package_tz_intervalle_2}
debut_2 <- ymd_hms("2020-03-01 08:00:00", tz = "Australia/Perth")
fin_2 <- ymd_hms("2020-10-01 10:00:00", tz = "Australia/Perth")

debut_3 <- ymd_hms("2020-10-02 09:00:00", tz = "Australia/Perth")
fin_3 <- ymd_hms("2020-10-02 10:00:00", tz = "Australia/Perth")

intervalle_1
(intervalle_2 <- interval(debut_2, fin_2))
(intervalle_3 <- interval(debut_3, fin_3))

int_overlaps(intervalle_1, intervalle_2)
int_overlaps(intervalle_1, intervalle_3)
```

On peut utiliser les fonctions ensemblistes sur des intervalles (`union()` (union), `intersect()` (intersection), `setdiff()` (différence), `setequal()` (égalité) et `%within%` (tester si une date est dans un intervalle)).
```{r manip_dates_lubridate_package_tz_intervalle_union}
lubridate::union(intervalle_1, intervalle_2)
lubridate::intersect(intervalle_1, intervalle_3)
lubridate::setdiff(intervalle_1, intervalle_2)
base::setequal(intervalle_1, intervalle_1)
debut_2 %within% intervalle_1
```

Après avoir utilisé ces fonctions ensemblistes, on peut être amené à vouloir extraire les bornes de l'intervalle. Il faut alors utiliser les fonctions `int_start()` et `int_end()` pour les bornes inférieures et supérieures respectivement.
```{r manip_dates_lubridate_package_tz_intervalle_bornes}
(intervalle <- lubridate::setdiff(intervalle_1, intervalle_2))
int_start(intervalle)
int_end(intervalle)
```


La fonction `int_flip()` échange les bornes de l'intervalle. Le nouvel intervalle possède la même longueur, mais une direction opposée.
```{r manip_dates_lubridate_package_tz_intervalle_bornes_flip}
int_flip(intervalle_1)
```


La fonction `int_shift()` décale le début et la fin de l'intervalle, en fonction de la valeur fournie à l'argument `by`, qui doit être un objet de durée, que l'on peut obtenir avec la fonction `duration()`.
```{r manip_dates_lubridate_package_tz_intervalle_bornes_shift}
int_shift(intervalle_1, duration(days = 5))
```


La fonction `int_aligns()` permet de tester si deux intervalles ont une borne commune, sans prendre en compte la direction de chaque intervalle. Ainsi, la fonction teste si les moments les plus anciens ou plus récents de chaque intervallent arrivent au même moment.
```{r manip_dates_lubridate_package_tz_intervalle_bornes_aligns}
int_1 <- interval(ymd("2019-10-01"), ymd("2019-10-05"))
int_2 <- interval(ymd("2019-10-04"), ymd("2019-10-01"))
int_3 <- interval(ymd("2020-10-01"), ymd("2020-10-05"))

int_aligns(int_1, int_2)
int_aligns(int_1, int_3)
```


#### Séquence de dates


Il est possible d'utiliser la fonction `seq()` avec des dates, qu'elles soient stockées au format `date`, `POSIXct` ou `POSIXlt`. Le lecteur ou la lectrice s'asurera de bien comprendre les exemples suivants.

```{r}
# Avec des objets de class date
seq(ymd("2020-09-01"), length = 4, by = "day") 
# Tous les deux jours
seq(ymd("2020-09-01"), length = 4, by = "2 days") 
# En spécifiant le début et la date maximum
seq(ymd("2020-09-01"), ymd("2020-09-08") , by = "2 days") 

# Avec des objets de classe POSIXct
seq(ymd_hms("2020-03-17 12:32:28 "), by = "9 months", length = 2)
```

#### Fuseaux horaires



Il peut être utile de faire des conversions d'heures, pour obtenir la valeur dans un autre fuseau horaire. La fonction `with_tz()` le permet.
```{r manip_dates_lubridate_package_tz}
# Une heure à Paris
(d <- ymd_hms("2020-10-30 20:00:00", tz = "Europe/Paris"))

# L'heure équivalente à New York City
with_tz(d, "America/New_York")
```


La fonction `force_tz()` permet de remplacer le fuseau horaire d'une date.
```{r manip_dates_lubridate_package_tz_force}
(d <- ymd_hms("2020-10-30 20:00:00", tz = "Europe/Paris"))

force_tz(d, "America/New_York")
```

### Calculs matriciels

Cette section aborde les opérations effectuées sur des matrices.

#### Addition, soustraction

L'addition et la soustraction de deux matrices $A$ et $B$ de même type ou d'une matrice et d'un scalaire $a$ se font avec les opérateurs `+` et `-` respectivement.
```{r donnees_manip_matrices_calculs}
(A <- matrix(c(1, 3, 2, 2, 2, 1, 3, 1, 3), ncol = 3))
(B <- matrix(c(4, 6, 4, 5, 5, 6, 6, 4, 5), ncol = 3))
(C <- matrix(c(0, 3, 1), ncol = 1))
a <- 2
A+a
A+B
A-a
A-B
```

#### Multiplication, division


La multiplication et la division par un scalaire ($aA$ et $A/a$) se font en utilisant les opérateurs `*` et `/`respectivement.
```{r}
a*A
A/a
```

La transposée d'une matrice ($A^\top$) s'obtient grâce à la fonction `t()`.
```{r donnees_manip_matrices_calculs_transposee}
t(A)
```

La conjuguée d'une matrice ($\overline{A}$) s'obtient avec `Conj()`.
```{r donnees_manip_matrices_calculs_conjuguee}
Conj(A)
```

Pour multiplier deux matrices ($AB$), l'opérateur en R est `%*%`.
```{r donnees_manip_matrices_produit}
A%*%C
```

Il ne faut pas confondre avec l'opérateur `*`, qui, lorsqu'il est employé entre deux matrices, effectue la multiplication terme à terme.
```{r}
A*B
```

L'inversion d'une matrice ($A^{-1}$) s'effectue avec la fonction `solve()`.
```{r donnees_manip_matrices_inversion}
solve(A)
```

Ce qui permet d'effectuer une division matricielle ($BA^{1}$).
```{r donnees_manip_matrices_division_matrices}
B %/% solve(A)
```

La fonction `crossprod()` effectue le produit avec transposition ($A^\top B$).
```{r donnees_manip_matrices_crossprod}
crossprod(A,B)
```

Elle réalise l'opération plus rapidement que l'instruction suivante :
```{r donnees_manip_matrices_crossprod_2}
t(A) %*% B
```

#### Déterminant, trace


Le calcul du déterminant d'une matrice ($\textrm{det}(A)$) s'obtient avec la fonction `det()`.
```{r donnees_manip_matrices_det}
det(A)
```

En utilisant la fonction `diag()`, qui donne les éléments de la diagonale de la matrice passée en argument, on peut facilement obtenir la trace de la matrice ($tr(A)$).
```{r donnees_manip_matrices_trace}
diag(A)
sum(diag(A))
```
### Tableaux de données {#tableaux_de_donnees}

Cette partie montre comment manipuler la structure de données la plus fréquemment rencontrée en économétrie : les tableaux de données. Il sera considéré que ces tableaux de données sont sous la forme de _tibbles_ plutôt que _data frame_. Les manipulations sont principalement effectuées à l'aide de fonctions issues de l'environnement tidyverse, et plus particulièrement du _package_ {`dplyr`}. Les descriptionsdes fonctions du _package_ {`dplyr`} sont fortement inspirées de la [vignette du _package_](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html).


#### L'opérateur Pipe

Avant de commencer à présenter les manipulations de données, il peut être intéressant d'introduire un opérateur : Pipe (`%>%`). Cet opérateur provient du _package_ {`magrittr`}. Avant de présenter cet opérateur en soi, et afin de montrer son utilité, quelques exemples ne l'*utilisant pas* sont présentés. Les explications sont issues de celles de @grolemund_2018_r.

Admettons qu'il soit nécessaire d'effectuer plusieurs opérations à la suite, sur un tableau de données. Par exemple, considérons un tableau dont chaque ligne contient les ventes mensuelles (en colonnes, une par mois) des bars du Cours Julien à Marseille (en lignes) et que l'on souhaite réaliser les opérations suivantes :

1. Calculer la moyenne du chiffre d'affaires (CA) à l'année pour chaque bar ;
2. Ordonner les observations par valeurs croissante des moyennes ;
3. Afficher le top 5 des bars avec le plus gros CA.

Nous allons présenter trois manières différentes de procéder, puis nous regarderons la solution avec le fameux opérateur pipe dont on tait encore ici l'utilité (quel suspens !).

*Première méthode*

La première méthode consiste à *sauvegarder un nouvel objet à chaque étape (inutile de tenter d'évaluer le code qui suit, il ne fonctionnera pas : il s'agit d'un exemple totalement fictif) :
```{r pipe_sol_1, eval=FALSE}
top_ca_bars_anuel_1 <- calcul(ca_bars_cours_ju, type = "moyenne")
top_ca_bars_anuel_2 <- ordonner(top_ca_bars_anuel_2,
                            type = "decroissantes", variable = "ca_annuel")
top_ca_bars_anuel_3 <- head(top_ca_bars_anuel_2, 5)
```

Cette manière de faire requière de créer de nombreux objets intermédiaires avant d'arriver au résultat. On peut noter que le nom de ces objets intermédiaires peut ne pas être facile à trouver/comprendre. Toutefois, s'il est possible de trouver des noms sensés, cette méthode peut être adaptée à la situation. On note également que le code devient plus difficile à lire du fait des nombreux noms de variables inintéressantes.


```{block2, type='remarque', echo=TRUE}
Si le tableau initial contient un volume de données importantes, la création des objets intermédiaire n'occupera pas un espace en mémoire important (R gère cela plutôt bien).
```

*Deuxième méthode*

La deuxième méthode consiste à écraser l'objet original à chaque étape :
```{r pipe_sol_2, eval=FALSE}
top_ca_bars_anuel_1 <- calcul(ca_bars_cours_ju, type = "moyenne")
top_ca_bars_anuel_1 <- ordonner(top_ca_bars_anuel_1,
                            type = "decroissantes", variable = "ca_annuel")
top_ca_bars_anuel_1 <- head(top_ca_bars_anuel_1, 5)
```

Si cette solution est moins pénible à rédiger que la précédente, on peut noter qu'elle ne facilite toutefois pas le debogage et que le nom de l'objet modifié a été inscrit 5 fois (et vient donc perturber la lecture rapide du code).


*Troisième méthode*

La troisième méthode, absolument hideuse à mes yeux (celle par laquelle j'ai commencé il y a quelques années, _mea culpa_), consiste à rédiger une composition de fonction :
```{r pipe_sol_3, eval=FALSE}
top_ca_bars_anuel_1 <- 
  head(
    ordonner(
      calcul(
        ca_bars_cours_ju, type = "moyenne"),
      type = "decroissantes", variable = "ca_annuel"
    ), 
    5
  )
```

Non seulement le temps de rédaction de ce type de code peut être long, mais la lecture du code produit est de surcroît ardue : il faut lire de l'intérieur vers l'extérieur, ce qui est d'autant plus difficile que les arguments de chaque fonction sont éloignés du nom de la fonction.

*Roulements de tambour : l'opérateur Pipe*

L'opérateur permet de réaliser l'opération chaînée de la manière suivante :
```{r pipe_ex_fictif, eval=FALSE}
top_ca_bars_anuel_1 <- 
  ca_bars_cours_ju %>% 
  calcul(type = "moyenne") %>% 
  ordonner(type = "decroissantes", variable = "ca_annuel") %>% 
  head(5)
```

Le membre à gauche de l'opérateur est donné comme premier argument de la fonction à droite de l'opérateur.

Avec cette solution, la lecture est rapide pour une personne humaine et le débogage est facilité. Attention à veiller à ne pas enchaîner de trop nombreuses opérations qui feraient perdre ces avantages.

Si on souhaite appeler explicitement le membre de gauche, on peut utiliser le point `.` comme suit :

```{r pipe_ex_fictif_2, eval=FALSE}
top_ca_bars_anuel_1 <- 
  ca_bars_cours_ju %>% 
  calcul(donnes = ., type = "moyenne") %>% 
  ordonner(donnees = ., type = "decroissantes", variable = "ca_annuel") %>% 
  head(x = ., 5)
```

Comme cet opérateur fait partie de l'environnement `tidyverse` et que la majorité des fonctions admettent en premier argument les données, il n'est pas nécessaire de rajouter le point au premier argument de la fonction à droite de l'opérateur.

Il convient de préciser que si la fonction à droite du Pipe n'admet pas pour premier argument les données, il est nécessaire de préciser l'argument de la fonction qui recevra les données, comme suit :
```{r exemple_pipe_point, eval=FALSE}
donnees %>% fonction(premier_argument = "foo", donnees = .)
```

#### Sélection



Dans la Section\ \@ref(manip-acces), il a été vu que l'accès aux données d'un _tibble_ peut se faire à l'aide du système d'indexation ou bien par celui de nommage, en utilisant la fonction `[()`. Le _package_ `dplyr` propose une autre manière de procéder pour sélectionner des colonnes, ou pour filtrer les données. Ces méthodes ont le mérite d'être faciles à lire. Reprenons le _tibble_ donné en exemple dans la Section\ \@ref(manip-acces).
```{r manip_operations_tibbles_select}
femmes <- tibble(
  height =c(58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68,69, 70, 71, 72),
  weight =c(115, 117, 120, 123, 126, 129, 132, 135,
            139,142, 146, 150, 154, 159, 164))
```

La sélection des colonnes se fait en utilisant la fonction `select()`. On peut noter que le nom des colonnes ne doit pas être entouré de guillemets. Le premier argument correspond au _tibble_, le second et les suivants à la ou les colonnes désirées. L'odre d'apparition des colonnes correspond à celui fourni à la fonction `select()`.
```{r manip_operations_tibbles_select_2}
library(dplyr)
select(femmes, height)
```

Si le nom d'une colonne ne respecte pas les conventions de nommage, il est possible d'y accéder avec `select()` en entourant le nom de la colonne d'accents graves :
```{r manip_operations_tibbles_mauvais_noms}
tb_2 <- tibble(`Un nom` = 1:3, `Un autre` = LETTERS[1:3])
select(tb_2, `Un nom`)
```

Il arrive de vouloir extraire une variable par son nom, ce dernier étant le contenu d'une variable externe (dans une boucle par exemple). La pratique suivante n'est pas recommandée, car ambigüe :
```{r manip_operations_tibbles_string_1}
nom_variable <- "x"
select(tb, nom_variable)
```
On peut aussi noter, à travers l'exemple suivant, que le résultats obtenu n'est pas nécessairement celui attendu (le nom de la colonne et le nom de la variable qui contient la chaîne de caractères sont identiques) :
```{r manip_operations_tibbles_string_2}
nom_variable <- "x"
tb_2 <- tibble(nom_variable = c("A","B", "C"), x = 1:3)
select(tb_2, nom_variable)
```

Une solution consiste à faire précéder le nom de la variable qui contient le nom de la (ou les) colonne(s) que l'on souhaite sélectionner :
```{r manip_operations_tibbles_string_3}
select(tb_2, !!nom_variable)
```

Pour *retirer une colonne*, il suffit de faire précéder le nom de la colonne par le signe moins :
```{r manip_operations_tibbles_retrait}
tb <- tibble(x = seq(1,4), y = x^2, z = LETTERS[1:4], t = letters[1:4])
select(tb, -x)
```

Pour *retirer plusieurs colonnes*, il suffit de placer les noms de colonnes dans un vecteur à l'aide de la fonction c() et de faire précéder l'appel de cette fonction du signe moins :
```{r}
select(tb, -c(x, z))
```

ou de manière équivalente, en listant chaque variable à retirer et en les faisant précéder du signe moins :
```{r}
select(tb, -x, -z)
```

Pour *sélectionner des lignes*, la fonction `slice()` du _package_ {`dplyr`} attend de recevoir les indices des lignes à extraire :
```{r}
tb <- tibble(x = seq(1,4), z = LETTERS[1:4], t = letters[1:4])
slice(tb, c(1,3,4))
```

```{block2, type='remarque', echo=TRUE}
La numérotation des lignes a été changée, elle a été recommencée à zéro.
```
Si la fonction `slice()` reçoit des entiers négatifs, les lignes dont l'indice est donné par la valeur absolue de ces entiers seront retirées :
```{r}
tb <- tibble(x = seq(1,4), z = LETTERS[1:4], t = letters[1:4])
slice(tb, -c(1,3,4))
```

#### Filtrage



Le filtrage par masque a été abordé dans la Section\ \@ref(manip-acces). Encore une fois, le _package_ {`dplyr`} propose une fonction très simple d'emploi pour sélectionner des lignes : `filter()`. Le premier argument est le nom du _tibble_, le second et les suivants correspondent aux expressions à évaluer à l'intérieur du `tibble`. Il est possible de fournir une expression logique complèxe au deuxième argument ou aux suivants. S'il y a plus de deux arguments, une expression logique sera constuite avec les arguments à partir du deuxième, en les liant par un ET logique.
```{r manip_operations_tibbles_filtrage, message=F, warning=F}
# Les femmes dont la taille vaut exactement 60 pouces
femmes %>% 
  filter(height == 60)
# Les femmes dont la masse vaut plus de 120 libres
# et dont la taille est inférieure ou égale à 62 pouces
femmes %>% 
  filter(weight > 120, height <= 62)
# De manière équivalente :
femmes %>% 
  filter(weight > 120 & height <= 62)
# Les femmes dont la masse vaut 150 ou 159 livres
# ou dont la taille est égale à 62 pouces
femmes %>% 
  filter(weight %in% c(150,159) | height == 62)
```

#### Retirer les valeurs dupliquées


Pour se séparer des observations contenues plusieurs fois dans un _tibble_, on utilise la fonction `unique()`.

```{r manip_operations_tibbles_dupli}
# Les observations 1 et 7, ainsi que 3 et 6 sont dupliquées
df <- tibble(x = letters[c(1,2,3,1,4,3,1)],
                 y = letters[c(1,5,2,4,3,2,1)])

unique(df)
```

#### Modification des colonnes


La Section\ \@ref(manip-acces) a posé les bases au sujet de la modification d'objets. Cette section apporte quelques informations supplémentaires.


Une des premières modifications que l'on peut apporter à un _tibble_ est de renommer ses colonnes. On peut s'en sortir sans fournir trop d'efforts à l'aide de la fonction `colnames()` et de la flèche d'assignation :
```{r}
colnames(femmes)
colnames(femmes)[which(colnames(femmes) == "height")] <- "taille"
colnames(femmes)
```


Cependant, cette syntaxe est assez lourde. La fonction `rename()` du _package_ {`dplyr`} propose de réaliser la même tâche de manière plus lisible :
```{r manip_operations_tibbles_modif_colname_2}
femmes <-
  femmes %>% 
  rename(masse = weight)
colnames(femmes)
```

Pour renommer plusieurs colonnes avec la fonction `rename()`, il suffit d'ajouter des arguments :
```{r}
rename(femmes, poids = masse, hauteur = taille)
```


On peut noter qu'avec la fonction `select()`, il est possible de sélectionner une variable et de la renommer directement :
```{r manip_operations_tibbles_modif_colname_remarque}
femmes %>% 
  select(poids = masse, hauteur = taille) %>% 
  head(2)
```

Pour ajouter une colonne, ou pour appliquer des changements à tous les éléments d'une colonne, on peut utiliser la flèche d'assignation :
```{r manip_operations_tibbles_modif_old}
# Nombre de chomeurs et d'actifs en millions de personnes
chomeurs <- tibble(annee = 2012:2008,
nb_chomeurs = c(2.811, 2.604, 2.635, 2.573, 2.064),
pop_active = c(28.328, 28.147, 28.157, 28.074, 27.813))

chomeurs$taux_chomage_0 <- chomeurs$nb_chomeurs / chomeurs$pop_active * 100
```


Comme on peut le voir, il est assez laborieux de devoir réécrire le nom du _tibble_ pour accéder à ses colonnes afin de faire des modifications ou des créations de variables (bien qu'avec uniquement deux variables à utiliser, cela reste encore faisable sans trop de pénibilité). Le _package_ {`dplyr`} propose la fonction `mutate()` pour créer ou modifier une ou plusieurs colonnes.
```{r}
chomeurs <- 
  chomeurs %>% 
  mutate(tx_chomage_1 = nb_chomeurs/pop_active*100,
         log_nb_chomeurs = log(nb_chomeurs))
chomeurs
```


Avec la fonction `mutate()`, il est possible de faire référence directement à la variable créé :
```{r}
chomeurs <- 
  chomeurs %>% 
  mutate(tx_chomage_2 = nb_chomeurs/pop_active*100,
         log_tx_chomage = log(tx_chomage_2))
chomeurs
```


Pour modifier une colonne, il suffit de créer une colonne portant le même nom :
```{r}
chomeurs %>% 
  mutate(annee = annee / 1000)
```

Pour conserver uniquement les variables nouvellement créées, on peut utiliser la fonction `transmute()` du _package_ {`dplyr`} :
```{r}
chomeurs %>% 
  transmute(annee = annee / 1000,
            tx_chomage = nb_chomeurs/pop_active*100)
```


Il existe une méthode qui à première vue semble agréable à utiliser : la fonction `attach()`, qui comme son nom l'indique, détache le tableau de données, c'est-à-dire rend les colonnes qui le composent visibles dans l'espace de travail. La fonction `detach()` produit l'effet inverse, et masque alors de l'espace de travail les colonnes du tableau de données indiqué en argument.
```{r, error=TRUE}
data(quakes)
quakes <- quakes[1:4,]  # On ne prend que quelques observations pour l'exemple
quakes <- as_tibble(quakes)
lat  # lat n'est pas dans l'espace de travail
attach(quakes)
lat	# maintenant il l'est
detach(quakes)
lat	# il est à nouveau masqué
```


Cependant, l'utilisation de la fonction `attach()` cause bien souvent des confusions et problèmes lors de l'emploi d'autres fonctions. À éviter.


#### Tri

Il existe plusieurs manières de trier un tableau. Une ancienne méthode consiste à utiliser la fonction `order()`. Le _package_ {`dplyr`} propose également une solution qui s'intègre bien dans les opérations chaînées, avec la fonction `arrange()`.

Il ne semble pas inutile de présenter `order()`, dans la mesure où cette fonction peut parfois être utile sur des vecteurs en dehors des tableaux de données.

Il est aisé de trier un _tibble_ par ordre croissant ou décroissant d'une ou plusieurs de ses colonnes. Pour ce faire, on peut utiliser la fonction `order()`, qui retourne les rangs de classement des éléments du ou des arguments. En cas d'_ex æquo, les rangs sont classés par ordre d'apparition dans le _tibble_.
```{r donnees_manip_df_order}
tb <- tibble(
  nom = c("Durand", "Martin", "Martin", "Martin", "Durand"),
  prenom = c("Sonia", "Serge", "Julien-Yacine", "Victor", "Emma"),
  note = c(23, 18, 17, 17, 19))
# Ordonner par notes décroissantes
order(tb$note, decreasing = TRUE)
tb[order(tb$note), ]
# Ordonner par ordre alphabétique des noms puis des prénoms
tb[with(tb, order(nom, prenom)), ]
```

```{block2, type='remarque', echo=TRUE}
La fonction `sort()` retourne un vecteur trié par valeurs croissantes ou décroissantes. La fonction `order()` retourne les rangs du classement.
```


La fonction `arrange()` du _package_ {`dplyr`} permet aussi de trier un tableau de données. Son utilisation semble plus aisée pour certains, surtout lorsque le tri s'effectue en fonction de plusieurs colonnes. Comme il n'y a pas de l'argument `decreasing` deux méthodes sont possibles :

- faire appel à la fonction `desc()`, elle aussi contenue dans le _package_ {`dplyr`}, qui permet de trier le vecteur donné en argument par ordre de valeurs décroissantes ;
- faire préceder le nom de la colonne par le signe `-` si les valeurs de la colonne sont numériques.
```{r}
# Ordonner par notes décroissantes
tb %>% arrange(-note)
# Ordonner par ordre alphabétique des noms puis inverse des prénoms
tb %>% arrange(nom, desc(prenom))
```

#### Jointures



Deux fonctions permettent de juxtaposer deuxtableaux de données ou plus entre-eux (cela fonctionne aussi avec des matrices) : `cbind()` et `rbind()`. La première fusionne les colonnes (place les tableaux côte-à-côte) tandis que la seconde fusionne les lignes (empile les tableaux les uns sur les autres). Il faut toutefois veiller à ce que le nombre de lignes des éléments passés en argument de `cbind()` correspondent, et que le nombre de colonnes de ceux passés en argument de `rbind()` correspondent aussi. De plus, lors de l'utilisation de `rbind()`, le nom des colonnes doit correspondre.
```{r}
(A <- tibble(x1 = c(1, -1), x2 = c(0, 3)))
(B <- tibble(x1 = c(3,2), x2 = c(1, 1)))
(C <- tibble(x3 = c(0, 3)))

rbind(A,B)
cbind(A,B)
cbind(A,B,C)
```


Toutefois, lors de la fusion de tableaux de données, l'emploi de la fonction `cbind()` n'est pas très pratique, puisque s'il existe une colonne identique aux tableaux de données à fusionner, elle sera dupliquée dans le résultat de la fusion.
```{r}
(pib <- data.frame(annee = 2010:2013, pib = c(1998.5, 2059.3, 2091.1, 2113.7)))
(importations <- data.frame(annee = 2010:2013, importations = c(558.1, 625.3, 628.5, 629.1)))
cbind(pib, importations)
```

De plus, le but d'une telle opération de juxtaposition se révèle utile en économétrie surtout lorsque l'on désire apparier des données de sources différentes. Il faut donc, avec `cbind()`, s'assurer au préalable que les individus du premier tableau apparaissent dans le même ordre que ceux du second. Cette étape est assez pénible à réaliser, et peut être évitée à l'aide des fonctions du _package_ {`dplyr`}. Ce _package_ propose des fonctions pour joindre deux tableaux de données. Ces fonctions partagent une syntaxe commune : `xx_join(x, y, by = NULL, copy = FALSE, ...)`, où `x` et `y` sont les tableaux à joindre, `by` est un vecteur de chaînes de caractères contenant le nom des variables permettant la jointure (si la valeur est `NULL`, ce qui est le cas par défaut, la jointure se fera à l'aide des variables portant le même nom dans les deux tables).

Les différentes fonctions de jointure sont les suivantes :

—`inner_join()` : toutes les lignes de `x` pour lesquelles il y a des valeurs correspondantes dans `y`, et toutes les colonnes de `x` et `y`. S’il y a plusieurs correspondances dans les noms entre `x` et `y`, toutes les combinaisons possibles sont retournées ;

—`left_join()`: toutes les lignes de `x`, et toutes les colonnes de `x` et `y`. Les lignes dans `x` pour lesquelles il n’y a pas de correspondance dans `y` auront des valeurs `NA` dans les nouvelles colonnes. S’il y a plusieurs correspondances dans les noms entre `x` et `y`, toutesles combinaisons sont retournées ;

—`right_join()`: toutes les lignes de `y`, et toutes les colonnes de `x` et `y`. Les lignes dans `y` pour lesquelles il n’y a pas de correspondance dansxauront des valeurs `NA` dans les nouvelles colonnes. S’il y a plusieurs correspondances dans les noms entre `x` et `y`, toutesles combinaisons sont retournées ;

—`semi_join()`: toutes les lignes de `x` pour lesquelles il y a des valeurs correspondantes dans `y`, en ne conservant uniquement les colonnes de `x`;

—`anti_join()`: toutes les lignes dexpour lesquelles il n’y a pas de correspondances dans `y`, en ne conservant que les colonnes de `x`.

```{r manip_operations_data_frames_fusion_join}
exportations <- tibble(
  year = 2011:2013, 
  exportations = c(572.6, 587.3, 597.8))
importations <- tibble(
  annee = 2010:2012,
  importations = c(558.1, 625.3, 628.5))

exportations ; importations

exportations %>% inner_join(importations, by = c("year" = "annee"))
exportations %>% left_join(importations, by = c("year" = "annee"))
exportations %>% right_join(importations, by = c("year" = "annee"))
exportations %>% semi_join(importations, by = c("year" = "annee"))
exportations %>% anti_join(importations, by = c("year" = "annee"))
```

#### Agrégation


Il arrive de vouloir agréger les valeurs d'une variable, pour passer par exemple d'une dimension trimestrielle à annuelle. Avec des observations spatiales, cela peut aussi être le cas, comme par exemple lorsque l'on dispose de données à l'échelle des départements et que l'on souhaite connaître les valeurs agrégées à l'échelle des régions.



Le _package_ {`dplyr`} propose une fonction simple d'utilisation : `summarise()`. Elle permet de réduire une colonne d'un tableau de données à une seule observation. On lui fournit un tableau de données en premier argument, et une ou plusieurs opérations à réaliser sur le tableau en arguments suivants.
```{r manip_operations_data_frames_agreg_1}
# Nombre d'ingenieurs et cadres au chômage
chomage <- tibble(
  region = rep(c(rep("Bretagne", 4), rep("Corse", 2)), 2),
  departement = rep(c("Cotes-d'Armor", "Finistere",
                      "Ille-et-Vilaine", "Morbihan",
                      "Corse-du-Sud", "Haute-Corse"), 2), 
  annee = rep(c(2011, 2010), each = 6),
  ouvriers = c(8738, 12701, 11390, 10228, 975, 1297,
               8113, 12258, 10897, 9617, 936, 1220), 
  ingenieurs = c(1420, 2530, 3986, 2025, 259, 254,
                 1334, 2401, 3776, 1979, 253, 241))
chomage
# Moyenne de la colonne ouvriers
chomage %>% 
  summarise(moy_ouvriers = mean(ouvriers),
            sd_ouvriers = sd(ouvriers),
            moy_ingenieurs = mean(ingenieurs),
            sd_ingenieurs = sd(ingenieurs))
```


Couplée à la fonction `group_by()` du même _package_, elle prend toute sa puissance. La fonction `group_by()` permet de regrouper les observations d'un tableau de données en sous-groupes, qui sont créés en fonction des variables données en arguments.

Par exemple, si on désire obtenir la somme par année des colonnes `ouvriers` et `ingenieurs` du tableau `chomage` :
```{r manip_operations_tibbles_agreg_group_1}
chomage %>% 
  group_by(annee) %>% 
  summarise(ouvriers = sum(ouvriers),
            ingenieurs = sum(ingenieurs))
```

Si on désire que les calculs soient effectués sur les sous-groupes définis à la fois par les années et les régions, il suffit de fournir les noms de ces deux colonnes du tableau en arguments à la fonction `group_by()` avant d'appliquer la fonction `sum()` aux colonnes contenant les valeurs numériques :

```{r manip_operations_tibbles_agreg_group_2}
chomage %>% 
  group_by(annee, region) %>% 
  summarise(ouvriers = sum(ouvriers),
            ingenieurs = sum(ingenieurs))
```


Attention, si des calculs sur les résultats obtenus sur des sous-groupes doivent être effectués par la suite, il faut penser à dégrouper le tableau obtenu, avec la fonction `degroup()` :
```{r}
chomage %>%
  group_by(annee, region) %>%
  summarise(ouvriers = sum(ouvriers),
            ingenieurs =sum(ingenieurs)) %>% 
  ungroup()
```

#### Faire pivoter un tableau


Devoir faire pivoter un tableau arrive fréquemment en R, principalement pour préparer les données avant de les fournir aux fonctions permettant de réaliser des graphiques. Deux fonctions dans le _package_ {`tidyr`} sont en cours de maturation à la rédaction de ces diapositives : 

- `pivot_longer()` : pivoter des données d'un tableau large vers un tableau long,
- `pivot_wider()` : pivoter des données d'un tableau long vers un tableau en largeur.


Voici un tableau large :
```{r manip_operations_tibbles_pivot_large_donnees}
pop <-
  tibble(ville =c ("Paris", "Paris", "Lyon", "Lyon"),
         arrondissement = c(1, 2, 1, 2),
         pop_municipale =c (17443, 22927, 28932, 30575),
         pop_totale =c(17620, 23102, 29874, 31131))

pop
```

Comment faire pour obtenir un tableau dans lequel chaque ligne donne la population, pour une ville, un arrondissement et indique si la valeur de la population concerne la population municipale ou totale ?


Il suffit d'utiliser `pivot_longer()` en précisant : pour l'argument `cols`, les variables contenant les valeurs que l'on veut avoir dans la colonne unique. Eventuellement, il est possible de préciser le nom de la colonne qui indiquera le nom des colonnes d'où viennent initialement les données, en le passant à l'argument `names_to` (par defaut : `name`). Il est également possible de préciser le nom de la colonne dans lesquelles les valeurs se trouveront en le passant à l'argument `values_to` (par defaut : `value`)

```{r manip_operations_tibbles_pivot_longer}
pop_long <- pop %>% 
  pivot_longer(cols = c(pop_municipale, pop_totale),
               values_to = "population",
               names_to = "type_pop")
pop_long
```

La fonction `pivot_wider()` permet d'effectuer l'opération dans l'autre sens. Les arguments `names_from` et `values_from` permettent de désigner où sont les noms qui définiront les colonnes du tableau large et les valeurs associées, respectivement.

```{r manip_operations_tibbles_pivot_larger}
pop_long %>% 
  pivot_wider(names_from = type_pop, values_from = population)
```


#### Stacking et unstacking



Pour empiler (stack) les contenus des colonnes d'un tableau de données dans un seul vecteur, R propose la fonction `stack()`. Le tableau de données retourné est composé de deux colonnes, dont la première contient les valeurs et la seconde le nom de la colonne dans le tableau de données initial. Pour réaliser l'opération inverse, on peut utiliser la fonction `unstack()`.
```{r donnees_manip_df_stack}
patients <- 
  tibble(traitement_1 = c(4, 2, 7),
         traitement_2 = c(8, 5, 0),
         traitement_3 = c(0, 5, 6))
patients
stack(patients)
unstack(stack(patients))
```


Le _package_ `tidyr` propose des fonctions intéressantes pour convertir des tableaux en longueur en tableaux en hauteur, et `vice versa`.

### Data tables

Comme brièvement indiqué précédemment (à la Section\ \@ref(structures)), le _package_ {`data.table`} propose une autre structure de données, appelée _data.table_, qui se veut être une alternative aux objets _tibbles_ ou _data frames_. L'idée est de réduire la longueur du code, de proposer une syntatxe plus facile à écrire et lire, mais aussi (et surtout) de réduire les temps de calculs. La syntaxe se rapproche un peu du `SQL`, mais évite pas mal de lourdeurs de ce langage.

Il est plus pratique de charger le package_:

```{r}
library(data.table)
```
#### Création, conversion


La création d'un _data.table_ se fait de manière analogue à ce que l'on utilise pour un _tibble_, en faisant appel à la fonction `data.table()`.
```{r manip_datatable_creation}
chomage <- 
  data.table(region = rep(c(rep("Bretagne", 4), rep("Corse", 2)), 2),
             departement = rep(c("Cotes-d'Armor", "Finistere",
                                 "Ille-et-Vilaine", "Morbihan",
                                 "Corse-du-Sud", "Haute-Corse"), 2), 
             annee = rep(c(2011, 2010), each = 6),
             ouvriers = c(8738, 12701, 11390, 10228, 975, 1297,
                          8113, 12258, 10897, 9617, 936, 1220), 
             ingenieurs = c(1420, 2530, 3986, 2025, 259, 254,
                            1334, 2401, 3776, 1979, 253, 241))
chomage
```



Il est facile de convertir un _tibble_ en `data.table`, en faiant appel à la même fonction.

<!-- % pop <- data.frame(departement = rep(c("Cotes-d'Armor", "Finistere", -->
<!-- %                                       "Ille-et-Vilaine", "Morbihan", -->
<!-- %                                       "Corse-du-Sud", "Haute-Corse"), 2), -->
<!-- %                   annee = rep(c(2011, 2010), each = 6), -->
<!-- %                   population = c(594375, 899870, 996439, 727083, -->
<!-- %                                  145846, 168640, 591641, 897628,  -->
<!-- %                                  988140, 721657, 143600, 166093)) -->
```{r manip_datatable_conversion}
pop <- 
  tibble(region = rep(c("Bretagne", "Alsace"), each = 2),
             annee = rep(c(2010, 2011), 2),
             population = c(3199066, 3217767, 1845687, 1852325))

population <- data.table(pop)
population
```


La fonction `tables()` donne un aperçu des _data.tables_ en mémoire.
```{r}
tables()
```

La fonction `as_tibble()` convertit les _data.table_ en _tibble_, ce qui est essentiel, dans la mesure où certaines fonctions ne prennent en compte qu'un objet  _tibble_ ou _data.frame_ en argument, et excluent toute autre structure.


#### Sélection


Comme pour un _tibble_, on peut accéder aux éléments par leur numéro de ligne. En revanche, l'accès par le numéro de colonne ne fonctionne pas comme avec une matrice ou un _tibble_.
```{r manip_datatable_acces}
chomage[1,]
# Retourne un résultat pas forcément attendu
chomage[,1]
chomage[1,1]
```

Pour accéder aux valeurs dans les colonnes, il faut fournir le nom de la colonne, sans guillemets en second argument à la fonction `"[.data.table"()`. Pour choisir plusieurs colonnes, il faut placer le nom des variables, sans guillemets, dans une liste, et le fournir en second argument de la fonction `"[.data.table"()`.
```{r manip_datatable_acces_2}
chomage[1,ouvriers]
chomage[1, list(ouvriers, ingenieurs)]
```

#### Filtrage

On peut extraire des sous parties du _data.table_ à l'aide des opérateurs logiques qui scannent la totalité des données. Cependant, la Section\ \@ref(manip-datatable-cles) propose un moyen beaucoup plus rapide, surtout avec des gros volumes de données, pour effectuer des recherches dans un _data.table_.
```{r manip_datatable_acces_3}
chomage[annee == 2010 & departement %in% c("Finistere", "Morbihan"),
        list(departement, ouvriers, annee)]
```

#### Retirer les valeurs dupliquées



Il arrive parfois, après avoir effectué des opérations sur les tables, d'obtenir des duplications d'enregistrement. Comme pour les _data.frames_ ou les _tibbles_, il faut se servir de la fonction `unique()` pour retirer les doublons. Attention, si le _data.table_ possède une clé, il est nécessaire de la retirer avant d'appeler la fonction `unique()`.
```{r manip_datatable_dupli}
# Les observations 1 et 7, ainsi que 3 et 6 sont dupliquées
dt <- data.table(x = letters[c(1,2,3,1,4,3,1)],
                 y = letters[c(1,5,2,4,3,2,1)])

# setkey(dt, NULL)
unique(dt)
```


#### Clés {#manip-datatable-cles}


Dans les bases de données relationnelles, la présence d'une clé primaire permet d'identifier chaque observation de la base. Celle-ci peut être composée d'un seul ou de plusieurs champs. Ici, avec les _data.table_, il en est à peu près de même. Une clé (`key`) peut être composée d'une seule ou de plusieurs variables (colonnes) du _data.table_, qui peuvent être de mode `factor`, `numeric`, `integer`, `character`, etc. Les lignes sont ordonnées en fonction de la clé, ce qui implique l'impossibilité d'avoir plusieurs clés. Les clés dupliquées sont autorisées.

Pour définir une clé, on peut utiliser la fonction `setkey()`.
```{r manip_datatable_cles_setkey}
setkey(chomage, departement)
tables()
```


Comme précisé plus haut, on peut voir à présent que le _data.table_ a été ordonné en fonction de la clé.
```{r manip_datatable_cles_setkey_2}
chomage
```

On peut à présent faire référence à une valeur de la clé pour accéder à une information
```{r manip_datatable_cles_setkey_3}
chomage["Finistere",]

# On n'est pas obligé de mettre la virgule
chomage["Finistere"]
```


Comme on peut le voir, la clé `"departement"` est dupliqueée pour la valeur `"Finistere"`. De fait, deux observations sont retournées. Si on souhaite obtenir uniquement la première ou la dernière, on peut utiliser l'argument \texttt{mult}, en lui donnant respectivement la valeur `"first"` ou `"last"`.
```{r}
chomage["Finistere", mult = "first"]
chomage["Finistere", mult = "last"]
```


La clé peut être composée de plusieurs variables, il faut utiliser la fonction `J()`.
```{r}
setkey(chomage, region, departement)
tables()
chomage["Corse"]
chomage[J("Bretagne", "Finistere")]
```


À l'heure de la rédaction de la première version de ces notes, il n'existait pas encore de moyen de faire une recherche par clé secondaire (cela semble être à présent possible, comme le montre [cette vignette du _package_](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-secondary-indices-and-auto-indexing.html)). Il était cependant possible de contourner le problème en effectuant de nouveau l'opération de définition de clé.
```{r manip_datatable_cles_setkey_mult_secondaire}
# Pour rechercher les observations pour lesquelles le département
# est le Finistere, sans savoir que c'est en Bretagne

# Ne fonctionne pas
chomage["Finistere"]

setkey(chomage, departement)
chomage["Finistere"]

# Retour à la clé précédente
setkey(chomage, region, departement)
```

#### Modification des colonne


Dans l'application de la fonction `"[.data.table"()` à un _data.table_, le deuxième argument peut être une ou plusieurs expressions dont les arguments sont les noms des colonnes du _data.table_, sans les guillemets.

Si on souhaite ajouter une nouvelle variable dans le _data.table_, on peut le faire avec le symbole d'assignation, ou bien en utilisant le symbole `:=`.
```{r manip_datatable_regroupements_ajout_1}
chomage[, a := letters[1:12]]
# Equivalent de 
# chomage$temp <- letters[1:12]
```


L'ajout d'une nouvelle variable à partir des valeurs contenues dans le _data.table_ est un peu plus subtil. Il faut utiliser le symbole `:=` et il n'est plus possible d'utiliser la flèche `<-`.
```{r manip_datatable_regroupements_ajout_2}
chomage[, b := ouvriers + ingenieurs]
```


L'ajout de plusieurs variables possède un syntaxe un peu moins intuitive.
```{r manip_datatable_regroupements_ajout_3}
chomage[, ":=" (c = ouvriers/100, d = paste0(a,b))]
```


Une fonctionnalité pratique est qu'il est possible de définir une variable et de la réutiliser directement après sa définition.
```{r manip_datatable_regroupements_ajout_4}
chomage[, c("e", "f") := list(tmp <- ouvriers + ingenieurs,
                              round(sqrt(tmp)))]
```



La suppression se fait avec `NULL`, et il faut placer le nom des variables entouré de guillemets dans un vecteur.
```{r}
# Suppression de plusieurs colonnes
chomage[, c("a", "b", "c", "d", "e") := NULL]

# Suppression d'une seule colonne
chomage[, f := NULL]
```

#### Tri


Lorsqu'une clé est définie, les enregistrement du _data.table_ sont triés en fonction de cette clé. Si la clé contient plusieurs noms de colonnes, par exemple `var_1, var_2,` etc., le tri s'effectue d'abord par la première variable (`var_1`), puis la seconde (`var_2`), etc.


Il est possible de forcer le tri sur une autre variable, ou plusieurs autres.
```{r manip_datatable_tri}
head(chomage[order(annee)])
```

#### Copie de _data.tables_



Attention, pour copier un _data.table_, il faut utiliser la fonction `copy()` ! En effet, la flèche d'assignation ne réalise pas la création d'une nouvelle variable dont le contenu est désigné par le bout de la flèche, elle réalise une référence.
```{r manip_datatable_copie}
dt <- data.table(x = letters[1:3], y = 4:6)
dt

# Référence
dt_ref <- dt

# Copie
dt_copie <- copy(dt)

# Ajoutons une variable
dt[, a := rep(1,3)]
dt_ref[, z := paste0(x,y)]
dt_copie[, t := paste0(y,x)]

# Les variables "a" et "z" ont été ajoutées à dt et dt_ref
# sans impacter dt_copie
# La variable "t" n'a été ajoutée qu'à dt_copie
dt
dt_ref
dt_copie

# En revanche, la suppression de dt_ref ne supprime pas dt
rm(dt_ref)
dt
```

#### Jointures


Pour réaliser une jointure, on peut utiliser la fonction `merge()` (bien que non présentée dans ces notes, cette fonction s'applique aussi aux _tibbles_). Le _package_ {`data.table`} fournit d'autres méthodes, plus rapides, en passant, encore une fois, par la fonction `"[.data.frame"()`. La manière la plus simple, pour ne pas faire d'erreur lors de la jointure, est de définir en clé les variables communes aux deux tables.
```{r manip_datatable_jointure}
setkey(chomage, region, annee)
setkey(population, region, annee)
chomage[population]
```



On peut le voir, la jointure réalisée est de type _Right Join_, c'est à dire que tous les éléments de la seconde table sont présents, mais que seuls ceux de la première à l'intersection avec la seconde sont conservés (on note que les observations concernant la Corse ont disparues). Les diagrammes suivants donnent les autres fusions possibles. On peut remarquer que le _Full Outer Join_ n'est pas possible avec la fonction `"[.data.frame"()`.

```{r manip_datatable_jointure_graph_h, echo=FALSE}
circle_fun <- function(center=c(0,0), diameter=7, gpe, npoints=500, start=0, end=2){
  tt <- seq(start*pi, end*pi, length.out=npoints)
  res <-data.frame(
    x = center[1] + diameter / 2 * cos(tt),
    y = center[2] + diameter / 2 * sin(tt)
  )
  res$gpe <- gpe
  res
}

cercles_1 <- rbind(circle_fun(center = c(7.5, 5), gpe = 2),
                   circle_fun(center = c(2.5, 5), gpe = 1))

cercles_1$col <- c(rep(NA, 500), rep("yes", 500))

cercles_2 <- rbind(circle_fun(center = c(2.5, 20), gpe = 3),
                   circle_fun(center = c(7.5, 20), gpe = 4))
cercles_2$col <- rep(NA, 500)

tmp <- circle_fun(center = c(2.5, 20), gpe = 9)
tmp <- tmp[which(tmp[,"x"]>=5),]
tmp <- tmp[order(tmp$y),]
tmp_2 <- circle_fun(center = c(7.5, 20), gpe = 9)
tmp_2 <- tmp_2[which(tmp_2[,"x"]<=5),]
tmp_2 <- tmp_2[order(tmp_2$y, decreasing = TRUE),]

cercles_2_b <- rbind(tmp, tmp_2)
cercles_2_b$col <- rep("yes", nrow(cercles_2_b))

cercles_3 <- rbind(circle_fun(center = c(12.5+5, 5), gpe = 6),
                    circle_fun(center = c(17.5+5, 5), gpe = 5))
cercles_3$col <- c(rep(NA, 500), rep("yes", 500))

cercles_4 <- rbind(circle_fun(center = c(12.5+5, 20), gpe = 7),
                   circle_fun(center = c(17.5+5, 20), gpe = 8))
cercles_4$col <- c(rep("yes", 1000))


library(ggplot2)

cercles <- rbind(cercles_1, cercles_2, cercles_2_b, cercles_3, cercles_4)
p <- ggplot(data = cercles, aes(x = x, y = y, group = gpe, fill = col)) +
  geom_polygon(col = "black") +
  geom_polygon(data = cercles_4, aes(x = x, y = y, group = gpe), col = "black", fill = NA) +
  coord_equal() +
  scale_fill_manual(na.value = NA, guide = "none", values = c(yes = "dodger blue")) +
  annotate(geom = "text", x = c(5,5,20, 20), y = c(-1, 14, 14, -1),
           label = c("population[chomage]", "population[chomage, nonmatch = 0]",
                     "merge(chomage, population, all = TRUE)", "chomage[population]"),
           size = 3) +
  annotate(geom = "text", x = c(5,5,20, 20), y = c(-2, 13, 13, -2),
           label = c("Inner Join", "Full Outer Join",
                     "Left Outer Join", "Right Outer Join"),
           size = 4, fontface = "bold") +
  xlab("") + ylab("") +
  theme(axis.text.x = element_blank(),
        panel.grid.minor = element_line(colour = NA),
        panel.background = element_rect(fill = NA, colour = NA),
        axis.text.y = element_blank(), axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(), axis.title = element_blank(),
        rect = element_blank())
```

```{r, fig.width = 7, fig.height = 5, fig.align = "center"}
p
```



L'avantage, outre le temps gagné lorsqu'on a de gros volumes de données, d'utiliser `"[.data.frame"()` plutôt que `merge()`, est aussi qu'il est possible de faire une opération juste après la jointure. On gagne à la fois en temps d'exécution, et en lignes de codes, ainsi qu'en clarté de lecture.
```{r}
chomage[population][,round((ouvriers + ingenieurs)/population*100, 2)]

chomage[population,
        list(tmp = round((ouvriers + ingenieurs)/population*100, 2), departement)]
```


Il arrive d'avoir à joindre des _data.table_ en les empilant, par lignes. Une manière de faire passe par un simple appel à la fonction `do.call()`, avec en premier argument la fonction `rbind()`. Cela dit, cette méthode peut s'avérer prendre beaucoup de temps. La fonction `rbindlist()` propose de joindre par les lignes des tables de manière très rapide, à condition d'avoir les différentes parties à coller placées dans une liste.
```{r manip_datatable_jointure_3}
l <- lapply(1:3, function(x) data.table(valeur = x, lettre = LETTERS[x]))
res1 <- do.call("rbind", l)
res2 <- rbindlist(l)

res2
all.equal(res1, res2)
```

#### Agrégation


Pour obtenir le résultat d'une fonction appliquée à toute une colonne, il faut travailler avec le second argument de la fonction `"[.data.table"()`.
```{r manip_datatable_agregation}
chomage[, mean(ouvriers)]
```


Si on souhaite effectuer des regroupements, il faut rajouter l'argument `by` et lui atribuer le nom de la colonne (sans guillemets). Si le regroupement doit s'effectuer selon plusieurs colonnes, il faut alors envelopper les noms séparés par des virgules (mais sans espace) par des guillemets. On peut également fournir la liste des noms dans une liste, ce qui est un peu plus souple.
```{r manip_datatable_agregation_2}
chomage[, mean(ouvriers), by = region]
chomage[, mean(ouvriers), by = "region,departement"]
# Fournit le même résultat
# chomage[, mean(ouvriers), by = list(region, departement)]
```


Il est possible d'effectuer des calculs sur plusieurs des colonnes du _data.table_. Pour ce faire, il faut placer le second argument de la fonction `"[.data.table"()` dans une liste. Si on souhaite donner des noms aux variables issues du calcul, c'est possible. Attention, il faut bien être dans une liste pour attribuer le nom !
```{r manip_datatable_agregation_noms, error=TRUE}
chomage[, list(mean(ouvriers), sd(ouvriers)), by = region]

# Ne permet pas d'attribuer le nom "moyenne" au calcul
chomage[, moyenne = mean(ouvriers), by = region]
# Il faut être dans une liste
chomage[, list(moyenne = mean(ouvriers)), by = region]
```


Les opérations de regroupement sont beaucoup plus rapides qu'avec les _tibbles_ ou les  _data.frames_ (à condition d'avoir des volumes de données larges).

Par ailleurs, on peut effectuer plusieurs opérations d'un coup, qui dépendent des résultats précédents, en utilisant à nouveau la fonction `"[.data.table"()`.
```{r manip_datatable_acces_4}
# Créons un data.table immense (presque 7 millions d'obs.)
n <- 10000
dt <- data.table(x = rep(letters, each = 26*n),
                 y = rep(LETTERS, each = n),
                 z = runif(n*26^2))

nrow(dt)

# Après avoir calculé la moyenne de z pour chaque groupe
# défini par les valeurs de x et y,
# on ne conserve que les observations pour lesquelles la moyenne
# fraîchement créée est supérieure à 0.5
dt[, list(moy = mean(z)), by = "x,y"][moy > 0.5]
```


<!-- %' % . . . . . . . . . % -->
<!-- %' \subsubsection{Importation}\label{sec:manip_datatable_importation} -->
<!-- %' % . . . . . . . . . % -->
<!-- %'  -->
<!-- %' La fonction \afun{fread()} du _package_ \texttt{data.table} fonctionne de manière similaire à la fonction \afun{read.table()} du _package_ \texttt{base} (voir section~Ref{sec:donnees_import_export_crea_importation_read}), mais elle est beaucoup plus adaptée pour des volumes de données plus importants. Les séparateurs, les classes et le nombre de lignes sont automatiquement détectés. à l'heure de l'écriture du document, la fonction est encore en cours de développement.\\ -->
<!-- %'  -->
<!-- %' La plupart du temps, pour lire un fichier (admettions qu'il se nomme \texttt{"monfichier.csv"}), il suffit de donner ce nom à l'argument \texttt{input}. -->
<!-- %' <<manip_datatable_importation, eval = FALSE>>= -->
<!-- %' dt <- fread("monfichier.csv") -->
<!-- %' @ -->
<!-- %'  -->
<!-- %' Même s'il existe une reconnaissance automatique des séparateurs, des classes et du nombre de lignes, il est possible de forcer la valeur des arguments \texttt{sep}, \texttt{colClasses} et \texttt{nrows}. Le lecteur ou la lectrice est invité•e à consulter la page d'aide \texttt{?fread()} pour plus de détails. -->

### Quelques fonctions utiles

Le tableau ci-dessous répertorie quelques fonctions de base qu'il est bon de connaître pour manipuler les données dans R.

| Fonction | Description |
|----------|-------------|
| `x%%y` | Modulo |
| `x%/%y` | Division entière |
| `ceiling(x)` | Plus petits entier supérieur ou égal à `x` |
| `floor(x)` | Plus petits entier inférieur ou égal à `x` |
| `round(x, digits)` | Arrondi de `x` à digits décimales près |
| `signif(x, digits)` | Arrondi de `x` à digits chiffres significatifs |
| `trunc(x)` | Partie entière de `x` |
| `abs(x)` | Valeur absolue de `x` |
| `cor(x)` | Matrice de corrélations, si `x` est une matrice ou une data frame |
| `cor(x, y)` | Corrélation linéaire entre `x` et `y`, ou matrice de corrélations si `x` et `y` sont des matrices ou des data frames |
| `cummax(x)` | Vecteur dont le ie élément est le maximum des éléments de `x[1]` à `x[i]` |
| `cummin(x)` | Vecteur dont le ie élément est le minimum des éléments de `x[1]` à `x[i]` |
| `cumprod(x)` | Vecteur dont le ie élément est le produit des éléments `x[1]` à `x[i]` |
| `cumsum(x)` | Vecteur dont le ie élément est la somme des éléments de `x[1]` à `x[i]` |
| `exp(x)` | Exponentielle de `x` |
| `log(x, base)` | Logarithme de `x`, avec `base=10` par défaut |
| `max(..., na.rm)` | Maximum du premier argument (peut être de type `numeric`, `logical` ou `character`. Si `na.rm = TRUE`, omet les valeurs non disponibles |
| `mean(x, na.rm, trim)` | Moyenne de `x`. Si `na.rm = TRUE`, omet les valeurs non disponibles. L'argument `trim`, compris entre 0 (par défaut) et 0.5 indique la fraction d'observations à retirer de chaque côté de `x` avant de calculer la moyenne des observations restantes |
| `median(x, na.rm)` | Médiane de `x`. Si `na.rm = TRUE`, omet les valeurs non disponibles |
| `min(..., na.rm)` | Minimum du premier argument (peut être de type `numeric`, `logical` ou `character`. Si `na.rm = TRUE`, omet les valeurs non disponibles |
| `prod(..., na.rm)` | Produit des éléments du premier argument (peut être de type `numeric`, `logical` ou `complex`. Si `na.rm = TRUE`, omet les valeurs non disponibles |
| `quantile(x, probs, na.rm)` | Fractiles empiriques de `x` d'ordre `probs`. Si `na.rm = TRUE`, omet les valeurs non disponibles. |
| `range(..., na.rm, finite)` | Étendue du premier argument (peut être de type `numeric`, `logical` ou `character`. Si `na.rm = TRUE`, omet les valeurs non disponibles. Si `finite = TRUE`, les éléments non-finis sont omis. |
| `sd(x, na.rm)` | Écart-type de `x`. Si `na.rm = TRUE`, omet les valeurs non disponibles |
| `sign(x)` | Signe de `x` |
| `sqrt(x)` | Racine carrée de `x` |
| `sum(..., na.rm)` | Somme du premier argument (peut être de type `numeric`, `logical` ou `complex`. Si `na.rm = TRUE`, omet les valeurs non disponibles. |
`var(x, na.rm)` ou `cov(x)` | Variance corrigée de `x` (division par `n - 1` et non `n`). Si `na.rm = TRUE`, omet les valeurs non disponibles. Si `x` est une matrice ou un data frame, le résultat est la matrice de variance-covariance |
| `var(x, y, na.rm)` ou `cov(x, y)` | Covariance entre `x` et `y`, ou, dans le cas où `x` et `y` sont des matrices ou des data frames, entre les colonnes de `x` et `y`. Si `na.rm = TRUE`, omet les valeurs non disponibles |
| `sin(x)` | Sinus de `x` |
| `cos(x)` | Cosinus de `x` |
| `tan(x)` | Tangente de `x` |
| `asin(x)` | Arc-sinus de `x` |
| `acos(x)` | Arc-cosinus de `x` |
| `atan(x)` | Arc-tangente de `x` |
| `sinh(x)` | Sinus hyperbolique de `x` |
| `cosh(x)` | Cosinus hyperbolique de `x` |
| `tanh(x)` | Tangente hyperbolique de `x` |
| `asinh(x)` | Arc-sinus hyperbolique de `x` |
| `acosh(x)` | Arc-cosinus hyperbolique de `x` |
| `atanh(x)` | Arc-tangente hyperbolique de `x` |
| `factorial(x)` | Factorielle de `x` |
| `choose(n, k)` | Coeffcient binomial $C_n^k$ |
| `any(x, na.rm)` | Indique si au moins un élément de `x` vaut `TRUE`. Si `na.rm = TRUE`, omet les valeurs non disponibles |
| `duplicated(x, fromLast)` | Indique les éléments de `x` qui commencent à être dupliqués. Si `fromLast = TRUE`, le calcul est effectué de droite à gauche |
| `head(x, n)` | Vecteur des `n` premières valeurs de `x` |
| `order(x, decreasing)` | Vecteur des rangs de classement des éléments de `x`. Si ex &aelig;quo, les rangs sont classés par ordre croissant |
| `rev(x)` | Retourne `x` avec ses éléments dans l'ordre inversé |
| `table(...)` | Tableau de contingence |
| `sample(x, size, replace, prob)` | Ré-échantillonnage pseudo-aléatoire (avec remise si `replace = TRUE`) de `x` de taille `size`. L'argument optionnel `prob` permet d'attribuer des poids aux éléments |
| `summary(object)` | Retourne une table indiquant pour object : le minimum, le premier quartile, la médiane, la moyenne, le troisième quartile, le maximum et, s'il y en a, le nombre de valeurs manquantes. Les calculs sont effectués en omettant les valeurs manquantes. |
| `sort(x, decreasing)` | `x` trié par ordre de valeurs croissantes (décroissantes si `decreasing = TRUE)` |
| `tail(x, n)` | Vecteur des `n` dernières valeurs de `x` |
| `unique(x, fromLast)` | Conserve uniquement les valeurs uniques de `x`, en retirant les doublons. Si `fromLast = TRUE`, le calcul indiquant si l'élément est dupliqué est effectué de droite vers la gauche |
| `which.min(x)` | Position du (premier) minimum de `x` |
| `which.max(x)` | Position du (premier) maximum de `x` |
| `"["()` | Fonction d'extraction ou de remplacement de parties d'un objet |
| `"[["()` | Fonction d'extraction ou de remplacement de parties d'un objet. Les noms sont perdus. |
| `dim(x)` | Liste des tailles de la matrice ou data frame `x` |
| `nrow(x)` | Nombre de lignes de `x` |
| `ncol(x)` | Nombre de colonnes de `x` |
| `dimnames(x)` | Liste des noms des lignes et des colonnes de `x` |
| `names(x)` | Vecteur du (des) nom(s) de `x` |
| `colnames(x)` | Nom des colonnes de `x` |
| `rownames(x)` | Nom des lignes de `x` |
| `c()` | Concaténation |
| `cbind(x, y, ...)` | Fusion des matrices ou data frames `x` et `y` par colonnes |
| `merge(x, y)` | Fusion de deux data frames par noms de colonnes communs |
| `rbind()` | Fusion des matrices ou data frames `x` et `y` par lignes |

## Exercices

<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 1. Manipulation de vecteurs**

Considérons le vecteur suivant : $x = \begin{bmatrix}1 & 2 & 3 & 4 & 5\end{bmatrix}$.

1. Créer ce vecteur dans R et le stocker dans un objet que l'on appellera `x`x
2. Afficher le mode de `x`, puis sa longueur ;
3. Extraire le premier élément, puis le dernier ;
4. Extraire les trois premier éléments et les stocker dans un vecteur que l'on nommera `a` ;
5. Extraire les éléments en position 1, 3, 5 ; les stocker dans un vecteur que l'on nommera `b` ;
6. Additionner le nombre `10` au vecteur `x`, puis multipliser le résultat par `2` ;
7. Effectuer l'addition de `a` et `b`, commenter le résultat ;
8. Effectuer l'addition suivante : `x+a`, commenter le résultat, puis regarder le résultat de `a+x` ;
9. Multiplier le vecteur par le scalaire `c` que l'on fixera à 2 ;
10. Effectuer la multiplication de `a` et `b`, commenter le résultat ;
11. Effectuer la multiplication suivante : `x*a`, commenter le résultat ;
12. Récupérer les positions des multiples de 2 et les stocker dans un vecteur que l'on nommera `ind`, puis conserver uniquement les multiples de 2 de `x` dans un vecteur que l'on nommera `mult_2` ;
13. Afficher les éléments de `x` qui sont multiples de 3 *et* multiples de 2 ;
14. Afficher les éléments de `x` qui sont multiples de 3 *ou* multiples de 2 ;
15. Calculer la somme des éléments de `x` ;
16. Remplacer le premier élément de `x` par un `4` ;
17. Remplacer le premier élément de `x` par la valeur `NA`, puis calculer la somme des éléments de `x` ;
18. Lister les objets en mémoire dans la session R ;
19. Supprimer le vecteur ;
20. Supprimer la totalité des objets de la session.

```

<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 2. Manipulation de listes**

1. évaluer le code suivant : `TRUE+FALSE+TRUE*4` et le commenter ;
2. évaluer les expressions suivantes : `c(1, 4, TRUE)`, et `c(1, 4, TRUE, "bonjour")`, commenter ;
3. Créer une liste que l'on appellera `l` et qui contient les éléments `1`, `4` et `TRUE` en première, deuxième et troisième positions, respectivement ;
4. Extraire le premier élément de la liste `l`, et afficher son mode. En faire de même avec le troisième élément, et commenter ;
5. Ajouter un quatrième élément à la liste `l` : `"bonjour"`, puis afficher la structure de `l` ;
6. Retirer le troisième élément de la liste `l` ;
7. Créer une liste de trois éléments : votre nom, votre prénom, et votre année de naissance. Ces trois éléments de la liste devront être nommés respectivement `"nom"`, `"prenom"` et `"année de naissance"`. Stocker la liste ainsi créée dans un objet nommé `moi` ;
8. Extraire le prénom de la liste `moi` de deux manières : en utilisant l'indice, et en utilisant le nommage ;
9. Créer une liste avec la même structure que celle de `moi`, en la remplissant avec les informations d'une autre personne et la nommer `toi`. Puis, créer la liste `personnes`, qui contiendra les listes `toi` et `moi` ;
10 Extraire la liste `toi` de `personnes` (en première position) ;
11 Extraire directement depuis `personne` le prénom de l'élément en première position.

```


<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 3. Manipulation de matrices**

1. Créer la matrice suivante : $A = \begin{bmatrix} -3 & 5 & 6 \\ -1 & 2 & 2 \\ 1 & -1 & -1 \end{bmatrix}$ ;
2. Afficher la dimension de `A`, son nombre de colonnes, son nombre de lignes et sa longueur ;
3. Extraire la seconde colonne de `A`, puis la première ligne ;
4. Extraire l'élément en troisième position à la première ligne ;
5. Extraire la sous-matrice de dimension $2\times 2$ du coin inférieur de `A`, c'est-à-dire $\begin{bmatrix} 2 & 2 \\ -1 & -1 \end{bmatrix}$ ;
6. Calculer la somme des colonnes puis des lignes de `A` ;
7. Afficher la diagonale de `A` ;
8. Rajouter le vecteur $\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top$ à droite de la matrice `A` et stocker le résultat dans un objet appelé `B` ;
9. Retirer le quatrième vecteur de `B` ;
10. Retirer la première et la troisième ligne de `B` ;
11. Ajouter le scalaire `10` à `A` ;
12. Ajouter le vecteur $\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top$ à A ;
13. Ajouter la matrice identité $I_3$ à `A` ;
14. Diviser tous les éléments de la matrice `A` par 2 ;
15. Multiplier la matrice `A` par le vecteur $\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top$ ;
16. Afficher la transposée de `A` ;
17. Effectuer le produit avec transposition $A^\top A$.

```


    

<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 4. Manipulation de matrices**

1. Télécharger le fichier `csv` à l'adresse suivante : [http://egallic.fr/Enseignement/R/Exercices/donnees/notes.csv](http://egallic.fr/Enseignement/R/Exercices/donnees/notes.csv) et le placer dans le répertoire courant du projet. Importer son contenu dans R ;
2. Importer à nouveau les données dans R, mais en utilisant fournissant cette fois le l'url directement à la fonction d'importation ;
3. À présent, importer le contenu du fichier disponible à l'adresse http://egallic.fr/Enseignement/R/Exercices/donnees/notes_decim.csv. Le séparateur de champs est un point virgule et le séparateur décimal est une virgule ;
4. Importer le contenu du fichier http://egallic.fr/Enseignement/R/Exercices/donnees/notes_h.csv. Le nom des colonnes n'est pas présent ;
5. Importer le contenu du fichier http://egallic.fr/Enseignement/R/Exercices/donnees/notes_h_s.csv. La première ligne n'est pas à importer ;
6. Importer le contenu de la première feuille du fichier Excel http://egallic.fr/Enseignement/R/Exercices/donnees/notes.xlsx ;
7. Importer le contenu de la seconde feuille (`notes_h_s) du fichier Excel http://egallic.fr/Enseignement/R/Exercices/donnees/notes.xlsx. La première ligne est un commentaire à ne pas considérer durant l'importaiton ;
8. Importer le fichier http://egallic.fr/Enseignement/R/Exercices/donnees/notes.rda dans R ;
9. Exporter le contenu de l'objet `notes` de la question précédente au format `csv` (virgule en séparateur de champs, point en séparateur décimal, ne pas conserver le numéro des lignes).
10. Importer le contenu du fichier `notes_2012.csv` contenu dans l'archive disponible à l'adresse suivante : http://egallic.fr/Enseignement/R/Exercices/donnees/notes.zip

```



    
<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 5. Manipulation de tableaux de données**

1. À l'aide de la fonction `read_excel()` du _package_ `readr`, importer le contenu de la feuille intitulée `notes_2012` du fichier Excel disponible à l'adresse suivante : http://egallic.fr/Enseignement/R/Exercices/donnees/notes_etudiants.xlsx et le stocker dans une variable que l'on nommera `notes_2012` ;
2. Afficher les 6 premières lignes du jeu de données, puis les dimensions du tableau ;
3. Conserver uniquement la colonne `note_stat` du tableau de données `notes_2012` dans un objet que l'on appellera tmp ;
4. Conserver uniquement les colonnes `num_etudiant`, `note_stat` et `note_macro` dans l'objet `tmp`;
5. Remplacer le contenu de `tmp` par les observations de `notes_2012` pour lesquelles l'individu a obtenu une note de stat supérieure (strictement) à 10 ;
6. Remplacer le contenu de `tmp` par les observations de `notes_2012` pour lesquelles l'individu a obtenu une note comprise dans l'intervalle $(10,15)$;
7. Regarder s'il y a des doublons dans le tableau de données `notees_2012` ; le cas échéant, les retirer du tableau ;
8. Afficher le type des données de la colonne `num_etudiant`, puis afficher le type de toutes les colonnes de `notes_2012` ;
9. Ajouter au tableau `notes_2012` les colonnes suivantes :

  - `note_stat_maj` : la note de stat (`note_stat`) majorée d'un point,
  - `note_macro_maj` : la note de macro (`note_macro`) majorée de trois points (le faire en deux étapes : d'abord deux points en plus, puis un point) ;

10. Renommer la colonne `year` en `annee` ;
11. Depuis le fichier `notes_etudiants.xlsx}` (c.f. question 1), importer le contenu des feuilles `notes_2013`, `notes_2014` et `prenoms` et le stocker dans les objets `notes_2013`, `notes_2014` et `prenoms` respectivement ;
12. Empiler le contenu des tableaux de données `notes_2012`, `notes_2013` et `notes_2014` dans un objet que l'on nommera `notes` ;
13. Fusionner les tableaux `notes` et `prenoms` à l'aide d'une jointure gauche, de manière à rajouter les informations contenues dans le tableau `prenoms` aux observations de `notes`. La jointure doit se faire par le numéro détudiant et l'année, l'objet final viendra remplacer le contenu de `notes` ;
13. Trier le tableau `notes` par années croissantes et notes de macro décroissantes ;
14. Changer le type des colonnes `annee` et `sexe` en facteur ;
15. Créer une colonne `apres_2012` qui prend la valeur `TRUE` si l'observation concerne une note attribuée après 2012;
16. à l'aide de la fonction `summarize()` du _package_ {`dplyr`}, calculer :

  - la moyenne et l'écart-type annuels des notes pour chacune des deux matières,
  - la moyenne et l'écart-type annuels et par sexe des notes pour chacune des deux matières ;

17. En utilisant la fonction `pivot_longer()` du _package_ {`tidyr`}, créer un tableau dans lequel chaque ligne renseigne le numéro d'étudiant, l'année, le prénom, le sexe, l'enseignement (macro ou stat) et la note ;
18. En repartant de l'objet obtenu à la question précédente, utiliser la fonction `pivot_wider()` du _package_ {`tidyr`} pour retomber sur le même tableau que `notes`.

```





<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 6. Manipulation de tableaux de chaînes de caractères**

1. Créer les objets `a` et `b` afin qu'il contiennent respectivement les chaînes de caractères suivantes : `23 à 0` et `C'est la piquette, Jack !` ;
2. Créer le vecteur `phrases` de longueur 2, dont les deux éléments sont `a` et `b` ;
3. À l'aide de la fonction appropriée dans le _package_ {`stringr`}, afficher le nombre de caractètres de `a`, de `b`, puis appliquer la même fonction à l'objet `phrases` ;
4. En utilisant la fonction `str_c()`, concaténer `a` et `b` dans une seule chaîne de caractères, en choisissant la virgule comme caractère de séparation ;
5. Concaténer les deux éléments du vecteur `phrases` en une seule chaîne de caractères, en les séparant par le caractère de retour à la ligne, puis utiliser la fonction `cat()` pour afficher le résultat dans la console ;
6. Appliquer la même fonction que dans la question précédente à l'objet suivant : `c(NA, phrases)` et commenter ;
7. Mettre en majuscules, puis en minuscules les chaînes du vecteur `phrases` (afficher le résultat, ne pas modifier `phrases`);
8. À l'aide de la fonction `word()` du _package_ {`stringr`}, extraire le mot `la`, puis `Jack` de la chaîne `b` ;
10. Même question que la précédente, en utilisant la fonction `str_sub()` ;
11. À l'aide de la fonction `str_detect()`, rechercher si le motif `piqu` puis `mauvais` sont présents dans `b` ;
12.  À l'aide de la fonction `str_detect()`, rechercher si le motif `piqu` est présent dans les éléments du vecteur `phrases` ;
13. À l'aide de la fonction `str_detect()`, rechercher si le motif `piqu` ou le motif `à` sont présents dans les éléments du vecteur `phrases` ;
14. En utilisant la fonction `str_locate()`, retourner les positions de la première occurence du caractère `a` dans la chaîne `b`, puis essayer avec le caractère `w` pour observer le résultat retourné ;
15. Retourner toutes les positions du motif `a` dans la chaîne `b` ;
16. En utilisant la fonction `str_replace()`, remplacer la première occurence du motif `a`, par le motif `Z` (afficher le résultat, ne pas modifier `phrases`);
17. Remplacer toutes les occurences de `a` par `Z` dans la chaîne `b` (afficher le résultat, ne pas modifier `phrases`) ;
18. Utiliser la fonction `str_split()` pour séparer la chaîne `b` en utilisant la virgule comme séparateur de sous-chaînes ;
19. Retirer tous les caractères de ponctuation de la chaîne `b`, puis utiliser la fonction `str_trim()` sur le résultat pour retirer les caractères blancs du début et de la fin de la chaîne.

```





<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 7. Manipulation de tableaux de de dates**

1. En utilisant la fonction `as.Date()`, stocker la date du 29 aoùt 2015 dans un objet que l'on appellera `d` puis afficher la classe de l'objet ;
2. À l'aide de la fonction appropriée, afficher la date du jour ;
3. À l'aide de la fonction `as.Date()`, stocker sous forme de date la chaîne de caractères suivante : `29-08-2015` ;
4. Utiliser les fonctions `as.POSIXct()` et `as.POSIXlt` pour stocker la chaîne de caractères `2015-08-29 20:30:56` sous forme de dates dans des objets nommés `d_ct` et `d_lt` respectivement ; utiliser ensuite la fonction `unclass()` sur les deux objets pour comparer la façon dont R a stocké l'information : 
5. Utiliser la fonction appropriée du _package_ {`lubridate`} pour stocker la chaîne de caractères `2015-08-29` sous forme de date ;
6. Même question avec la chaîne `2015-08-29 20:30:56` ;
7. Utiliser la fonction `ymd_hms()` pour stocker la date et l'heure actuelle, en précisant le fuseau horaire, puis afficher la date et l'heure correspondantes à New York City ;
8. Considérons le vecteur `x` :

    `x <- c(ymd_hms("2015-08-29 20:30:56", tz = "Europe/Paris"),
                 ymd_hms("2015-09-15 08:10:33", tz = "Europe/Paris"))`
  
    Extraire l'année, le mois, le jour, les heures, les minutes et les secondes du premier élément de `x` à l'aide des fonctions appropriées du _package_ {`lubridate`} ;
    
9. Appliquer les mêmes fonctions au vecteur `x` ;
10. Au premier élément de `x`, ajouter :

  - une seconde,
  - un jour,
  - un mois
  - deux années ;
  
11. Tester si la date du premier élément de `x` vient avant celle du second élément ;
12. En utilisant la fonction `interval()` du _package_ {`lubridate`}, créer un intervalle de dates entre les deux éléments de `x`, puis afficher le nombre de jours, puis le nombre d'heures, puis le nombre d'années séparant les deux dates ;
13. En utilisant la fonction `seq()`, créer une séquence de dates avec un intervalle de 5 jours entre chaque date, commençant à la date du premier élément de `x` et se terminant à la date du second élément de `x` (la séquence sera tronquée avant) ;
14. Convertir en date les deux chaînes de caracères suivantes : `Sam 29 Aoùt 2015` et `Sat 29 Aug 2015`.

```


# Fonction

Jusqu'ici, nous avons utilisé des fonctions incluses dans les _packages_, rédigées par d'autres personnes. Dans ce chapitre, nous allons voir comment créer ses propres fonctions.

## Définition


La définition  d'une nouvelle fonction suit la syntaxe suivante :
```{r fonctions_definition_def, eval=FALSE}
name <- function(arguments) expression
```

avec `name` le nom que l'on décide de donner à la fonction, qui doit respecter les règles de nommage abordés en Section\ \@ref(introduction-espace-nommage), `arguments` les arguments de la fonction, et `expression` le corps de la fonction. Comme on peut le remarquer, on utilise le symbole d'assignation : les fonctions sont des objets. L'appel de la fonction aura la syntaxe suivante :
```{r fonctions_definition_appel, eval=FALSE}
name()
```

Il suffit donc de rajouter des parenthèses au nom de la fonction pour l'appeler. En effet, `name` désigne l'objet `R`~qui contient la fonction qui est appelée à l'aide de l'expression `name()`.

Par exemple, si on souhaite définir la fonction qui calcule le carré d'un nombre, voici ce que l'on peut écrire :
```{r fonctions_definition_exemple_carre}
carre <- function(x) x^2
# Le carré de 2
carre(2)

# Le carré de -3
carre(-3)
```

## La structure d'une fonction {#fonctions_structure}



Les fonctions en `R`, excepté les fonctions primitives du _package_ {`base`}, sont composées de trois parties :

- une liste d'arguments ;
- un corps, contenant du code exécuté lors de l'appel à la fonction ;
- un environnement, qui définit l'endroit où sont stockées les variables.


On peut accéder à ces trois parties (et les modifier) avec les fonctions `formals()` pour les arguments, `body()` pour le corps et `environment()` pour l'environnement.

### Le corps d'une fonction {#fonctions_structure_corps}


Dans le cas le plus simple, le corps d'une fonction est constitué d'une seule instruction. Si on désire en écrire plusieurs, il est nécessaire de les entourner par des accolades, pour réaliser un regroupement. Le résultat est la valeur de la dernière commande contenue dans le corps de la fonction.
```{r fonctions_structure_corps_regroupement}
f <- function(x) {
  x^2
  y <- x
  y
}
f(2)
```


Si on souhaite retourner une valeur autre part qu'à la dernière ligne, il faut utiliser la fonction `return()` (utile lorsque l'on emploie des conditions, comme nous le verrons par la suite, ou pour prévenir d'une erreur).
```{r fonctions_structure_corps_return}
f <- function(x) {
  return(x^2)
  # Un commentaire de dernière ligne
}
f(2)
```

```{block2, type='remarque', echo=TRUE}
Certains conseillent de ne pas utiliser la fonction `return()` en dernière ligne, dans la mesure où cela est d'une part inutile, et perturbe la lecture du code d'autre part.
```

Il est possible de retourner une liste, pouvant contenir autant d'objet que l'on souhaite.
```{r fonctions_return_list}
# Calculer la moyenne et l'écart-type pour un vecteur
stat_des <- function(x) {
  list(moyenne = mean(x), ecart_type = sd(x))
}
x <- runif(10)
stat_des(x)
```


Il est également possible de ne pas afficher dans la console le résultat de l'appel à une fonction à l'aide de la fonction `invisible()`.
```{r fonctions_return_invisible}
stat_des_2 <- function(x) {
  invisible(list(moyenne = mean(x), ecart_type = sd(x)))
}
x <- runif(10)
stat_des_2(x)
str(stat_des_2(x))
stat_des_2(x)$moyenne
```



On peut afficher malgré tout le résultat d'une fonction retournant un résultat invisible en ayant recours aux parenthèses.
```{r fonctions_return_invisible_2}
(stat_des_2(x))
```



Lorsque la dernière instruction est une assignation, nous sommes dans le cas d'un résultat invisible.
```{r fonctions_return_invisible_3}
f <- function(x){
  res <- x^2
}
f(2)
(f(2))
x <- f(2)
x
```

### Les arguments d'une fonction {#fonctions_structure_parametres}



Dans l'exemple de la fonction `carre()` que nous avons crée, nous avons renseigné un seul argument, appelé `x`. Si la fonction que l'on souhaite créer nécessite plusieurs arguments, il faut les séparer par une virgule.

Considérons par exemple le problème suivant. Nous disposons d'une fonction de production $Y(L,K, M)$, qui dépend du nombre de travailleurs $L$ et de la quantité de capital $K$, et du matériel $M$, telle que $Y(L,K, M) = L^{0.3}K^{0.5}M^{2}$. Cette fonction pourra s'écrire, en `R` de la manière suivante :
```{r fonctions_structure_parametres}
production <- function(l, k, m) l^(0.3) * k^(0.5) * m^(0.2)
```


#### Appel sans noms {#fonctions_structure_parametres_appel_noms}


En reprenant l'exemple précédent, si on nous donne $L = 60$ et $K = 42$ et $M = 40$, on peut en déduire la production :
```{r fonctions_structure_parametres_2}
production(60, 42, 40)
```



On peut noter que le nom des arguments n'a pas été mentionné ici. Lors de l'appel de la fonction, `R` cherche d'abord s'il y a des arguments nommés afin de leur associer des valeurs. S'il n'y a pas de nom, il se basera sur la position donnée aux arguments.
```{r fonctions_structure_parametres_3}
production(k = 42, m = 40, l = 60)
production(k = 42, 60, 40)
```

#### Arguments effectifs {#fonctions_structure_parametres_defaut}



On peut, lors de la définition de la fonction, choisir de donner une valeur par défaut aux arguments. On parle d'argument `formel` pour désigner les arguments de la fonction (les variables utilisées dans le corps de la fonction) et d'argument `effectif` pour désigner la valeur que l'on souhaite donner à l'argument formel. Pour définir la valeur à donner à un argument formel, on utilise le symbol d'égalité. Lors de l'appel de la fonction, si l'utilisateur•rice ne définit pas explicitement une valeur, celle par défaut sera affectée.
```{r fonctions_structure_parametres_4}
# On propose de définir la valeur du capital à 42 par défaut
production_2 <- function(l, m, k = 42) l^(0.3) * k^(0.5) * m^(0.2)
production_2(l = 42, m = 40)
production_2(l = 42, m = 40, k = 2)
```


Dans l'exemple précédent, l'argument auquel nous avons donné une valeur est placé en dernier. Ce n'est pas obligatoire, mais plus pratique, si le but recherché est de ne pas avoir à saisir l'argument effectif lors de l'appel de la fonction. De plus, si l'utiliateur ne nomme pas les arguments lors de l'appel, des problèmes liés à l'ordre peuvent apparaître...
```{r fonctions_structure_parametres_5, error=TRUE}
production_3 <- function(l, k = 42, m) l^(0.3) * k^(0.5) * m^(0.2)
production_3(l = 42, m = 40)
production_3(42, 40)
```

#### Appel avec des noms partiels {#fonctions_structure_parametres_appel_noms_partiels}


Par ailleurs, il est possible de ne pas saisir le nom complet des arguments lors de l'appel d'une fonction. En effet, on peut utiliser une abréviation du nom de l'argument. S'il existe une ambiguïté, `R` retourne un message d'erreur.
```{r fonctions_structure_parametres_abr, error=TRUE}
f <- function(premier, second, troisieme) premier + second + troisieme
f(p = 1, s = 2, t = 3)

# Problème d'ambiguïté
f <- function(texte, nombre, nom) print(nom)
f("hello", 2, no = 3)
```


```{block2, type='remarque', echo=TRUE}
Si parmi les arguments de la fonction, figure l'argument `...` (plus de détails sont donnés dans la Section\ \@ref(fonctions_structure_parametres_special), il n'est pas possible d'utiliser les abréviations.
```

#### Fonctions sans arguments {#fonctions_structure_parametres_sans}


On est parfois amené à créer des fonctions qui ne prennent pas d'argument. Il suffit alors de laisser la liste d'arguments formels vide.
```{r fonctions_structure_parametres_aucun}
f <- function() sample(letters, size = 10, replace = TRUE)
f()
```


#### L'argument spécial `...` {#fonctions_structure_parametres_special}



l'argument `...` que l'on peut voir dans certaines fonctions (essayez d'évaluer `sum` par exemple) sert à indiquer que la fonction peut admettre d'autres arguments que ceux qui ont été définis. Cela sert à, dans la plupart des cas, à passer un argument à une autre fonction contenue dans le corps de la fonction que l'on appelle.
```{r}
f <- function(...) names(list(...))
f(premier = 1, second = 2)
```


Attention toutefois, l'utilisation de `...` peut induire des soucis. En effet, un argument mal écrit sera passé à `...` et il n'y aura pas d'erreur de retournée. Par ailleurs, tous les arguments placés après `...` doivent être complètement nommés, pas abrégés.
```{r fonctions_structure_parametres_special_abr}
sum(3, NA, 4, na.rm = TRUE)
sum(3, NA, 4, an.rm = TRUE) # Mauvaise écriture
sum(3, NA, 4, na = TRUE)  # Abréviation
```


### Portée des fonctions {#fonctions_structure_environnement}



Lorsque une fonction est appelée, le corps de cette fonction est interprété. Les variables ayant été définies dans le corps de la fonction ne vivent qu'à l'intérieur de celle-ci à moins d'avoir spécifié le contraire. On parle alors de `portée` des variables. Ainsi, une variable ayant une portée locale --- c'est-à-dire vivant uniquement à l'intérieur du corps de la fonction --- peut avoir le même nom qu'une variable globale --- c'est à dire définie dans l'espace de travail de la session ---, sans pour autant désigner le même objet, ou écraser cet objet.
```{r fonctions_structure_environnement, error=TRUE}
# Définition d'une variable globale
valeur <- 1

# Définition d'une variable locale à la fonction f
f <- function(x){
  valeur <- 2
  nouvelle_valeur <- 3
  print(paste0("valeur vaut : ",valeur))
  print(paste0("nouvelle_valeur vaut : ",valeur))
  x + valeur
}

f(3)
# valeur n'a pas été modifiée
valeur
# nouvelle_valeur n'existe pas en dehors de f()
nouvelle_valeur
```



Sans trop rentrer trop dans les détails, il semble important de connaître quelques principes à propos de la portée des variables. Les variables sont définies dans des environnements, qui sont embriqués les uns dans les autres. Si une variable n'est pas définie dans le corps d'une fonction, `R` ira chercher dans un environnement parent.
```{r fonctions_structure_environnement_parent}
valeur <- 1
f <- function(x){
  x + valeur
}
f(2)
```


Si on définit une fonction à l'intérieur d'une autre fonction, et qu'on appelle une variable non définie dans le corps de cette fonction, `R` ira chercher dans l'environnement directement supérieur. S'il ne trouve pas, il ira chercher dans l'environnement encore supérieur, et ainsi de suite.
```{r fonctions_structure_environnement_parent_2}
# La variable valeur n'est pas définie dans g(). R va alors chercher dans f().
valeur <- 1
f <- function(){
  valeur <- 2
  g <- function(x){
    x + valeur
  }
  g(2)
}
f()

# La variable valeur n'est définie ni dans g() ni dans f()
# mais dans l'environnement supérieur (global, ici)
valeur <- 1
f <- function(){
  g <- function(x){
    x + valeur
  }
  g(2)
}
f()
```


Si on définit une variable dans le corps d'une fonction et que l'on souhaite qu'elle soit accessible dans l'environnement global, on peut utiliser le symbole `<<-`, ou bien la fonction `assign` (pratique peu recommandable).
```{r fonctions_structure_environnement_parent_assign}
rm(x)
f <- function(x){
  x <<- x + 1
}
f(1)
x

# En utilisant assign
rm(x)
f <- function(x){
  # envir = .GlobalEnv signifique que l'on veut définir dans l'environnement global
  assign(x = "x", value = x + 1, envir = .GlobalEnv)
}
f(4)
x
```


## Documentation

Lorsque l'on créé une fonction, il est important de bien la documenter afin de rendre son utilisation facilitée (par les autres mais également par soi-même).

Il existe un _package_ ({`roxygen2`}) qui permet de réaliser des fichiers de documentation des fonctions que l'on souhaite exporter au sein d'un _package_. Ces notes de cours ne visent pas à expliquer comment créer un _package_. Toutefois, il n'est pas inutile d'emprunter une technique utilisée par de nombreuses personnes qui créent des _packages_ pour améliorer la documentation de nos fonctions dans nos codes.

L'idée est d'ajouter un commentaire `roxygen` en préfixe de la définition de la fonction. Ce commentaire s'écrit à l'aide d'un croisillon suivi d'un guillemet simple : `#'`. Reprenons la fonction de production, et ajoutons un commentaire `roxygen` précisant :

- ce que fait la fonction
- quels sont ses arguments (`@param`)
- ce qu'elle retourne (`@return`)
- deux exemples d'utilisation

```{r documentation_fonction}
#' Calcul le niveau de production
#' 
#' @param l montant de force de travail
#' @param k montant de capital
#' @param m montant de matériel
#' @return Le niveau de production d'une Cobb-Doublas, fonction de \code{l}, \code{k} et \code{m}
#' @examples
#' production(k = 42, l = 60, m = 40)
#' production(40, 20, 60)
production <- function(l, k, m) {
  l^(0.3) * k^(0.5) * m^(0.2)
}
```

Plus de détails sont disponibles au [chapitre 10]((https://r-pkgs.org/man.html)) du livre "R Packages" d'Hadley Wickham et Jennifer Bryan.

## Exercices

<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 1. Création de fonctions**
  
1. Créer une fonction nommée `somme_n_entiers` qui retourne la somme des $n$ premiers entiers. Son seul argument sera `n` ;
2.Utiliser la fonction `somme_n_entiers()` pour calculer la somme des 100 premiers entiers ;
3. Terminer la fonction par l'assignation du résultat dans un objet nommé `res`, puis évaluer l'expression suivante : `somme_n_entiers(100)`.  Que peut-on constater ?
4. Charger les données `diamonds` du _package_ {`ggplot2`} dans la session `R` à l'aide de l'expression suivante : `data(diamonds, package = "ggplot2")`

    Créer une fonction que l'on appellera `prix_diamant_coupe()`, qui, quand on lui fournit la valeur de la coupe du diamant sous forme de caractères (`Fair`, `Good`, `Very Good`, `Premium`, ou `Ideal`), filtre le tableau de données `diamonds` pour ne conserver que les observations pour lesquelles la coupe du diamant correspond à celle indiquée en argument, et retourne le prix moyen des observations de la base ainsi filtrée ;
5. Reprendre le code de la fonction précédente, et le modifier pour retourner à présent une liste de deux éléments : (i) la moyenne des prix et (ii) l'écart-type ;
6. Créer la fonction `resume_diamant_coupe_couleur()`, qui pour une coupe et une couleur de diamant données, retourne une liste de deux éléments : (i) la moyenne des prix et (ii) l'écart-type pour les diamants possédant cette coupe et cette couleur (la couleur du diamant est une lettre allant de `J` pour les pires, à `D` pour les meilleurs). Tester la fonction pour la coupe `Fair` et la couleur `D` ;
7. Reprendre la fonction précédente, et lui attribuer la valeur `D` (en chaîne de caractères) comme argument effectif pour la couleur. Tester alors l'appel à la fonction en précisant :

  - la coupe `Fair` et la couleur `D`,
  - la coupe `Fair`, mais pas d'argument pour la couleur,
  - la coupe `Fair` et la couleur `E`,
  - la coupe non précisée mais la couleur `E` ;

```

<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 2. Création de fonctions**
  
Supposons que les adresses e-mails des étudiant•e•s d'Aix-Marseille Université sont constituées de la manière suivante : le prénom et le nom de famille séparés par un point, le symbole arobase et le enfin le nom de domaine. Supposons de plus que les étudiant•e•s ont un seul prénom, et aucune particule au nom de famille. La syntaxe des adresses e-mail est donc comme suit : `nom.prenom@etu.univ-amu.fr`.

`emails <- c("marie.petit@etu.univ-amu.fr",
              "jean.dupont@etu.univ-amu.fr",
              "isabelle.martinez@etu.univ-amu.fr",
              "pierre.moreau@etu.univ-amu.fr")`

Créer une fonction, qui à partir d'**une seule** adresse e-mail d'un•e étudiant•e, retourne un tibble contenant trois variables : le prénom, le nom et l'adresse e-mail de cet•te étudiant•e.


```




# Boucles et calculs vectoriels {#boucles}

Il existe deux sortes de boucles dans `R`. Celles pour lesquelles les itérations continuent tant qu'une condition n'est pas invalidée (`while()`), et celles pour lesquelles le nombre d'itérations est défini au moment de lancer la boucle (`for()`).

Avant de présenter chacune de ces fonctions, il est nécessaire de préciser que les boucles ne sont pas le point fort de `R`. Dès que l'on souhaite appliquer une fonction à chaque élément d'un vecteur, et/ou que le résultat de chaque itération ne dépend pas de l'itération précédente, il est préférable de vectoriser les calculs (voir Section\ \@ref(boucles-vectorisation)).

## Les boucles {#boucles_boucles}


### Les boucles avec `while()` {#boucles_boucles_while}


Quand on souhaite répéter un calcul tant qu'une condition est satisfaite, on utilise la fonction `while()`, avec la syntaxte suivante :
```{r boucles_while_syntaxe, eval=FALSE}
while(condition) instruction
```



avec `condition` un logique, comme vu dans la Section\ \@ref(manip_operateurs_logiques), et `instruction` du code, qui peut être entouré d'accolades si on souhaite évaluer plusieurs instructions.
```{r boucles_while_exemple}
x <- 100
while(x/3 > 1){
  x <- x/3
}
x/3 > 1
x
```

### Les boucles avec `for()` {#boucles_boucles_for}


Quand on connaît le nombre d'itérations à l'avance, on peut utiliser la fonction `for()`. La syntaxe est la suivante :
```{r boucles_for_syntaxe, eval=FALSE}
for(variable in vector) instruction
```

avec `variable` le nom d'une variable locale à la fonction `for()`, `vector` un vecteur à `n` éléments définissant les valeurs que prendra `variable` pour chacun des `n` tours, et `instruction` le code à exécuter à chaque itération.
```{r boucles_for_exemple}
for(nom in  c("Sonia", "Anne-Hélène", "Julien-Yacine")) print(nom)
```


On peut utiliser la fonction `for()` pour remplir les éléments d'une liste, ou d'un vecteur. à chaque itération, `R` doit trouver le vecteur de destination en mémoire, créer un nouveau vecteur qui permettra de contenir plus de données, copier données depuis l'ancien vecteur pour les insérer dans le nouveau, et enfin supprimer l'ancien vecteur [@Ross_2014_Vectorization]. C'est une opération coûteuse en temps. Un moyen de rendre cette allocation plus efficace est de créer _a priori_ le vecteur ou la liste en le remplissant avec des données manquantes. Ainsi, `R` n'aura pas besoin de ré-allouer la mémoire à chaque itération.
```{r boucles_for_exemple_avant, error=TRUE}
# Mauvaise manière
resultat <- NULL
for(i in seq_len(3)) {
  resultat[i] <- i
}
resultat

# Manière plus économique
resultat <- rep(NA, 3)
for(i in seq_len(3)) {
  resultat[i] <- i
}
resultat
```


### Les conditions {#boucles_boucles_conditions}

On peut soumettre l'exécution de codes en `R` à conditions que certaines conditions soient honorées.

#### Les instructions `if` ... `else` {#boucles_boucles_conditions_if}




Les instructions `if` et `else` fournissent un moyen d'exécuter du code si une condition est respectée ou non. La syntaxe prend deux formes :
```{r boucles_conditions_syntaxe, eval=FALSE}
# Première forme (pas de code si condition == FALSE)
if (condition) instruction

# Seconde forme
if (condition) instruction si vrai else instruction si faux
```


avec `condition` un logique et `instruction` du code à évaluer si la condition est satisfaite. à nouveau, on peut avoir recours aux accolades pour créer des regroupements.
```{r boucles_conditions_exemple}
# Simple condition
x <- 2
if(x == 2) print("Hello")
x <- 3
if(x == 2) print("Hello")

# Avec des instructions dans le cas contraire
if(x == 2) print("Hello") else print("x est différent de 2")

if(x == 2){
  print("Hello")
} else {# x != 2
  x <- x-1
  print(paste0("La nouvelle valeur de x : ", x))
}
```


```{block2, type='remarque', echo=TRUE}
Attention, lorsque l'on fait des regroupements et qu'on utilise la structure `if` et `else`, il est nécessaire d'écrire le mot `else` sur la même ligne que la parenthèse fermante du groupe d'instructions à réaliser dans le de la condition du `if` vérifiée.
```


#### La fonction `switch()` {#boucles_boucles_conditions_switch}



Avec la fonction `switch()`, on peut indiquer à `R` d'exécuter un code en fonction du résultat obtenu lors d'un test. La syntaxe est la suivante :
```{r boucles_boucles_conditions_switch_syntaxe, eval=FALSE}
switch(valeur_test,
       cas_1 = {
         instruction_cas_1
       },
       cas_2 = {
         instruction_cas_2
       },
       ...
  )
```


avec `valeur_test` un nombre ou une chaîne de caractères. Si `valeur_test` vaut `cas_1`, alors uniquement `instruction_cas_1` sera évaluée, si `valeur_test` vaut `cas_2`, alors ce sera  `instruction_cas_2` qui le sera, et ainsi de suite. On peut rajouter une valeur par défaut en utilisant la syntaxte suivante :
```{r boucles_boucles_conditions_switch_syntaxe_2, eval=FALSE}
switch(valeur_test,
       cas_1 = {
         instruction_cas_1
       },
       cas_2 = {
         instruction_cas_2
       },
       {
        instruction_defaut 
       }
  )
```


Voici un exemple d'utilisation, issu de la page d'aide de la fonction.
```{r boucles_boucles_conditions_switch_syntaxe_3}
centre <- function(x, type) {
  switch(type,
         mean = mean(x),
         median = median(x))
}
x <- rcauchy(10)
centre(x, "mean")
centre(x, "median")
```


### L'instruction `repeat` ... `break` {#boucles_boucles_repeat}



L'instruction `repeat`, ... `break` permet de répéter une expression. Il est nécessaire d'ajouter un test d'arrêt, à l'aide de l'instruction `break`.
```{r boucles_repeat}
i <- 1
repeat {
  i <- i + 1
  if(i == 3) break
}
i
```

### L'instruction `next` ... `break` {#boucles_boucles_next}



L'instruction `next` ... `break` autorise de passer immédiatement à l'itération suivante d'une boucle `for`, `while` ou `repeat`
```{r}
resul <- rep(NA, 10)
for(i in 1:10) {
  if(i == 5) next
  resul[i] <- i
}
# Le 5e élément de resul est resté non-disponible
resul
```


### Barre de progression {#boucles_boucles_progressbar}


Lorsque l'exécution d'une boucle prend du temps, il peut être intéressant d'avoir une idée de l'état d'avancement des itérations. Pour cela, il est bien sûr possible d'afficher une valeur dans la console à chaque tour, chaque 10 tours, etc.

La fonction `txtProgressBar()` du _package_ {`utils`} permet un affichage d'une barre de progression dans la console. Il suffit de lui fournir une valeur minimale et maximale, et de la mettre à jour à chaque itération. l'argument `style` autorise de surcroît à choisir un "style" pour la barre. Le style numéro 3 affiche un pourcentage de progression, et est utile lorsque d'autres résultats sont affichés dans la console lors de l'exécution de la boucle, dans la mesure où la barre est de nouveau affichée au complet dans la console si nécessaire.

Dans l'exemple qui suit, à chacun des dix tours, une pause $0.1$ seconde est effectuée, puis la barre de progression est mise à jour.
```{r boucles_boucles_progressbar_ex, eval=FALSE}
nb_tours <- 10
p_b <- txtProgressBar(min = 1, max = nb_tours, style = 3)
for(i in 1:nb_tours){
  Sys.sleep(0.1)
  setTxtProgressBar(p_b, i)
}
```



Si l'exécution est vraiment longue, et qu'on est impatient de connaître les résultats, il existe de plus une fonction amusante dans le _package_ `beepr`, qui porte le nom de `beep()`. Plusieurs sons peuvent être utilisés (voir la page d'aide de la fonction).
```{r boucles_boucles_progressbar_beep, eval=FALSE}
library(beepr)
beep("mario")
```

## La vectorisation {#boucles-vectorisation}


Comme indiqué plus haut, les boucles sont des opérations lentes en `R`. Il est cependant possible, dans de nombreux cas, d'éviter de les employer, en ayant recours à la vectorisation : au lieu d'appliquer une fonction à un scalaire, on l'applique à un vecteur. En fait, nous avons déjà eu recours à maintes reprises aux calculs vectoriels. En effet, lorsque nous avons procédé à des additions, des multiplications, etc. sur des vecteurs, nous avons effectué des calculs vectoriels.

Empruntons un exemple à @Burns_2011_R : dans des langages comme le `C`, pour effectuer la somme des logarithmes naturels des $n$ premiers entiers, voici une manière de faire :
```{r boucles_vectorisation_intro}
# Somme des logarithmes des 10 premiers entiers
somme_log <- 0
for(i in seq_len(10)){
  somme_log <- somme_log + log(i)
}
somme_log
```


Il est possible d'obtenir le même résultat, à la fois d'une manière plus élégante, mais surtout plus efficace en vectorisant le calcul :
```{r}
sum(log(seq_len(10)))
```

Ou bien, en utilisant l'opérateur Pipe, afin d'éviter la lecture pénible de cette composée de fonctions :
```{r}
seq_len(10) %>% log() %>% sum()
```


Derrière ce code, la fonction `log()` applique la fonction logarithme sur toutes les valeurs du vecteur donné en argument. La fonction `sum()`, quant à elle, se charge d'additionner tous les éléments du vecteur qui lui est donné en argument. Ces deux fonctions utilisent la vectorisation, mais d'une manière différente : la fonction `log()` applique une opération à chaque élément d'un vecteur, tandis que la fonction `sum()` produit un résultat basé sur la totalité du vecteur. L'avantage d'utiliser des fonctions vectorielles plutôt que d'écrire une boucle pour effectuer le calcul, est que ces premières font appel à des fonctions rédigées en `C` ou `FORTRAN`, qui utilisent aussi des boucles, mais comme ce sont des langages compilés et non pas interprétés, les itérations sont réalisées dans un temps réduit.


Il existe des fonctions, rédigées en `C` qui effectuent des boucles `for`. On leur donne souvent le nom de "_fonctions de la famille apply_''. Il ne s'agit pas de la vectorisation, mais ces fonctions sont souvent mentionnées dès que l'on parle de ce sujet. Ce sont des fonctionnelles qui prennent une fonction en _input_ et retournent un vecteur en _output_ [@Wickham_2014_Advanced_R_Functionals]. Ces fonctions sont très utilisées, mais elles souffrent d'un manque d'uniformité. En effet, elles ont été rédigées par des personnes différentes, ayant chacune leur convention. Le _package_ {`plyr`} remédie à ce problème, et ajoute par la même occasion des fonctions supplémentaires, pour couvrir plus de cas que les "_fonctions de la famille apply_''. Plus récemment, le _package_ {`purrr`} a également introduit des fonctions de ce type qui seront présentées ici.

Nous allons donc nous attarder dans un premier temps les fonctions du _package_ {`purr`}. Puis, afin d'en conserver une trace, sur les fonctions du _package_ {`purrr`} ainsi que celles du _package_ {`base`}.

## Avec {`purrr`} {#boucles-vectorisation-purrr}

Le _package_ {`purrr`} propose de nombreuses fonctions permettant de manipuler les listes et les tableaux de données. Dans cette partie, nous allons nous concentrer sur les fonctions de ce _package_ qui permettent d'appliquer des opérations sur chaque élément d'une liste ou sur chaque colonne d'un tableau de données. Le nom de ces fonctions commence par le préfixe `map`. Si la structure du résultat voulu est différente d'une liste, le nom de la fonction à utiliser se poursuit par un suffixe désignant la structure désirée.

| Fonction | Résultat |
| :------- | --------------------: |
| `map()`  | Liste |
| `map_chr()` | Vecteur de caractères |
| `map_dbl()` | Vecteur de _doubles_ |
| `map_int()` | Vecteur d'entiers |
| `map_lgl()` | Vecteur de booléens |
| `map_dfr()` | _data frame_ créé en concaténant par les lignes (`rows`) à chaque itération |
| `map_dfc()` | _data frame_ créé en concaténant par les colonnes (`columns`) à chaque itération |


Ces fonctions prennent les arguments suivants :

- `.x` : une liste ou un vecteur ;
- `.f` : une fonction, une formule (qui sera transformée automatiquement en fonction) ou un vecteur / une liste ;
- `...` : des arguments additionnels passés à la fonction appliquée à chaque élément.




### Listes ou vecteurs en _input_

Lorsque l'on donne une liste ou un vecteur à l'argument `.x` des fonctions de type `map`, la fonction (ou la formule) donnée en argument `.f` est appliquée à chaque élément de la liste ou du vecteur d'entrée. La structure du résultat dépend de la fonction `map` utilisée, qui est précisée à l'aide du suffixe du nom de la fonction.

Prenons un exemple. Admettons que l'on dispose d'une liste de longueur 100, dont chaque élément contient 50 valeurs numériques. On peut faire face à ce type de données lorsqu'on souhaite réaliser des simulations par ré-échantillonnage, par exemple. Dans cet exemple, nous aurions au préalable réalisé 100 rééchantillonnage différents. Admettons que l'on souhaite connaître la moyenne de chaque ré-échantillon.


Dans un premier temps, générons une liste contenant 50 éléments dans un vecteur contenant 100 éléments. Les 50 valeurs seront tirées ici selon une loi Normale dont les arguments sont aléatoirement tirées.
```{r purr_initial_sample_list}
set.seed(263)
simulations <- vector(mode = "list", length = 100)
for(i in 1:length(simulations)){
  simulations[[i]] <- rnorm(n = 50,
                            mean = sample(-10:10, 1),
                            sd = runif(1, min=1, max = 5))
}
length(simulations)
head(simulations[[1]])
```


Nous souhaitons donc calculer la moyenne de chacun des 100 éléments de cette liste. Avec une boucle `for`, on pourrait faire comme suit :
```{r purr_sample_list_for}
mean_samples <- vector(mode="numeric", length = 100)
for(i in 1:length(simulations)) 
  mean_samples[[i]] <- mean(simulations[[i]])

head(mean_samples)
```


De manière équivalente, et avec un temps d'exécution comparable, on peut utiliser une des fonctions du _package_ {`purrr`}. Ici, nous voulons appliquer à une liste en entrée, une fonction (`mean()`) sur chacun des éléments, puis obtenir le résultat final sous la forme d'un vecteur de numériques. Nous pouvons de fait utiliser la fonction `map_dbl()` comme suit :
```{r purr_sample_list_map_dbl}
mean_samples_2 <- map_dbl(simulations, mean)
head(mean_samples_2)
```

Cette méthode a l'avantage de produire un code plus élégant et plus rapide à lire.

On peut également faire appel à l'opérateur Pipe pour rendre la lecture encore plus aisée :
```{r purr_sample_list_map_dbl_pipe}
mean_samples_2 <- 
  simulations %>% 
  map_dbl(mean)
```


Admettons maintenant que nous voulons calculer le premier quartile empirique de chaque élément de `simulations`. Pour ce faire, il faut appliquer la fonction `quantile()`, en précisant à l'aide de l'argument `probs` que nous voulons le quantile d'ordre 0.25. Si on désire utiliser la fonction `map_dbl()`, il faut ajouter un argument à cette dernière pour que celui-ci soit transmis à la fonction `quantile()` (il s'agit de fait d'appeler l'argument `...` de la fonction `map_dbl()`).

```{r purr_sample_list_map_dbl_quantile}
simulations %>% 
  map_dbl(quantile, probs = .25) %>% 
  head()
```


Si à présent, nous souhaitons appliquer plusieurs fonctions à chaque élément de notre liste et récupérer le résultat sous la forme d'un tableau de données, on peut utiliser la fonction `map_df()`. Admettons que l'on souhaite obtenir, pour chaque élément, la moyenne des valeurs, le premier et le troisième quartiles. On peut procéder comme suit :


```{r purr_sample_list_map_df}
simulations %>% 
  map_df(function(x){
    tibble(mean = mean(x),
           q1 = quantile(x, probs = .25),
           q3 = quantile(x, probs = .75))
  })
```

Dans l'exemple précédent, à chaque itération, les fonctions `mean()` et `quantile()` ont été évaluées sur l'élément courant que nous avons décidé d'appeler `x`. Le résultat de l'évaluation de ces fonctions a été, à chaque itération, consigné dans un tableau, à l'aide de la fonction `tibble()`.


Afin d'éviter de devoir écrire `function(x)`, il est possible d'utiliser un raccourci : `~`. L'élément courant auquel on applique une fonction est alors désigné par le symbole `.` :


```{r purr_sample_list_map_df_lambda}
simulations %>% 
  map_df(~tibble(
    mean = mean(.),
           q1 = quantile(., probs = .25),
           q3 = quantile(., probs = .75)
  ))
```


On peut noter que dans le résultat final, les tableaux créés à chaque itération ont été collés par lignes. C'est le cas puisque nous avons fait appel à la fonction `map_df()`. Si en revanche on supprime le suffixe `_df()` de cette fonction, et que nous utilions uniquement `map()`, alors le résultat final sera rétribué dans une liste de la même longueur que celle donnée en _input_ à l'argument `.x` (c'est-à-dire `simulations` dans notre exemple) :


```{r purr_sample_list_map}
tmp <- 
  simulations %>% 
  map(~tibble(
    mean = mean(.),
    q1 = quantile(., probs = .25),
    q3 = quantile(., probs = .75))
  )
length(tmp)
tmp[[1]]
```


### Tibbles en _input_


À présent, considérons le cas où l'objet donné en entrée aux fonctions de type `map` est un tableau de données. Dans ce cas, la fonction (ou la formule) donnée à l'argument `.f` de la fonction de type `map` sera appliquée à chacune des colonnes du tableau de données.

Par exemple, pour connaître la moyenne des colonnes de type numérique dans le tableau de données `iris`, on peut dans un premier temps sélectionner uniquement les colonnes numériques à l'aide de la fonction `select_if()` en précisant que l'on souhaite conserver uniquement les colonnes pour lesquelles l'application de la fonction `is.numeric()` retournerala valeur `TRUE`. Ensuite, si on applique la fonction `map_df()` au tableau de données `iris` dont seules les colonnes numériques ont été conservées, en fournissant à l'argument `.f` la fonction `mean()`, on obtient la moyenne pour chaque colonne de ce tableau :

```{r map_df_mean_tibble}
iris %>% 
  select_if(is.numeric) %>% 
  map_df(mean)
```


Si on applique une fonction à l'aide de `map()` aux colonnes d'un tableau de données, et que cette fonction retourne plusieurs valeurs, il est possible de faire à nouveau appel à une fonction de type `map` sur le résultat pour extraire un des résultats. Admettons par exemple que l'on souhaite effectuer un test de normalité sur chacune des colonnes (numériques) du tableau de données `iris`, puis extraire la valeur-p associée au test (en effectuant, par exemple un test de Shapiro-Wilk). La valeur-p est stocjée dans un élément du résutat retourné par la fonction `shapiro.test()` nommé `p.value`

```{r map_purr_pvalue}
iris %>% 
  select_if(is.numeric) %>% 
  map(shapiro.test) %>% 
  map_dbl("p.value")
```


Comme avec les listes (cf plus haut), il est possible d'appliquer plusieurs fonctions à chaque colonne du tableau de données et de retourner sous la forme d'un tibble chaque sous-résultat. On peut par ailleurs ajouter à la fonction `map_df()` l'argument `.id` auquel on indique la valeur `"variable"` pour faire figurer une colonne indiquant le nom de chaque colonne.
```{r purrr_tibble_variable}
iris %>% 
  select_if(is.numeric) %>% 
  map_df(~tibble(
    mean = mean(.),
    q1 = quantile(., probs = .25),
    q3 = quantile(., probs = .75)
    ),
    .id = "variable"
  )
```

Evidemment, il est possible d'appliquer certaines fonctions sur des variables factorielles. Par exemple, si on désire connaître le nombre de valeurs distinctes pour chaque variable catégorielle d'un tableau de données :

```{r purrr_factor}
iris %>% 
  select_if(is.factor) %>% 
  map_df(~tibble(
    n_dist = n_distinct(.),
    class = class(.x)
    ),
  .id = "variable"
  )
```



Astuce : pour connaître le type de données de chaque colonne, on peut faire appel à la fonction `map_chr()` en appelant la fonction `class()` sur chaque colonne :

```{r purr_class}
iris %>% map_chr(class)
```



## Avec {`plyr`} {#boucles-vectorisation-plyr}




Les fonctions que nous allons aborder dans cette section possèdent des noms faciles à se remémorer : la première lettre correspond au format d'entrée des données, la seconde au format de sortie souhaité, et la fin du nom se termine par le suffixe `ply` . Ainsi, la fonction `llapply()` prend en entrée une liste, effectue une opération sur les éléments, et retourne une liste [@Anderson_2012_A_Quick].

Les différentes fonctions que nous allons passer en revue sont consignées dans le tableau ci-dessous, où les lignes correspondent aux formats d'entrée, et les lignes aux formats de sortie. Pour y avoir accès, il est possible de charger le _package_. Il est également possible de faire précéder l'appel des fonctions par le nom du _package_ (il existe de nombreux conflits de noms de fonctions entre celle de {`plyr`} et d'autres _packages_...)

| Type | `array` | `data.frame` | `list` |
| ---- |:-------:|:------------:|:------:|
| `array` | `aaply()` | `adply()` | `alply()` |
| `data.frame` | `daply()` | `ddply()` | `dlply()` |
| `list` | `laply()` | `ldply()` | `llply()` |



```{block2, type='remarque', echo=TRUE}
Il est possible d'avoir plusieurs arguments en `input` au lieu d'un seul objet. Les fonctions `mlply()`, `mdply()` et `maply()` s'en chargent. Si à la place du `m`, la première lettre est un `r`, il s'agit alors de fonction de réplications. Enfin, si la seconde lettre est un trait de soulignement (`_`), alors le résultat retourné n'est pas affiché (le code utilise la fonction `invisible()`).
```



Tous les arguments de ces fonctions commencent par un point (`.`), afin d'éviter des incompatibilités avec la fonction à appliquer.

### Array en _input_ {#boucles-vectorisation-plyr-a-ply}

Les fonctions `aaply()`, `adply()` et `alply()` appliquent une fonction à chaque portion d'un _array_ et ensuitent joignent le résultat sous forme d'un _array_, d'un _data frame_ ou d'une _list_ respectivement.

l'argument `.margins` détermine la manière de découper le tableau. Il y en a quatre pour un tableau en deux dimensions :

1. `.margins = 1` : par lignes ;
2. `.margins = 2` : par colonnes ;
3. `.margins = c(1,2)` : par cellule ;
4. `.margins = c()` : ne pas faire de découpement.


Pour un tableau en trois dimensions, il y a trois découpages possibles en deux dimensions, trois en une dimension et une en zéro dimension (voir @Wickham_2011_Split) au besoin.
```{r boucles_vectorisation_plyr_a_ply}
tableau <- array(1:24, dim = c(3, 4, 2),
                 dimnames = list(ligne = letters[1:3],
                                 colonne = LETTERS[1:4],
                                 annee = 2001:2002))
tableau


# La moyenne des valeurs pour chaque ligne
plyr::aaply(tableau, 1, mean) # résultat sous forme de tableau
plyr::adply(tableau, 1, mean) # résultat sous forme de liste
plyr::alply(tableau, 1, mean) # résultat sous forme de liste

# La moyenne des valeurs pour chaque longitude
# en ne simplifiant pas le résultat
plyr::aaply(tableau, 2, mean, .drop = FALSE)

# Par lignes et colonnes
plyr::aaply(tableau, c(1,2), mean)
plyr::adply(tableau, c(1,2), mean)
# L'affichage prend beaucoup de place
# alply(tableau, c(1,2), mean)

# Avec une fonction définie par l'utilisateur/rice
standardise <- function(x) (x - min(x)) / (max(x) - min(x))
# Standardiser les valeurs par colonne
plyr::aaply(tableau, 2, standardise)
```


### _Data frame_ en _input_ {#boucles-vectorisation-plyr-d-ply}




En économétrie, les _data frames_ sont très présents. Aussi, la connaissance des fonction `daply()`, `ddply()` et `dlply()` s'avère pratique. En effet, elles sont très utiles pour appliquer des fonctions à des groupes basés sur des combinaisons de variables. Actuellement, il est toutefois, selon moi, plus pratique d'avoir recours aux fonctions du _package_ {`dplyr`} (`group_by()`, `summarise()`, `mutate()`, ..., comme présentées dans la Section\ \@ref(tableaux_de_donnees)). À titre informatif, ces notes de cours présentent toutefois les fonctions du _package_ {`plyr`}.



Avec les fonctions `d*ply()`, il est nécessaire d'indiquer quelles variables, ou fonctions de variables on souhaite utiliser, en l'indiquant à l'argument `.variables`. Elles peuvent être contenue dans le _data frame_ fourni à l'argument `.data`, ou bien provenir de l'environnement global. `R` cherchera dans un premier temps si la variable est contenue dans le _data frame_, et, s'il ne trouve pas, ira chercher dans l'environnement global.

Pour indiquer que l'on désire faire le regroupement selon une variable --- mettons `variable_1` --- il faudra fournir l'expression `.(variable_1)` à l'argument `.variables`. Si on souhaite effectuer les regroupement selon les interactions de plusieurs variables --- `variable_1`, `variable_2` et `variable_3`, il faut alors utiliser l'expression suivante : `.(variable_1, variable_2, variable_3)`.
```{r boucles_vectorisation_plyr_d_ply}
chomage <- 
  tibble(region = rep(c(rep("Bretagne", 4), rep("Corse", 2)), 2),
         departement = rep(c("Cotes-d'Armor", "Finistere",
                             "Ille-et-Vilaine", "Morbihan",
                             "Corse-du-Sud", "Haute-Corse"), 2),
         annee = rep(c(2011, 2010), each = 6),
         ouvriers = c(8738, 12701, 11390, 10228, 975, 1297,
                      8113, 12258, 10897, 9617, 936, 1220),
         ingenieurs = c(1420, 2530, 3986, 2025, 259, 254,
                        1334, 2401, 3776, 1979, 253, 241))

chomage

# Total chomeurs en Bretagne et en Corse pour les années 2010 et 2011
# Sous forme de data frame
plyr::ddply(chomage, plyr::.(annee), summarise, total_chomeurs = sum(ouvriers + ingenieurs))
# Sous forme de tableau
plyr::daply(chomage, plyr::.(annee), summarise, total_chomeurs = sum(ouvriers + ingenieurs))
# Sous forme de liste
plyr::dlply(chomage, plyr::.(annee), summarise, total_chomeurs = sum(ouvriers + ingenieurs))

# Total chomeurs pour les années 2010 et 2011, par région du data frame
plyr::ddply(chomage, plyr::.(annee, region), summarise,
      total_chomeurs = sum(ouvriers + ingenieurs))

# Nombre d'observations pour chaque groupe
plyr::ddply(chomage, plyr::.(annee, region), nrow) 

# En utilisant une fonction définie par l'utilisateur/rice
plyr::ddply(chomage, plyr::.(annee, region), function(x){
  moy_ouvriers <- mean(x$ouvriers)
  moy_ingenieurs <- mean(x$ingenieurs)
  data.frame(moy_ouvriers = moy_ouvriers, moy_ingenieurs = moy_ingenieurs)
})
```

### _List_ en _input_ {#boucles-vectorisation_plyr-l-ply}


Les fonctions du type `l*ply()` prennent une liste en entrée. Il n'y a donc pas de paramétrage à effectuer pour choisir un découpage, il est déjà fait.
```{r}
set.seed(1)
liste <-
  list(normale =rnorm(10),
       logiques =c(TRUE, TRUE, FALSE),
       x =c(0,NA, 3))

# Obtenir la longueur de chaque élément de la liste
plyr::laply(liste, length)
plyr::ldply(liste, length)
plyr::llply(liste, length)

# Calculer la moyenne pour chaque élément
plyr::llply(liste, mean, na.rm = TRUE) %>% 
  unlist()

# Appliquer une fonction définie par l'utilisateur/rice
plyr::llply(liste, function(x, y) x /mean(x, na.rm = TRUE) + y, y = 2)
```

### Calcul parallèle {#boucles-vectorisation-plyr-parallel}



En utilisant plusieurs processeurs, on peut effectuer des calculs parallèles, ce qui accélère les calculs dans certains cas. En effet, quand il est possible de fractionner les opérations à effectuer en morceaux, on peut en réaliser une partie sur un processeur, une autre sur un second processeur, et ainsi de suite. Les résultats obtenus sont ensuite rassemblés avant d'être retournés. Le _package_ {`doMC`} (ou {`doSMP`} sur Windows) peut être chargé pour utiliser la fonction de calcul parallèle proposé par les fonctions `**ply()`. Il suffit de préciser le nombre de cœurs souhaité en faisant appel à la fonction `registerDoMC()`, et de fixer la valeur `TRUE` à l'argument `.parallel` de la fonction `**ply()`.
```{r boucles_vectorisation_plyr_parallel, eval=TRUE}
df <- 
  data.frame(valeur_1 = rnorm(12000),
         id = rep(month.abb, each = 1000))

# Fonction lente (et inutile)
f <- function(x){
  res <- rep(NA, nrow(x))
  for(i in 1:length(res)){
    res[i] <- mean(x[1:i, "valeur_1"],)
  }
  mean(res)
}

library(doMC)
# Définir le parallel backend avec le package foreach
registerDoMC(cores=4)

system.time(plyr::ddply(df, plyr::.(id), f))
system.time(plyr::ddply(df, plyr::.(id), f, .parallel = TRUE))
```


## Avec {`base`} {#boucles-vectorisation-apply}

Le tableau ci-dessous recense les fonctions principales _de la famille apply_ du _package_ {`base`}.


| Fonction | Input | Output |
|:--------:|:-----:|:------:|
| `apply()` | Matrice ou tableau | Vecteur ou tableau ou liste |
| `lapply()` | Liste ou vecteur | Liste |
| `sapply()` | Liste ou vecteur | Vecteur ou matrice ou liste |
| `vapply()` | Liste ou vecteur | Vecteur ou matrice ou liste |
| `tapply()` | Tableau et facteurs | Tableau ou liste |
| `mapply()` | Listes et/ou vecteurs | Vecteur ou matrice ou liste |


### La fonction `lapply` {#boucles-vectorisation-apply-lapply}

La fonction `lapply()` applique à chaque élément du premier argument qui lui est donné une fonction indiquée en second argument et retourne le résultat sous forme de liste. La syntaxe est la suivante :

```{r boucles_vectorisation_lapply_syntaxe, eval=FALSE}
lapply(X, FUN, ...)
```


avec `X` la liste ou le vecteur donné en argument sur lequel on désire appliquer la fonction `FUN`. L'argument `...` permet comme expliqué dans une précédente remarque, de fournir des arguments à une fonction imbriquée, en l'occurance à celle que l'on souhaite appliquer à tous les éléments de `X`.
```{r boucles_vectorisation_lapply}
liste <- 
  list(normale = rnorm(10),
       logiques = c(TRUE,  TRUE, FALSE),
       x = c(0, NA, 3))

# Obtenir la liste des longueurs de chaque élément
lapply(liste, length)

# Calculer la moyenne pour chaque élément
lapply(liste, mean, na.rm = TRUE)
```



On peut créer une fonction à l'intérieur de l'appel à la fonction `lapply()`. Le premier argument est nécessairement un élément du vecteur auquel on souhaite appliquer la fonction.
```{r boucles_vectorisation_lapply_fonction}
lapply(liste, function(x) x / mean(x, na.rm = TRUE))

# Si la fonction doit posséder plusieurs arguments
lapply(liste, function(x, y) x / mean(x, na.rm = TRUE) + y, y = 2)
```


On peut appliquer la fonction `lapply()` sur des tableaux de données, dans la mesure où ces derniers sont des listes. Cela s'avère pratique pour réaliser des opérations pour chaque colonne d'un tableau de données. Afin de prendre moins de place dans l'affichage, l'exemple suivant utilise la fonction `unlist()` pour aplatir la liste.
```{r boucles_vectorisation_lapply_fonction_df}
data(cars)

# Afficher le type de chaque colonne de la data frame "cars"
unlist(lapply(cars, class))

# Calculer la moyenne pour chaque colonne
unlist(lapply(cars, mean))
```

```{block2, type='remarque', echo=TRUE}
Attention, ce qui suit relève plus d'un tour de passe-passe que de la programmation élégante.


Si la fonction que l'on souhaite appliquer aux éléments de notre vecteur retourne un vecteur ligne de même longueur pour chaque élément, la fonction `do.call()` peut devenir un outil très pratique pour créer une _data frame_. Par exemple, définissons une liste à l'aide de `lapply()`: `l <- lapply(1:3, function(x) cbind(valeur = x, lettre = LETTERS[x]))`. Ensuite, pour coller les lignes entre-elles : `do.call("rbind", l) %>% data.frame()`.

L'appel de `do.call("rbind", x)` revient à faire `rbind(x[1], x[2], ..., x[n])` avec `x` un vecteur de taile $n$.
```


### La fonction `sapply()` {#boucles-vectorisation-apply-sapply}



La fonction `sapply()` applique une fonction aux éléments d'un vecteur ou d'une liste et peut retourner un vecteur, une liste ou une matrice. Elle possède la syntaxe suivante :
```{r boucles_vectorisation_apply_sapply_syntaxe, eval=FALSE}
sapply(X, FUN, simplify, USE.NAMES)
```


où `X` est le vecteur ou la liste auquel on souhaite appliquer la fonction `FUN`. Lorsque `simplify` vaut `FALSE`, le résultat est retourné sous forme de liste, exactement comme `lapply()` (la fonction `sapply()` s'appuie sur la fonction `lapply()`). Lorsque `simplify` vaut `TRUE` (par défaut), le résultat est retourné dans une forme simplifiée, si cela est possible. Si tous les éléments retournés par la fonction `FUN` sont des scalaires, alors `sapply()` retourne un vecteur ; sinon, si les éléments retournés ont la même taille, `sapply()` retourne une matrice avec une colonne pour chaque élément de `X` auquel la fonction `FUN` est appliquée. l'argument `USE.NAMES`, quand il vaut `TRUE` (par défaut), et si `X` est de type `character`, utilise `X` comme nom pour le résultat, à moins que le résultat possède déjà des noms.
```{rboucles_vectorisation_apply_sapply}
(x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)))

# Application de la fonction quantile() à chaque élément
# pour obtenir la médiane et les quartiles

# Avec lapply()
lapply(x, quantile)

# Avec sapply
sapply(x, quantile)

# Exemple avec USE.NAMES
sapply(LETTERS[1:3], nchar)
sapply(LETTERS[1:3], nchar, USE.NAMES = FALSE)
```

### La fonction `vapply` {#boucles-vectorisation-apply-vapply}



La fonction `vapply` est similaire à `sapply()`, mais elle possède un type de valeurs spécifié, ce qui peut rendre l'utilisation plus sûre (et parfois plus rapide). Lorsqu'on lui fournit un _data frame_, `vapply` retourne le même résultat que `sapply()`. Cependant, quand on lui fournit une liste vide, `vapply` retourne un vecteur logique de longueur nulle (ce qui est plus sensé que la liste vide que returne `sapply()`).
```{r boucles_vectorisation_apply_vapply_syntaxe, eval=FALSE}
vapply(X, FUN, FUN.VALUE, ..., USE.NAMES)
```


avec `X`, `FUN`, `...` et `USE.NAMES` les mêmes arguments que pour `sapply()`. l'argument `FUN.VALUE` doit être un vecteur, un masque pour la valeur retournée par la fonction de `FUN`.
```{r boucles_vectorisation_apply_vapply}
# Retourner le vecteur 
sapply(cars, is.numeric)
vapply(cars, is.numeric, FUN.VALUE = logical(1))

# Avec la liste vide
sapply(list(), is.numeric)
vapply(list(), is.numeric, FUN.VALUE = logical(1))
```

### La fonction `apply()` {#boucles-vectorisation-apply-apply}



La fonction `apply()` possède la syntaxe suivante :
<<boucles_vectorisation_apply_apply_syntaxe, eval = FALSE>>=
apply(X, MARGIN, FUN, ...)
@
avec `X` une matrice ou un tableau, `MARGIN` indiquant si on souhaite appliquer la fonction `FUN` aux lignes (`MARGIN = 1`) ou aux colonnes (`MARGIN = 2`), et `...` des arguments supplémentaires éventuels à passer à la fonction `FUN`.
```{r boucles_vectorisation_apply_apply}
(X <- matrix(1:9, ncol = 3))

# Somme par ligne
apply(X, MARGIN = 1, sum)

# Somme par colonne
apply(X, MARGIN = 2, sum)

# Fonction définie par l'utilisateur/rice
apply(X, MARGIN = 1, function(x) sum(x) / sum(X))
```


### La fonction `tapply()` {#boucles_vectorisation_apply_tapply}


La fonction `tapply()` s'applique à chaque cellule d'un tableau, sur des regroupements définis par les variables catégorielles fournies. La syntaxe est la suivante :
```{r boucles_vectorisation_apply_tapply_syntaxe, eval=FALSE}
tapply(X,INDEX, FUN, ..., simplify)
```

avec `X` le taleau de données, `INDEX` une liste d'un ou plusieurs facteurs, chacun de même taille que `X`. l'argument `FUN` renseigne la fonction que l'on souhaite appliquer. Si `SIMPLIFY` vaut `FALSE`, le résultat est un tableau de mode `list`. Sinon (par défaut), le résultat est un tableau de scalaires.
```{r boucles_vectorisation_apply_tapply}
data(iris)
head(iris)

# Moyenne de la longueur des sépales par espèce
tapply(iris$Sepal.Length, iris$Species, mean)

# Pour retourner le résultat sous forme de liste
tapply(iris$Sepal.Length, iris$Species, mean, simplify = FALSE)
```


### La fonction `mapply()` {#boucles_vectorisation_apply_mapply}



La fonction `mapply()` applique une fonction à plusieurs listes ou vecteurs. La syntaxe est la suivante :
```{r boucles_vectorisation_apply_mapply_syntaxe, eval=FALSE}
mapply(FUN, ..., MoreArgs, SIMPLIFY, USE.NAMES)
```


avec `FUN` la fonction à appliquer aux vecteurs ou listes fournies (grâce à `...`), `MoreArgs` une liste d'arguments supplémentaires à fournir à la fonction à appliquer. Les arguments `SIMPLIFY` et `USE.NAMES` ont le même usage que pour la fonction `sapply()`.
```{r boucles_vectorisation_apply_mapply}
(l1 <- list(a = c(1:5), b = c(6:10)))
(l2 <- list(c = c(11:15), d = c(16:20)))

# La somme des éléments correspondants de l1 et l2
mapply(sum, l1$a, l1$b, l2$c, l2$d)

# Attention au recyclage silencieux !
(l1 <- list(a = c(1:5), b = c(6:20)))
mapply(sum, l1$a, l1$b, l2$c, l2$d)
```

### La fonction `Vectorize()` {#boucles_vectorisation_Vectorize}



La fonction `Vectorize()` permet de convertir une fonction scalaire en une fonction vectorielle. Attention, cela ne permet pas d'améliorer la rapidité d'exécution du code. Par contre, son utilisation assez intuitive permet de gagner du temps. Il s'agit donc de faire l'arbitrage entre le temps passé à trouver un moyen élégant et efficace pour effectuer une opération en passant par de réels calculs vectoriels et le gain d'exécution que ce calcul vectoriel apporte vis-à-vis d'une boucle. La syntaxe de la fonction `Vectorize()` est la suivante :
```{r boucles_vectorisation_Vectorize_syntaxe, eval=FALSE}
Vectorize(FUN, vectorize.args, SIMPLIFY, USE.NAMES)
```


avec `FUN` une fonction à appliquer, `vectorize.args` un vecteur d'arguments (de type caractère) qui devraient être vectorisés (par défaut, tous les arguments de `FUN`). Les arguments `SIMPLIFY` et `USE.NAMES` on le même emploi que dans la fonction `sapply()`.
```{r boucles_vectorisation_Vectorize}
f <- function(x = 1:3, y) c(x, y)
# On "vectorise" la fonction f
vf <- Vectorize(f, SIMPLIFY = FALSE)
f(1:3, 1:3)

vf(1:3, 1:3)
# Vectorise seulement y, pas x
vf(y = 1:3)
```


## Exercices {#boucles_exercices}


<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 1. Boucle `while()`**
  
1. à l'aide de la fonction `while()`, créer une boucle qui permet de calculer la factorielle d'un nombre ;
2. Réutiliser le code de la question précédente pour en faire une fonction qui, lorsqu'on lui donne un nombre, retourne sa factorielle. Comparer le résultat avec la fonction `factorial()`.

```




<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 2. Boucles `while()` et `for()`**
  
1. Choisir un nombre mystère entre 1 et 100, et le stocker dans un objet que l'on nommera `nombre_mystere`. Ensuite, créer une boucle qui à chaque itération effectue un tirage aléatoire d'un entier compris entre 1 et 100. Tant que le nombre tiré est différent du nombre mystère, la boucle doit continuer. à la sortie de la boucle, une variable que l'on appellera `nb_tirages` contiendra le nombre de tirages réalisés pour obtenir le nombre mystère ;
2. Utiliser le code de la question précédente pour réaliser la fonction `trouver_nombre`, qui, lorsqu'on lui donne un nombre compris entre 1 et 100, retourne le nombre de tirages aléatoires d'entiers compris entre 1 et 100 nécessaires avant de tirer le nombre mystère ;
3. En utilisant une boucle `for`, faire appel 1000 fois à la fonction `trouver_nombre()` qui vient d'être créée. à chaque itération, stocker le résultat dans un élément d'un vecteur que l'on appellera `nb_essais_rep`. Enfin, afficher la moyenne du nombre de tirages nécessaires pour retrouver le nombre magique.

`nb_essais_rep <- rep(NA, 1000)`

```




<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 3. Boucles `for()`**

1. Parcourir les entiers de 1 à 20 à l'aide d'une boucle `for` en affichant dans la console à chaque itération si le nombre courant est pair ;
2. L'objet `month.name` est un vecteur contenant les noms des mois du calendrier, en anglais. Parcourir chacun des éléments de ce vecteur, et afficher dans la console pour chacun des mois si le nombre de caractères composant le nom du mois est pair ou impair.

```

<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 4. Suite de Fibonacci**
  
Utiliser une boucle `for` pour reproduire la suite de Fibonacci jusqu'à son dixième terme (la séquence $F_n$ est définie par la relation de récurrence suivante : $F_{n} = F_{n-1} + F_{n-2}$ ; les valeurs initiales sont : $F_0 = 0$ et $F_{1} = 1$).

```

<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 5. Barre de progression**
  
Considérons le vecteur de chaînes de caractères `ids` ainsi que la liste `res` : 
  
```

```{r, eval=FALSE}
library(magrittr)
n <- 1000
ids <- 
  str_c(sample(LETTERS, n, replace = TRUE),
        sample(letters, n, replace = TRUE)) %>% 
  unique()
res <- vector("list", length(ids))
```

```{block2, type='exframe', echo=TRUE}
Parcourir les éléments du vecteur \texttt{ids} à l'aide d'une boucle `for()`. à chaque itération, stocker dans l'élément de la liste `res` dont la position correspond à celle de l'identifiant courant dans `ids` les informations suivantes : (i) l'identifiant courant et (ii) la somme de $50 000$ tirages aléatoires selon une \(\mathcal{N}(0,1)\).

Afficher l'état d'avancement de la boucle à l'aide d'une barre de progression.

```

<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 6. Fonctions appliquées aux éléments d'une liste**

Soit une liste nommée `twittos`, disponible à l'adresse suivante : http://egallic.fr/Enseignement/R/Exercices/donnees/twittos.rda. Elle contient des informations fictives sur des utilisateur•rice•s de Twitter ; chaque élément de cette liste est une liste dont les éléments sont les suivants :

- `screen_name` : nom d'utilisateur•rice ;
- `nb_tweets` : nombre de tweets ;
- `nb_followers` : nombre de followers ;
- `nb_friends` : nombre de followings ;
- `created_at` : date de création du compte ;
- `location` : ville renseignée.

1. Importer le contenu du fichier dans la session `R` ;
2. Utiliser la fonction _map_ appropriée sur `twittos` pour récupérer une liste contenant uniquement les noms d'utilisateur•rice•s. Faire de même pour le nombre de followers, puis appliquer `unlist()` au résultat ;
3. Créer une fonction qui, quand on lui fournit un élément de la liste `twittos`, c'est-à-dire les informations sous forme de liste d'un•e seul•e utilisateur•rice, retourne ces informations sous forme de tableau de données. Nommer cette fonction `twittos_to_df` ;
4. Appliquer la fonction `twittos_to_df()` au premier élément de la liste `twittos`, puis utiliser la fonction _map_ appropriée pour appliquer la fonction `twittos_to_df()` à tous les éléments de la liste. Stocker ce dernier résultat dans un objet appelé `res` ;
5. Quelle est la structure de l'objet `res` obtenu à la question précédente ?
6. Importer le fichier disponible à cette adresse dans la session `R` : http://egallic.fr/Enseignement/R/Exercices/donnees/dates_tw.rda. Il s'agit d'une liste donc chaque élément contient une liste indiquant le nom d'un•e utilisateur\rice et la date de chacun de ses tweets.
7. Appliquer la fonction _map_ appropriée à la liste `dates_tw` qui vient d'être importée dans `R`, pour afficher l'heure moyenne des tweets pour chaque utilisateur•rice, puis faire de même pour l'écart-type.

```





<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 7. Fonctions appliquées aux éléments d'une matrice**

1. Créer une matrice de dimension $100\times 5$, donc chaque vecteur colonne est composé de tirages issus d'une loi Normale centrée réduite ;
2. Utiliser la fonction `apply()` pour calculer la moyenne des valeurs de chaque colonne ;
3. Utiliser la fonction `apply()` pour calculer l'écart-type des valeurs de chaque colonne.

```



# Graphiques {#graphiques}



L'analyse de données passe souvent par une phase de visualisation. `R` propose différentes méthodes pour créer des graphiques. Le _package_ {`graphics`}, qui est installé d'office et chargé par défaut au démarrage de `R`, contient de nombreuses fonctions pour réaliser des graphiques. Cependant, nous allons plutôt présenter les bases de la confection de graphiques à partir du _package_ {`ggplot2`}. Comme ce document a vocation à être une introduction, seule une infime partie des possibilités offertes par {`ggplot2`} est abordée. Le lecteur ou la lectrice intéressé•e est invité•e à consulter des excellents ouvrages ayant été publiés [@Chang_2013_R, Wickham_2009_ggplot2].

Les graphiques avec {`ggplot2`} sont crées par couches (_layers_), avec la première constituée des données brutes, puis les suivantes d'annotations, d'informations statistiques. {`ggplot2`} s'appuie sur une grammaire. L'apprentissage de cette grammaire nécessite un peu de temps, mais permet de créer des graphiques intelligibles. La grammaire graphique crée une carte, un plan (_mapping_) pour passer des données aux attributs esthétiques des objets géométriques (comme la couleur, la forme, ou la taille des points, lignes, etc.). Elle permet également d'appliquer des transformations aux données avant de les représenter, ou encore de faire du facettage (_faceting_).


Pour pouvoir utiliser les fonctions de {`ggplot2`}, il est nécessaire d'installer le _package_ lors de la première utilisation, puis de le charger les fois suivantes.
```{r graphiques_library, eval=FALSE}
# Lors de la première utilisation
install.packages("ggplot2")

# Les fois suivantes
library("ggplot2")
```

```{r graphiques_library_h, eval=FALSE}
library("ggplot2")
```



Avant de rentrer dans le vif du sujet, il est important de mentionner la page d'aide du _package_ sur Internet, qui est très bien réalisée, et s'avère être un excellent aide-mémoire : https://ggplot2.tidyverse.org/reference/.


## Structure {#graphiques_structure}

Les éléments de la grammaire graphique utilisés par {`ggplot2`} sont les suivants :

- des données brutes (**_data_**) ;
- une projection graphique pour lier ces données aux attributs esthétiques (**_mapping_**) ;
- des objets géométriques (**_geom_**) (points, lignes, polygones, etc.) ;
-des transformations statistiques (**_stats_**) ;
- des échelles (**_scale_**) qui lient les données à un espace esthétique ;
- un système de coordonnées (**_coord_**), indiquant comment les coordonnées issues des données sont positionnées sur le graphique ;
- une indication de regroupement à effectuer dans les données pour créer des sous-groupes, afin de créer des facettes (**_facet_**).


Les mots en gras dans la liste ci-avant servent de base dans les noms des fonctions du _package_ {`ggplot2`}. Par exemple, les fonctions pour définir le type de géométrie souhaité commencent par `geom_`.




La création d'un graphique avec {`ggplot2`} débute avec l'appel de la fonction `ggplot()`. Les couches supplémentaires (_layers_) sont ajoutées en ayant recours au symbole `+`. La syntaxe est la suivante :
```{r graphiques_structure_syntaxe_ggplot, eval=FALSE}
ggplot(data, aes(x, y)) + layers
```

Il est possible de stocker un graphique créé avec {`ggplot2`} dans une variable, en utilisant la flèche d'assignation. Des nouvelles couches peuvent ensuite être ajoutées à l'objet stocké.
```{r graphiques_structure_syntaxe_ggplot_assign, eval=FALSE}
p <- ggplot(data, aes(x, y)) + layers
p + new_layers
```


Les données doivent être fournies sous forme de _tibble_ ou _data.frame_ à la fonction `ggplot()`.


## Des graphiques élaborés avec `ggplot()` {#graphiques_ggplot}


Pour illustrer les différentes notions, un échantillon de 135 films est utilisé. Il est issus de la base ``film`` obtenue, à l'époque, sur un site qui s'appelait _freebase_. Ce jeu de données contient des informations relatives à la date de première date de sortie, à la durée la plus longue du film, l'estimation du budget, les revenus bruts et le premier pays indiqué concernant la réalisation du film.
```{r graphiques_ggplot_ggplot_data, eval=FALSE}
load(url("http://egallic.fr/R/films.rda"))
head(films)
```

```{r graphiques_ggplot_qplot_data_h, echo=FALSE}
load("donnees/graphiques/films.rda")
head(films)
```

Créons une sous-base, qui ne concerne que quelques pays :
```{r graphiques_ggplot_ggplot_data_reduit, message=F, warnings=F}
library(dplyr)
pays_liste <- 
  c("United States of America", "New Zealand",
    "United Kingdom", "Spain")
films_reduit <- 
  films %>% 
  filter(country %in% pays_liste)
```


Le graphique le plus commun est sans doùte le nuage de points (ou _scatterplot_).

L'exemple suivant trace des un nuage de points représentant le budget estimé de chaque film en fonction des recettes brutes. Nous avons besoin d'utiliser la fonction `geom_point()`, qui définit le type de géométrie. D'autres types de géométries sont présentés à la Section\ \@ref(graphiques_ggplot_geom).



```{r graphiques_ggplot_ggplot, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films, aes(x = estimated_budget, y = gross_revenue)) +
  geom_point()
```


### Arguments esthétiques {#graphiques_ggplot_aes}


Parmi les arguments esthétiques que l'on peut modifier, on retrouve :

- `colour` : la couleur ;
- `shape` : la forme ;
- `size` : la taille ;
- `alpha` : la transparence ;
- `fill` : le remplissage.



Dans l'exemple précédent, ces arguments n'ayant pas étés modifiés, ils ont conservé leur valeur par défaut. Pour les modifier, il suffit d'indiquer la valeur voulue à l'intérieur de la fonction `ggplot()` ou d'une fonction de géométrie.

Par exemple, pour que la couleur des points soit `dodger blue` et que la transparence soit de `0.8` :
```{r graphiques_ggplot_ggplot_col, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films,
       aes(x = estimated_budget, y = gross_revenue)) +
  geom_point(colour = "dodger blue", alpha = .8)
```


Il est également possible de faire dépendre les arguments esthétiques des valeurs prises par les variables du tableau de données. En fonction du mode de la variable utilisée, les effets seront différents. Par exemple, si on décide de faire dépendre la couleur d'une variable continue, une échelle de couleurs sera utilisée ; si la variable est discrète, une palette de couleurs est utilisée. Pour ce faire, il faut indiquer le _mapping_ à l'intérieur de la fonction `aes()`.

Par exemple, pour faire dépendre la couleur des points de la valeur prise par l'estimation de budget (variable continue) :
```{r graphiques_ggplot_ggplot_continue, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = estimated_budget, y = gross_revenue)) +
  geom_point(alpha = .8, aes(colour = estimated_budget))
```


Et pour faire dépendre la couleur des points du pays d'origine :
```{r graphiques_ggplot_ggplot_continue_2, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = estimated_budget, y = gross_revenue)) +
  geom_point(alpha = .8, aes(colour = country))
```


```{block2, type='remarque', echo=TRUE}
Une petite astuce pour créer un _bubble chart_ consiste à attribuer à l'argument `size` des valeurs prises par une variable.

```
```{r graphiques_ggplot_ggplot_bubble, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = estimated_budget, y = gross_revenue)) +
  geom_point(alpha = .8, aes(colour = country, size = runtime))
```


```{block2, type='remarque', echo=TRUE}
Si on souhaite que la couleur de la forme géométrique soit la même pour toutes les observations, il faut renseigner l'argument `color` dans la fonction `geom_*` et non pas `ggplot()`.

```

```{r graphiques_structure_geom_point_red, fig.width = 7, fig.height = 2.5, fig.align = "center"}
p_rem <- 
  ggplot(data = films_reduit, 
         aes(x = estimated_budget,
             y = gross_revenue)) +
  geom_point(colour = "red")
p_rem
```



```{block2, type='remarque', echo=TRUE}
Si on fournit un argument esthétique à la fonction `aes()`, à l'intérieur de la fonction `geom_*`, une nouvelle variable est créé, qui vaut, pour toutes les observations, la valeur attribuée à l'argument esthétique. De fait, {`ggplot2`} se charge d'interpréter cela comme une variable de mode facteur, qui ne contient qu'un niveau.

```

```{r graphiques_structure_geom_point_red_2, fig.width = 7, fig.height = 2.5, fig.align = "center"}
p_rem <- 
  ggplot(data = films_reduit, 
         aes(x = estimated_budget,
             y = gross_revenue)) +
  geom_point(aes(colour = "green"))
# La couleur pour les points va s'appuyer sur une variable qui
# vient d'être créée, et qui vaut "green" pour toutes les obs.
# Il est alors considéré qu'il n'y a qu'un facteur.
# Donc la couleur affichée sera le rose !
p_rem
```


### Arguments géométriques (fonctions `geom_*`) {#graphiques_ggplot_geom}




Pour définir le type d'objet géométrique utilisé pour représenter les données, on ajoute une couche au graphique. Le nom des fonctions qui ajoutent ce type de couches possède la syntaxe suivante : `geom_*`, où l'étoile doit être remplacée par le nom d'une forme géométrique. Les principales fonctions sont les suivantes :

- `geom_point()` : tracer des points ;
- `geom_line()` : tracer des lignes ;
- `geom_polygon()` : tracer des lignes ;
- `geom_path()` : tracer des points dans l'ordre du tableau de données
- `geom_step()` : faire un graphique en escalier ;
- `geom_boxplot()` : tracer une boîte à moustache ;
- `geom_jitter()` : mettre des points côte à côte pour une variable catégorielle ;
- `geom_smooth()` : ajouter une courbe de tendance ;
- `geom_histogram()` : tracer un histogramme ;
- `geom_bar()` : tracer un diagramme en bâton ;
- `geom_density()` : tracer une estimation de densité.

Toutes les fonctions `geom_*` possèdent les arguments optionnels suivants : `data`, `mapping`, `...`, `geom` (ou `stat`) et `position`. S'ils sont omis, leur valeur est héritée de celle des arguments correspondants de la fonction `ggplot()`. Si à l'inverse ils sont renseignés, alors leur valeur vient remplacer celle héritée. Certaines fonctions ont d'autres arguments ; le lecteur ou la lectrice est invité•e à consulter l'aide pour de plus amples détails.

Le but ici n'est pas de passer en revue chaque fonction, mais de permettre au lecteur ou à la lectrice de comprendre le fonctionnement des graphiques en couche avec {`ggplot2`}. Toutes les fonctions `geom_*` fonctionnent de la même manière. En étant capable de comprendre les exemples qui suivent, il ne devrait pas être compliqué d'explorer les cas non traités dans ce document.

#### Points {#graphiques_ggplot_geom_points}


La fonction qui permet de tracer des points a déjà été utilisées à plusieurs reprises : `geom_point()`.
```{r graphiques_ggplot_geom_point, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = estimated_budget,
           y = gross_revenue, col = country)) +
  geom_point()
```



Si on renseigne le chemin vers les données à l'intérieur de la fonction `geom_point()` plutôt que dans `ggplot()`, il faut veiller à bien préciser l'argument `data` !
```{r graphiques_ggplot_geom_point_2, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot() +
  geom_point(data = films_reduit,
       aes(x = estimated_budget,
           y = gross_revenue, col = country))
```



Attention, pour que tous les points aient la même couleur, il faut que l'argument esthétique soit fourni à `geom_point()` et non pas à `ggplot()`.
```{r graphiques_ggplot_geom_point_3, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = estimated_budget, y = gross_revenue)) +
  geom_point(colour = "red")
```

#### Lignes {#graphiques_ggplot_geom_line}


Pour tracer des lignes entre les points, il faut utiliser la fonction `geom_line()`.
```{r graphiques_ggplot_geom_line, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = estimated_budget,
           y = gross_revenue, col = country)) +
  geom_line()
```



Le fait d'ajouter l'argument `colour` et de lui donner en valeur une variable de type facteur crée automatiquement des groupes. Les points de chaque groupe seront reliés entre eux.
```{r graphiques_ggplot_geom_line_2, fig.width = 7, fig.height = 2.5}
ggplot(data = films_reduit,
       aes(x = estimated_budget,
           y = gross_revenue, group = country)) +
  geom_line()
```


#### Polygones {#graphiques_ggplot_geom_polygon}


La fonction `geom_polygon()` permet de tracer des polygones. Les coordonnées doivent être ordonnées dans le sens direct. Tandis que de nombreuses fonctions utilisant des polygones en `R` nécessitent que la première et la dernière observation soient identiques, et ce afin de pouvoir fermer le polygone, ce n'est pas obligatoire avec {`ggplot2`}.
```{r graphiques_ggplot_geom_polygon, fig.width = 7, fig.height = 2.5, fig.align = "center"}
df <- tibble(x = c(0, 0.2, 1, 0.75), y = c(0, 1, 1, 0.5))

ggplot() + 
  geom_polygon(data = df, aes(x = x, y = y), fill = "light green")
```

#### Boxplot {#graphiques_ggplot_geom_boxplot}



Pour réaliser une boîte à moustache, il faut utiliser la fonction `geom_boxplot()`.
```{r graphiques_ggplot_geom_boxplot, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = country, y = runtime, fill = country)) +
  geom_boxplot()
```

```{block2, type='remarque', echo=TRUE}
La fonction `geom_boxplot()` ne permet pas de tracer de manière élégante (au sens du code) la boîte à moustache pour une seule variable. Il faut pour cela, avoir recours à une petite astuce : fournir une variable factorielle à une seule modalité à l'esthétique `x`.

```

```{r graphiques_ggplot_geom_boxplot_seule, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = factor(1), y = runtime)) + geom_boxplot()
```


#### Gigue {#graphiques_ggplot_geom_jitter}


Une forme géométrique qui peut être pratique est `jitter`. Elle permet de placer les points côte à côte au lieu de les entasser. Dans le cas de variables catégorielles, cela peut être intéressant à utiliser.
```{r graphiques_ggplot_qplot_geom_jitter, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = country, y = estimated_budget, col = country)) +
  geom_point()

ggplot(data = films_reduit,
       aes(x = country, y = estimated_budget, col = country)) +
  geom_jitter()
```


#### Courbe de tendance {#graphiques_ggplot_geom_smooth}


On peut facilement ajouter une courbe de tendance à un nuage de points, en ajoutant une couche avec la fonction `geom_smooth()`. Des intervalles de confiance associés aux valeurs obtenues par le lissage sont automatiquement dessinés. Pour les retirer, il faut ajouter `se=FALSE` à la liste des arguments.
```{r raphiques_ggplot_ggplot_smooth, fig.width = 3, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = estimated_budget, y = gross_revenue)) +
  geom_point() +
  geom_smooth()

ggplot(data = films_reduit,
       aes(x = estimated_budget, y = gross_revenue)) +
  geom_point() +
  geom_smooth(se = FALSE)
```



L'argument `method` contrôle le type de lissage. Par défaut, la fonction `loess()` est appelée pour le réaliser, et l'argument `method` est fixé à `loess`. Si on regarde la page d'aide de cette fonction, on voit que cette dernière possède plusieurs arguments modifiables. Comme l'argument `...` est présent dans la fonction `ggplot()`, on peut transmettre à la fonction de lissage les arguments que l'on souhaite modifier.


Parmi les autres méthodes qu'il est possible d'utiliser pour le lissage, on retrouve `lm`, pour un modèle linéaire, `rlm` (_package_ {`MASS`}) pour un modèle linéaire robuste, ou encore `gam` (_package_ {`mgcv`}) pour un modèle additif généralisé.

Voici un exemple, avec un lissage par régression linéaire, avec un intervalle de confiance pour la prévision à $90\%$ :
```{r graphiques_ggplot_qplot_smooth_ic, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films, 
       aes(x = estimated_budget, y = gross_revenue)) +
  geom_point() +
  stat_smooth(method = "lm", level = 0.9)
```

#### Histogramme {#graphiques_qplot_geom_histogram}



Pour réaliser un histogramme, {`ggplot2`} propose la fonction `geom_histogram()`. La fenêtre (_bindwidth_) par défaut est l'étendue divisée par 30.
```{r graphiques_ggplot_geom_histogram, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = runtime)) +
  geom_histogram(fill = "dodger blue")
```


Si on ajoute au moins un des arguments esthétiques `colour` ou `fill` en fonction d'une variable, les histogrammes feront état des sous-groupes.
```{r graphiques_ggplot_geom_histogram_fill, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = (estimated_budget/1000000)/runtime,
           fill = country))+
  geom_histogram(binwidth = 0.1, colour = "dark grey")
```

#### Densité {#graphiques_qplot_geom_densite}



Pour afficher des estimations de la densité, il faut utiliser la fonction `geom_density()`. Le noyau peut être changé _via_ l'argument `kernel` (c.f. la page d'aide `?stat_density` pour de plus amples détails).
```{r graphiques_ggplot_geom_densite, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = (estimated_budget/1000000)/runtime)) +
  geom_density(colour = "black")
```

Si on ajoute au moins un des arguments esthétiques `colour` ou `fill` en fonction d'une variable, les densités seront estimées pour chaque sous groupe.
```{r graphiques_ggplot_geom_densite_fill, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = films_reduit,
       aes(x = (estimated_budget/1000000)/runtime,
           fill = country)) +
  geom_density(colour = "black", alpha = .5)
```


#### Rubans

L'affichage de rubans autour d'une valeur centrale permet, notamment, de réaliser une représentation graphique d'intervalles de confiance. Il suffit pour cela de faire appel à la fonction `geom_ribbon()` et de renseigner en plus des arguments `x` et `y` qui peuvent être hérités d'une couche précédente, les arguments `ymin` et `ymax` qui vont définir les valeurs minimum et maximum pour les ordonnées, respectivement, en chaque point d'abscisse.

Admettons que l'on dispose d'un tableau de données dans lequel, pour chaque unité de temps, on dispose d'une valeur de nombre de passagers estimés, ainsi que les bornes d'un intervalle de confiance données dans les colonnes `passenger_low` et `passenger_high`.

```{r graphiques_ggplot_geom_ribbon_data}
df_passengers <- 
  tibble(
  time = as.vector(time(AirPassengers)),
  passenger = as.vector(AirPassengers)) %>% 
  mutate(
    passenger_low = passenger-20,
    passenger_high = passenger+20
  )
df_passengers
```

Il faut bien penser à afficher le ruban avant la ligne (sinon cette dernière peut se retrouver cachée par le ruban si l'argument `alpha` du ruban n'autorise aucune transparence).

```{r graphiques_ggplot_geom_ribbon, fig.width = 7, fig.height = 2.5, fig.align = "center"}
ggplot(data = df_passengers,
       aes(x = time, y = passenger)) +
  geom_ribbon(aes(ymin = passenger_low, ymax = passenger_high),
              fill = "gray") +
  geom_line()
```


### Arguments statistiques {#graphiques_ggplot_stat}


Pour effectuer des opérations statistiques sur les données avant de les représenter, {`ggplot2`} propose de nombreuses fonctions. Leur nom suit la syntaxe suivante : `stat_*` avec `*` le nom d'une opération à réaliser, comme par exemple `density` pour une estimation de la densité par la méthode du noyau. Les fonctions de type `geom_*` s'appuient sur celles de type `stat_*`. Une ou plusieurs variables sont créés automatiquement lors de l'appel à ces fonctions.

Il faut savoir qu'il est possible d'accéder à ces variables, à condition de connaître leur nom, en les entourant par deux points de chaque côté. Par exemple, lorsque l'on fait appel à la fonction `geom_histogram()`, un appel interne à la fonction `stat_bin()` est fait par défaut (voir le fichier d'aide de la fonction `geom_histogram()`). Or, la fonction `stat_bin()` retourne entre autre les variables `count`, qui indique le nombre d'observations dans chaque classe créée (_bin_) ; `density` pour la densité des points dans chaque classe, mise à l'échelle pour que l'intégrale vaille 1 (pourcentage du total sur la largeur de la barre).
```{r graphiques_ggplot_stat, fig.width = 7, fig.height = 2.5, fig.align = "center"}
# Par défaut, stat_bin() utilise ..count.. en ordonnées
ggplot(data = films_reduit, aes(x = runtime)) + geom_histogram()
# Produit le même résultat
# ggplot(data = films_reduit, aes(x = runtime)) + stat_bin()

# Pour afficher la densité estimée à la place
ggplot(data = films_reduit, aes(x = runtime)) +
  geom_histogram(aes(y = ..density..))
```




Il n'est pas rare de vouloir tracer un histogramme et d'y ajouter une courbe de densité. Pour cela, avec {`ggplot2`}, on peut faire appel à la fonction `stat_density()`, soit directement, soit par l'intermédiaire de la fonction `geom_line()`, en  fournissant la valeur `"density"` à l'argument `stat`.
```{r graphiques_ggplot_stat_density, fig.width = 7, fig.height = 2.5, fig.align = "center"}
p <- ggplot(data = films_reduit, aes(x = runtime))
p + geom_histogram() + 
  geom_line(stat="density", col = "red", size = 1.2)
```



On peut voir sur le précédent graphique que les valeurs pour l'axe des ordonnées sont basées sur ce qu'utilise par défaut la fonction `geom_histogram()`[^On peut noter que si on fait appel à la fonction `geom_line()` avant `geom_histogram()`, l'étiquette de l'axe des ordonnées sera `density`, mais les valeurs seront bien celles du nombre de données par classe !], à savoir le nombre de données par classe. En revanche, l'axe des ordonnées pour la densité estimée par `stat_density()` est la valeur de la densité. Comme les valeurs de la densité sont moins élevées que celles du nombre de points par classe, on n'aperçoit qu'une forme applatie de cette première. Aussi, il faut indiquer à la fonction `ggplot()` le _mapping_ suivant : `y = ..density..`. De fait, lors de l'appel de la fonction `stat_bin()`, la valeur utilisée pour `y` sera la densité plutôt que la variable de comptage.
```{r graphiques_ggplot_stat_2, fig.width = 7, fig.height = 2.5, fig.align = "center"}
p <- ggplot(data = films_reduit, aes(x = runtime, y = ..density..))
p + geom_histogram(colour = "white") +
  geom_line(stat="density", col = "red", size = 1.2)  
```


Un dernier exemple des fonctions `stat_*()` (le lecteur ou la lectrice étant invité•e à consulter les références mentionnées au sujet de {`ggplot2`} pour plus de détails sur ces fonctions) : les estimations de densité en 2d.
```{r graphiques_ggplot_stat_3, fig.width = 7, fig.height = 2.5, fig.align = "center"}
p <- ggplot(data = films_reduit, aes(x = runtime, y = gross_revenue))

p + stat_density2d() + geom_point()
  
# En faisant dépendre la couleur des lignes de contour de la hauteur
p + stat_density2d(aes(colour = ..level..)) + geom_point()
```



Les principales fonctions `stat_*()`, qui peuvent donc être soit appelées directement, soit en fournissant le suffixe à l'argument `stat` d'une fonction `geom_*`, sont les suivantes :

- `stat_bin()` : répartition des données en classes ;
- `stat_contour()` : calculer les contours des données en 3d ;
- `stat_density()` : estimation de densité 1d par la méthode du noyau;
- `stat_density2d()` : estimation de densité 2d ;
- `stat_identity()` : ne transforme pas les données ;
- `stat_qq()` : _qqplot_ (droite de Henry) ;
- `stat_quantile()` : quantiles continus ;
- `stat_smooth()` : lissage ;
- `stat_sum()` : somme les valeurs uniques ;
- `stat_summary()` : appliquer une fonction pour faire des _summaries_ sur les valeurs de `y` ;
- `stat_unique()` : retire les valeurs dupliquées.


### Échelles (fonction `scale_*()`) {#graphiques_ggplot_scale}


Les fonctions `scale_*()` du _package_ {`ggplot2`} permettent de définir et contrôler le _mapping_ entre les données et les attributs esthétiques. Chaque argument esthétique possède son échelle, et sa fonction `scale_*()`. Encore une fois, le nom des fonctions est bien pensé, et tout est uniformisé. De fait, l'utilisateur•trice peut, une fois qu'il/elle a compris le fonctionnement d'une fonction, utiliser toutes les autres aisément.

On peut diviser en quatre catégories les échelles :

  - de positions ;
  - de couleurs ;
  - manuelles discrètes ;
  - `identity` : pas de mise à l'échelle.


Ces échelles font donc le lien entre :

- le domaine (_domain_) : il s'agit de l'espace des données. Cet espace est caractérisé de manière différente selon la nature des données. En effet, si ces dernières sont discrètes, ce qui est le cas pour les facteurs, les logiques ou encore les chaînes de caractères, alors le domaine sera une énumération des valeurs possibles. En revanche, si les données sont continues, le domaine sera être défini par un intervalle ;
- la gamme (_range_) : il s'agit de l'espace des esthétiques. La gamme sera discrète lorsque le domaine l'est, et sera constituée des valeurs esthétiques correspondantes aux valeurs des données d'_input_. En revanche, lorsque le domaine est continue, la gamme est alors un chemin, pour indiquer comment passer d'une valeur à une autre.


Les échelles sont ajoutées automatiquement aux graphiques et l'utilisateur•trice n'a rien à faire (c'est ce qui a été fait dans les sections précédentes). Cependant, la possibilité de changer ces échelles est offerte à l'utilisateur•trice, par l'intermédiaire des fonction `scale_*()`. Les échelles dépendent du type de variable en _input_, à savoir continues (_numeric_) ou discrètes (_factor_, _character_ ou _logical_). Pour ajouter ou modifier une échelle, il faut en construire une nouvelle, et l'ajouter au graphique, à l'aide, encore une fois, de l'opérateur `+`. Le nom des échelles est composé de deux ou trois parties : le préfixe `scale_`, puis le nom de l'esthétique auquel on ajoute un trait de soulignement, et enfin le nom de l'échelle à utiliser. Par exemple, pour modifier l'échelle qui gère la couleur, pour des données d'`input` continues, pour changer les couleurs du gradient, il faut utiliser la fonction `scale_colour_gradient()`.
```{r graphiques_ggplot_scale, fig.width = 7, fig.height = 2.5, fig.align = "center"}
p <- ggplot(data = films_reduit,
            aes(x = estimated_budget,
                y = gross_revenue, colour = runtime)) +
  geom_point()
p
# Changer l'échelle des couleurs pour que les films les plus courts
# soient en rouge (#FF0000), et les plus longs en jaune (#FFFF00),
# en créant un dégradé.
# On change également le titre de la légende
p + scale_colour_gradient(name = "Runtime", low = "#FF0000", high ="#FFFF00")
```



Le tableau ci-dessous répertorie les fonctions `scale_*()` en fonction du type d'esthétique et de la nature discrète ou continue des données.

| Esthétique | Variable discrète | Variable continue |
|------------|-------------------|-------------------|
| Transparence (alpha) | `scale_alpha_discrete()` | `scale_alpha_continuous()` | 
| | `scale_alpha_manual()` | |
| | `scale_alpha_identity()` | `scale_alpha_identity()` |
| Couleur (colour) | `scale_colour_discrete()` | `scale_colour_continuous()` |
| | `scale_colour_brewer()` | `scale_colour_dilstiller()` |
| | `scale_colour_grey()` | `scale_colour_gradient()` |
| | `scale_colour_hue()` | `scale_colour_gradient2()` |
| | `scale_colour_manual()` | `scale_colour_gradientn()` |
| | `scale_colour_identity()` | `scale_colour_identity()` |
| Remplissage (fill) | `scale_fill_discrete()` | `scale_fill_continuous()` |
| | `scale_fill_brewer()` | `scale_fill_distiller()` |
| | `scale_fill_grey()` | `scale_fill_gradient()` |
| | `scale_fill_hue()` | `scale_fill_gradient2()` |
| | `scale_fill_manual()` | `scale_fill_gradientn()` |
| | `scale_fill_identity()` | `scale_fill_identity()` |
| Type de ligne (linetype) | `scale_linetype_discrete()` | `scale_linetype_continuous()` |
| | `scale_linetype_manual()` | |
| | `scale_linetype_identity()` | `scale_linetype_identity()` | ￼
| Forme | `scale_shape_discrete()` | `scale_shape_continuous()` |
| | `scale_shape_manual()` | |
| | `scale_shape_identity()` | `scale_shape_identity()` |
| Taille (size) | `scale_size_discrete()` | `scale_size_continuous()` |
| | `scale_size_manual()` | `scale_size_area()` |
| | `scale_size_identity()` | `scale_size_identity()` |
| Position (x, y) | `scale_x_discrete()` | `scale_x_continuous()` |
| | `scale_y_discrete()` | `scale_y_continuous()` |
| | | `scale_x_date()` |
| | | `scale_y_date()` | 
| | | `scale_x_datetime()` |
| | | `scale_y_datetime()` |
| | | `scale_x_log10()` |
| | | `scale_y_log10()` |
| | | `scale_x_reverse()` |
| | | `scale_y_reverse()` |
| | | `scale_x_sqrt()` |
| | | `scale_y_sqrt()` |


L'emploi de ces fonctions est simple, et les fichiers d'aide lèvent les éventuels doutes. Prenons cependent le temps de regarder un second exemple. Traçons un nuage de points représentant le revenu brut des films en fonction de leur budget ; faisons dépendre la couleur et la taille des points du pays d'origine, et de la longueur du film respectivement. La couleur dépend donc d'une variable discrète, et la taille d'une variable continue.
```{r graphiques_ggplot_scale_2, fig.width = 7, fig.height = 3, fig.align = "center"}
p <- ggplot(data = films_reduit,
            aes(x = estimated_budget,
                y = gross_revenue,
                colour = country,
                size = runtime)) +
  geom_point()

# Le graphique par défaut
p

# Dégradé de gris pour la couleur, les valeurs manquantes en orange
# Le titre de la légende est aussi modifié
p + scale_colour_grey(name = "Country", start = .1, end = .8,
                      na.value = "orange")

# Définissons nous-même la couleur pour chaque pays
# Si on souhaite en plus afficher un nom différent,
# il faut faire attention à bien effectuer le matching...
# La variable "country" est transformée en facteur,
# l'ordre est alphabétique (mais peut être changé avec la fonction order())
levels(factor(films_reduit$country))

# Une première solution
p + scale_colour_manual(name = "Country",
                        values = c("red", "green", "blue", "orange"),
                        labels = c("NZ", "ES", "UK", "USA"))

# Une seconde solution, plus longue, moins esthétique, mais plus sûre
p <- 
  p + scale_colour_manual(name = "Country",
                          values = c("Spain" = "green", "New Zealand" = "red",
                                     "United States of America" = "orange",
                                     "United Kingdom" = "blue"),
                          labels = c("Spain" = "ES", "New Zealand" = "NZ",
                                     "United States of America" = "USA",
                                     "United Kingdom" = "UK"))


# Changeons également la taille
# En choisissant nous même les seuils
range(films_reduit$runtime)
p + scale_size_continuous(name = "Film\nDuration",
                          breaks = c(0, 60, 90, 120, 150, 300, Inf),
                          range = c(1,10))


# Un autre graphique, avec des dates en abscisses.
# Le package scales offre de merveilleuses fonctions !
films_reduit$initial_release_date2 <- as.Date(films_reduit$initial_release_date)
p_2 <- ggplot(data = films_reduit,
              aes(x = initial_release_date2, y = runtime)) +
  geom_point()

# En affichant les dates tous les dix ans uniquement
library(scales)
p_2 + scale_x_date(breaks = date_breaks("10 year"),
                   labels = date_format("%Y"))
```




Les légendes affichées sont fonction du _mapping_ réalisé, et {`ggplot2`} essaie de combiner les légendes autant que possible. Par exemple, si le paramétrage de la couleur et de la forme concernent la même variable, au lieu d'afficher deux légendes distinctes (une pour la couleur, et une pour la forme), une seule combinant les deux arguments esthétiques sera affichée. Par ailleurs, il est nécessaire que les légendes qui sont combinées possèdent le même nom. Il est important d'avoir conscience de cela : en effet, pour changer le titre d'une légende, si elle est le résultat d'une combinaison, il est nécessaire de le changer pour toutes les légendes qui composent la combinaison.
```{r graphiques_ggplot_scale_3, fig.width = 7, fig.height = 3, fig.align = "center"}
p <- ggplot(data = films_reduit,
            aes(x = estimated_budget, y = gross_revenue,
                colour = country_abr, size = country_abr)) +
              geom_point()

p + scale_colour_discrete(name = "Country")
p + scale_colour_discrete(name = "Country") +
  scale_size_discrete(name = "Country")
```



### Groupes {#graphiques_ggplot_group}


Dans de nombreux cas, {`ggplot2`} effectue des regroupements automatiquement, lorsqu'il y a besoin de tracer des objets géométriques. Par exemple, lorsque l'on souhaite tracer des points, chaque groupe est constitué d'un seul point. Pour tracer des polygones, chaque groupe est constitué de plusieurs points qu'il faut relier. Le groupement s'effectue en fonction des interactions de toutes les variables qualitatives d'un graphique. Parfois, il est nécessaire de définir à nouveau les groupes (par exemple, si aucune variable discrète n'est appelée dans le graphique). Pour ce faire, il faut préciser quelle variable doit permettre le regroupement, en l'indiquant à l'argument `group`. L'exemple qui suit s'appuie sur les données `AirPassengers`, qui renseignent le nombre de passagers aériens annuels entre 1949 et 1960. Si on désire afficher le nombre de passagers en fonction des mois de l'année, en superposant les courbes par année, l'argument `group` nous le permet.
```{r graphiques_ggplot_group, fig.width = 3, fig.height = 2.5, fig.align = "center", message = FALSE, warning = FALSE, fig.show='hold'}
df <- tibble(year = rep(1949:1960, each = 12),
           month = rep(1:12, 12),
           passengers = c(AirPassengers))
head(df)

# Sans préciser de groupe
# Comme il n'y a pas de variable discrète, on obtient 
ggplot(data = df, aes(x = month, y = passengers)) + geom_line()

# En précisant que l'on souhaite regrouper par années
ggplot(data = df, aes(x = month, y = passengers, group = year)) + geom_line()
```



Si on veut tracer des lignes qui relient des points au sein d'un même groupe, alors que l'échelle est discrète, il est tout à fait possible d'indiquer un changement du groupement par défaut. Il suffit alors de préciser la valeur du groupe à l'argument `group` dans la fonction `aes()` de la fonction `geom_line()`.
```{r graphiques_ggplot_group_2, fig.width = 3, fig.height = 2.5, fig.align = "center"}
# Boxplot du nombre de passager pour chaque mois
ggplot(data = df, aes(x = factor(month), y = passengers)) + geom_boxplot()

# En ajoutant les lignes de chaque année
ggplot(data = df, aes(x = factor(month), y = passengers)) +
  geom_boxplot() +
  geom_line(aes(group = year), colour = "dodger blue")
```


### Annotations {#graphiques_ggplot_annotations}



L'annotation sur un graphique peut passer par du texte, ou bien par l'ajout d'objets géométriques (_e.g._, des lignes ou des rectangles).

Les exemples qui suivent vont s'appuyer sur le graphique suivant.
```{r graphiques_ggplot_annotations, fig.width = 3, fig.height = 2.5, fig.align = "center"}
p <- ggplot(data = films_reduit,
            aes(x = estimated_budget, y = gross_revenue)) +
  geom_point()
```

#### Texte {#graphiques_ggplot_annotations_texte}


Pour ajouter du texte sur les graphiques, il existe deux fonctions dans le _package_ `ggplot` : `geom_text()` et `annotate()`, bien que la dernière soit plus générique (elle permet d'ajouter d'autres éléments que du texte). Nous ne présentons que la manière d'utiliser `annotate()`, dans la mesure où elle offre des performances accrues comparativement à  `geom_text()`.


La fonction `annotate()`, dans le cas général, créé une nouvelle couche qui contient les annotations. Les données pour faire le lien avec les arguments esthétiques ne sont pas celles du tableau de données, mais contenues dans un vecteur qu'il est nécessaire de renseigner. Par ailleurs, la forme géométrique est à définir _via_ l'argument `geom` (`"text"` pour du texte, ou encore `"segment"` pour un segment, etc.). Enfin, comme pour les couches de type `geom_*`, on peut rajouter des arguments esthétiques.

Pour ajouter du texte, on précise la position `x` et `y` (ou les positions, si on désire afficher plusieurs textes), l'argument `geom` doit recevoir la valeur `"text"` et l'argument `legend` se voit attribuer la chaîne à afficher (ou les chaînes en cas d'affichage de plusieurs textes)[^Les règles de recyclage s'appliquent !]. Si on souhaite afficher le texte d'une certaine couleur, on peut ajouter l'argument `colour` dans la fonction `annotate()`.
```{r graphiques_ggplot_annotations_texte, fig.width = 7, fig.height = 2, fig.align = "center"}
# Ajout d'un texte simple
p + annotate("text", x = 1e8, y = 2e9, label = "Du texte")

# Ajoute de deux textes, le premier en rouge, le second en bleu
p + annotate("text", x = c(1e8, 2e8), y = 2e9,
             label = c("Du texte", "Un autre texte"),
             colour = c("red", "blue"))
```



Dès lors que des lettres grecques doivent apparaître, ou bien des écritures en indice ou exposant, ou encore des symboles mathématiques, on peut rajouter l'argument `parse` évalué à `TRUE`. Pour faire apparaître une lettre grecque, il suffit d'écrire son nom. Pour écrire en indice, on utilise les crochets `[]` et pour écrire en exposant, l'accent circonflèxe `^`. Attention, pour ajouter un terme en indice et un en exposant, il est nécessaire de le faire dans l'ordre suivant : d'abord en indice, puis en exposant.
```{r graphiques_ggplot_annotations_expr, fig.width = 7, fig.height = 2, fig.align = "center"}
p + annotate("text", x = 1e8, y = 2e9,
             label = "sqrt(1-alpha) + beta[i+1]^n", parse = TRUE)
```


Il est aussi possible, pour afficher des expressions mathématiques ou des lettres grecques, de faire appel à la fonction `TeX` du _package_ {`latex2exp`}:
```{r}
library(latex2exp)
p + annotate("text", x = 1e8, y = 2e9,
             label = TeX("$\\sqrt{1-\\alpha} + \\beta^{n}_{i+1}$",
                         output = "character"),
             parse = TRUE)
```


#### Lignes {#graphiques_ggplot_annotations_lignes}



Le _package_ {`ggplot2`} contient quatre fonctions très utile pour ajouter des lignes sur un graphique, en plus des fonctions `geom_line()` et `geom_path()` :

  - `geom_vline()` : ligne verticale;
  - `geom_hline()` : ligne horizontale;
  - `geom_abline()` : ligne spécifiée par sa pente et son ordonnée à l'origine ;
  - `geom_segment()` : segment ou flèche (en utilisant `arrow()`).

```{r graphiques_ggplot_annotations_lignes, fig.width = 7, fig.height = 2, fig.align = "center"}
# Ligne verticale
p + geom_vline(xintercept = seq(0, 3e8, by = 1e8),
               size = 1, col = "dodger blue")

# Ligne horizontale
p + geom_hline(yintercept = seq(0, 2e9, by = 1e9),
               col = "gold", linetype = "longdash")

# Droite
p + geom_abline(intercept = 1e9, slope = -5)

# Segment
p + geom_segment(aes(x = 0, xend = 1e8, 
                     y = 0, yend = 1e9), col = "blue")
```


Pour les segments, il peut être plus intéressant d'utiliser la fonction `annotate()`, afin de s'affranchir de tout héritage des arguments de la fonction `ggplot()`.

```{r graphiques_ggplot_annotations_lignes_annotate, fig.width = 7, fig.height = 2, fig.align = "center"}
p + annotate(geom = "segment",
             x = 0, xend = 1e8,
             y = 0, yend = 1e9, col = "blue")
```



Pour tracer une flèche, il faut avoir recours à la fonction `arrow()` du _package_ {`grid`}.
```{r graphiques_ggplot_annotations_lignes_arrow, fig.width = 7, fig.height = 2, fig.align = "center"}
p + annotate(geom = "segment", x = 0, xend = 1e8,
             y = 0, yend = 1e9, col = "blue",
             arrow = arrow(length = unit(0.5, "cm")))
```



#### Rectangles {#graphiques_ggplot_annotations_rect}


Pour ajouter un rectangle à un graphique, ce qui peut être pratique avec des données temporelles par exemple (_e.g._, pour faire figurer les périodes de croissance ou de récession), on peut utiliser soit la fonction `geom_rect()`, soit à nouveau la fonction `annotate()`. Les deux méthodes fonctionnent à peu près de la même façon, mais encore une fois, `annotate()` permet de ne pas subir les héritages des arguments esthétiques.
```{r graphiques_ggplot_annotations_rect, fig.width = 7, fig.height = 2, fig.align = "center"}
p + annotate(geom = "rect", xmin = 1e8, xmax = 2e8,
             ymin = -Inf, ymax = Inf,
             alpha = .3, fill = "red") +
  annotate(geom  ="rect", xmin = 0, xmax = 5e8,
           ymin = 1e9, ymax = 2e9,
           alpha = .2, fill = "dodger blue")
```



### Positions {#graphiques_ggplot_position}


Pour modifier le positionnement de certains éléments dans les graphiques, {`ggplot2`} propose cinq fonctions :

- `position_dodge()` : évite les chevauchements, place les éléments côte à côte ;
- `position_fill()` : empile les éléments qui se chevauchent, en normalisant pour avoir une hauteur égale ;
- `position_identity()` : n'ajuste pas la position;
- `position_jitter()` : place les éméments côte à côte en essyant d'optimiser l'espace ;
- `position_stack()` : empile les éléments qui se chevauchent.


La manière la plus simple d'utiliser ces fonctions est de les appeler à travers l'argument `position` d'une fonction `geom_*`, en précisant uniquement le suffixe. Par exemple, avec un diagramme en bâton, pour que les barres soient côte à côte, on indique `position = "dodge"` à la fonction `geom_bar()}.


Encore une fois, même s'il est possible de réaliser une action avec une fonction de {`ggplot2`}, cela ne veut pas forcément dire que cette action est adaptée à une lecture facilitée. Ainsi, lorsque l'on fournit la valeur `"identity"` à l'argument `position` de la fonction `geom_bar()`, les barres s'entre-mêlent, et certaines peuvent devenir invisibles, cachées par une autre.

Les exemples ci-après montrent toutes les possibilités de placement pour un diagramme en bâton.
```{r graphiques_ggplot_position, fig.width = 7, fig.height = 2, fig.align = "center"}
p <- ggplot(data = films_reduit,
            aes(x = runtime, fill = country_abr))
library(grid)
p <- p + 
  theme(text = element_text(size = 5),
        legend.key.size = unit(.1, "cm")) + 
  scale_fill_discrete(name = "Country")

# Dodge
p + geom_bar(position = "dodge")

# Fill
p + geom_bar(position = "fill")

# Identity (pas pratique avec un barchart)
p + geom_bar(position = "identity", alpha = .8)

# Jitter
p + geom_bar(position = "jitter")

# Stack
p + geom_bar(position = "stack")
```

### Facettes {#graphiques_ggplot_facet}



Tout comme pour `qplot()`, on peut créer des facettes, c'est-à-dire produire des graphique de même type pour différentes sous-divisions du tableau de données, et les aligner sur une grille. {`ggplot2`} propose deux fonctions pour faire du _fateting_ : `facet_grid()` (produisant une grille à deux dimensions, pour laquelle les variables définissent les lignes et colonnes) et `facet_wrap()` (produisant les graphiques pour chaque sous-division, qui sont ensuite placés sur une grille à deux dimension, les uns après les autres).


Les deux arguments principaux de ces fonctions sont : les variables servant à faire le _faceting_, sour forme de formule, et un logique indiquant si les échelles de positions doivent être globales ou bien locales à chaque facette.


Pour être plus précis avec les exemples, nous avons besoin d'une seconde variable qualitative avec peu de modalités. Prenons arbitrairement une variable indicatrice, valant `nouveau` pour les films produits après 2000, et `ancien` sinon.

```{r}
films_reduit$old <- 
  ifelse(films_reduit$year <= 2000, "ancien", "nouveau")
```

#### La fonction `facet_grid()` {#graphiques_ggplot_facet_grid}



Pour créer une grille sur laquelle les colonnes et les lignes servent à différentier différentes modalités de variables, on utilise la fonction `facet_grid()`. L'argument `facets` attend une formule, dont la syntaxe est la suivante : `variable_ligne ~ variable_colonne`, avec `variable_ligne` le nom de la variable facteur en ligne, et `variable_colonne` le nom de la variable facteur en colonne. Le symbole `.` indique que l'on ne souhaite pas créer de facette sur la dimension :

- `.~.` (la valeur par défaut) : ne pas faire de _faceting_ ;
- `. ~ variable_colonne` : une ligne, autant de colonnes que de valeurs possibles pour `variable_colonne` ;
- `variable_ligne ~ .` : autant de lignes que de valeurs possibles pour `variable_ligne`, une seule colonne ;
- `variable_ligne ~ variable_colonne` : autant de lignes que de valeurs possibles pour `variable_ligne`, autant de colonnes que de valeurs possibles pour `variable_colonne`.

```{r graphiques_ggplot_facet_grid, fig.width = 7, fig.height = 3, fig.align = "center"}
p <- ggplot(data = films_reduit,
            aes(x = estimated_budget,
                y = gross_revenue,
                colour = country,
                size = runtime)) +
  geom_point()

# Avec une colonne pour chaque pays
p + facet_grid(. ~ country)

# Avec en ligne la récence du film, et en colonne le pays
p + facet_grid(old ~ country)
```



On peut ajouter une option pour avoir les situations marginales (similairement au tableau obtenu, dans le cas de deux variables aléatoires discrètes, faisant figurer les lois marginales en bout de ligne et de colonne). Pour ce faire, il faut attribuer la valeur `TRUE` à l'argument `margins`. Si on souhaite afficher uniquement les facettes supplémentaires pour une variable mais pas les deux, il faut fournir le nom de cette variable à l'argument `margins`.
```{r graphiques_ggplot_facet_grid_margins, fig.width = 7, fig.height = 3, fig.align = "center"}
p + facet_grid(old ~ country, margins = TRUE)

# Ajout d'une facette avec tous les pays, en différenciant par ligne (récence)
p + facet_grid(old ~ country, margins = "country")
```

#### La fonction `facet_wrap()` {#graphiques_ggplot_facet_wrap}



La fonction `facet_wrap()` fonctionne un peu différemment de `facet_grid()`. En effet, au lieu de travailler en fonction de variables par lignes et par colonnes, elle crée une succession de graphiques qui sont **par la suite** placés sur une grille à deux dimensions. Pour créer les facette, il faut renseigner une formule à l'argument `facets`. La syntaxe pour la formule est la suivante : `~ variable_1 + variable_2 + ... variable_n`. La grille finale sera ce qui se rapproche le plus d'un carré. Dans les cas où ce n'est pas possible, la grille sera plutôt large que longue (nos écrans sont généralement configurés ainsi, ce qui explique ce choix).
```{r graphiques_ggplot_facet_wrap, fig.width = 7, fig.height = 3, fig.align = "center"}
# Avec une seule variable
p + facet_wrap(facets = ~ country)

# Avec deux variables
p + facet_wrap(facets = ~ country + old)
```


#### Échelles et facettes {#graphiques_ggplot_facet_scales}



Que ce soit pour `facet_grid()` ou `facet_wrap()`, il est possible de préciser  si les échelles de positions doivent s'appliquer à tous les graphiques de la grille, ou bien doivent varier. Cela se fait _via_ l'argument `scales`. On distingue quatre options :


- `fixed` : les échelles les fixes, identiques pour chaque graphique ;
- `free` : les échelles peuvent varier en fonction de chaque graphique de la grille ;
- `free_x` : seule l'échelle pour les `x` peut varier, l'échelle pour les `y` est fixe, commune à chaque graphique de la grille ;
- `free_y` : seule l'échelle pour les `y` peut varier, l'échelle pour les `x` est fixe, commune à chaque graphique de la grille.

```{r graphiques_ggplot_facet_scales, fig.width = 7, fig.height = 4, fig.align = "center"}
p_m <- ggplot(data = films_reduit,
       aes(estimated_budget/1000000, 
           gross_revenue/1000000, 
           colour = country, 
           size = runtime)) +
  geom_point()

# Toutes les échelles identiques
p_m + facet_wrap( ~ country, scales = "fixed")

# Échelles variant pour chaque graphique de la grille
p_m + facet_wrap( ~ country, scales = "free_y")
```


### Coordonnées {#graphiques_ggplot_coord}


Le _package_ {`ggplot2`} gère plusieurs systèmes de coordonnées différents, le système cartésien étant celui utilisé par défaut. Pour définir le système souhaité, il faut faire appel aux fonctions commençant par `coord_` :

- `coord_cartesian()` : coordonnées cartésiennes ;
- `coord_fixed()` : coordonnées cartésiennes avec la même échelle pour les deux axes ;
- `coord_flip()` : coordonnées cartésiennes avec les axes renversés ;
- `coord_map()` : projections pour les cartes ;
- `coord_polar()` : coordonnées polaires ;
- `coord_trans()` : coordonnées cartésiennes transformées.

```{r graphiques_ggplot_coord, fig.width = 2, fig.height = 3, fig.align = "center"}
p <- ggplot(data = films,
            aes(x = estimated_budget/1e6,
                y = gross_revenue/1e6)) +
  geom_point()
# En renversant les axes
p + coord_flip()

# En effectuant une transformation du système de coordonnées
p + coord_trans(x = "log10", y = "log10")
```

```{block2, type='remarque', echo=TRUE}
Nous avons vu que la fonction `scale_x_log10()` (Section\ \@ref(graphiques_ggplot_scale)) permet aussi de changer les échelles en échelles logarithmiques. Cependant, il y a une petite différence : avec `coord_trans`, la transformation est réalisée après la réalisation de statistiques. Cela a un impact, par exemple, sur les lignes du quadrillage

```

```{r graphiques_ggplot_coord_remarque, fig.width = 7, fig.height = 2, fig.align = "center"}
p + scale_x_log10()
```


### Titres, axes, légendes {#graphiques_ggplot_axes}


Jusqu'ici, les graphiques proposés en exemple souffrent pour la plupart de l'absence de titre, de légendes illisibles, etc. Heureusement, tout cela est paramétrable !

Pour ajouter un titre, rien de plus simple : faire appel à la fonction `ggtitle()`, et fournir le titre à l'argument `label`. Pour changer les étiquettes des axes, on peut faire appel aux fonctions `xlab()` et `ylab()` pour l'axe des `x` et des `y` respectivement, et renseigner l'argument `label`.
```{r graphiques_ggplot_axes, fig.width = 7, fig.height = 2, fig.align = "center"}
p <- ggplot(data = films,
            aes(x = estimated_budget/1e6,
                y = gross_revenue/1e6)) +
  geom_point() +
  ggtitle("Titre") +
  xlab("Étiquette axe des x") +
  ylab("Étiquette axe des y")
```

La fonction `labs()` permet de gérer les trois en même temps :
```{r graphiques_ggplot_axes_labs, fig.width = 7, fig.height = 2, fig.align = "center"}
p <- ggplot(data = films,
            aes(x = estimated_budget/1e6,
                y = gross_revenue/1e6)) +
  geom_point() +
  labs(
    title = "Titre",
    x = "Étiquette axe des x",
    y = "Étiquette axe des y"
  )
```


Pour définir manuellement les limites des axes, on peut utiliser les fonctions `xlim()` et `ylim()`. Attention toutefois, les valeurs en dehors des intervalles définis seront complètement jetées, les autres couches hériteront des données appartenant aux intervalles définis. Pour changer les limites des axes sans jeter de données, il faut faire appel à la fonction `coord_cartesian()`.
```{r graphiques_ggplot_axes_limites, fig.width = 2, fig.height = 2, fig.align = "center"}
df <- tibble(x = c(0, 0, 5, 5, 0, 0, 10, 10), 
             y = c(0,5, 5, 0, 10, 15, 15, 10),
             g = factor(rep(1:2, each = 4)))

p_2 <- ggplot(data = df, aes(x = x, y = y, group = g, fill = g)) +
  geom_polygon()
p_2 <- ggplot(data = df, aes(x = x, y = y, group = g, fill = g)) +
  geom_polygon() +
  theme(legend.position="none")

# Le graphique par défaut
p_2

# En jouant avec la limite des x avec la fonction xlim()
p_2 + xlim(0, 7)

# Avec la fonction coord_cartesian()
p_2 + coord_cartesian(xlim = c(0,7))
```



Le changement des arguments des légendes est un peu moins simple. Il faut passer par la fonction `theme()`. Le lecteur ou la lectrice est invité•e à consulter la page d'aide de la fonction à l'adresse suivante : http://docs.ggplot2.org/current/theme.html. Dès que l'on souhaite modifier l'aspect de la légende, des marques des axes, des étiquettes des axes, des lignes principales et secondaires formant le quadrillage, etc. il faut utiliser la fonction `theme()`.

Les éléments pouvant être changés sont nombreux. Il y a quatre types de fonctions pour modifier les éléments :

- `element_text()` : pour toutes les étiquettes, ce qui est au format texte. On peut modifier :

  -  `family` : la famille de la fonte,
  - `face` : graisse ("plain", "italic", "bold", "bold.italic"),
  - `colour` : couleur,
  - `size` : taille en pts,
  - `hjust` : justification horizontale, dans [0, 1],
  - `vjust` : justification verticale, dans [0, 1],
  - `angle` : angle, dans [0, 360],
  - `lineheight` : hauteur de ligne (pour l’espacement entre les lignes) ;
  
- `element_line()` : pour toutes les lignes tracées. On peut modifier :

  - `colour` : la couleur de ligne,
  - `size` : la taille,
  - `linetype` : le type de ligne ("blank", "solid", "dashed", "dotted", "dotdash", "longdash", "twodash),
  - `lineend` : le type de fin de ligne ("round", "butt" ou "square") ;

- `element_rect()` : pour les backgrounds et les cadres. On peut modifier :

  - `fill` : la couleur de remplissage,
  - `colour` : la couleur de la bordure,
  - `size` : la taille de la bordure,
  - `linetype` : le type de ligne ("blank", "solid", "dashed", "dotted", "dotdash", "longdash", "twodash) ;

- `element_blank()` permet de ne rien dessiner.


```{r graphiques_ggplot_axes_theme, fig.width = 7, fig.height = 3, fig.align = "center"}
p <- ggplot(data = films_reduit,
            aes(x = estimated_budget/1e6, 
                y = gross_revenue/1e6,
                colour = country_abr)) +
  # Tracer des points
  geom_point() + 
  # Ajout d'un titre
  ggtitle("Titre\nsur deux lignes") +
  # Changement des étiquettes pour les axes
  xlab("Étiquette axe des x") + ylab("Étiquette axe des y") +
  # Changement du titre de la légende
  scale_colour_discrete(name = "Country")

# Le graphique par défaut
p

# En changeant certains éléments
p + theme(plot.title = element_text(family = "Times", face = "bold",
                       colour = "red",
                       size = rel(2),
                       hjust = 0,
                       lineheight = 1.5),
          axis.title = element_text(face = "bold", colour = "orange"),
          axis.text.x = element_text(colour = "blue", angle = 45),
          axis.ticks = element_line(colour = "brown", size = rel(2)),
          legend.key = element_rect(fill = "dodger blue", colour = "red"),
          legend.background = element_rect(fill = "green",
                                           colour = "purple",
                                           linetype = "twodash"),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_line(colour = "black")
          )
```



Comme on peut le voir, changer les arguments graphiques peut facilement produire un graphique difficile à lire. Le thème par défaut dans {`ggplot2`} a été étudié, il convient dans de nombreux cas (pour un affichage sur un écran d'ordinateur). Mais on est parfois amené à effectuer quelques changements, d'où l'importance deprésenter la méthode pour réaliser ces changements. Par ailleurs, il existe d'autres thèmes réfléchis dans le _package_ {`ggplot2`}, parmi lesquels `theme_bw()` (_background_ blanc et grilles noires) ou `theme_grey()` (_background_ gris et grilles blanches) ou encore `theme_mini()` (pour un affichage minimaliste).

```{r graphiques_ggplot_axes_theme_3, fig.width = 7, fig.height = 2, fig.align = "center"}
p + theme_bw()
```


Certains développent des thèmes supplémentaires. Voir par exemple sur ce \emph{github} : \url{https://github.com/jrnold/ggthemes}.


Depuis 2020, il est possible dans {`ggplot2`} de choisir d'afficher le titre du graphique tout à gauche, aligné avec les étiquettes de l'axe des ordonnées, en renseignant à `"plot"` l'argument `plot.title.position` de la fonction `theme()` :
```{r graphiques_ggplot_axes_theme_title_pos, fig.width = 7, fig.height = 2, fig.align = "center"}
p + theme(plot.title.position = "plot")
```


Pour aller plus loin sur la conception des graphiques, je vous propose deux pistes :

1. La présentation filmée de William Chase intitulée "[The Glamour of Graphics](https://rstudio.com/resources/rstudioconf-2020/the-glamour-of-graphics/)", donnée le 30 janvier 2020 à la conférence RStudio ;
2. Un article intitulé "[An Economist's Guide to Visualizing Data](https://www.aeaweb.org/articles?id=10.1257/jep.28.1.209)", rédigé par Jonathan A. Schwabish et publié dans Journal of Economic Perspectives [@schwabish2014economist].



## Enregistrement des graphiques {#graphiques_enregistrement}

Pour enregistrer un graphique créé avec la fonction `qplot()` ou `ggplot()`, rien de plus simple : la fonction `ggsave()`. Ses arguments sont les suivants :

- `filename` : nom du fichier, ou chemin et nom du fichier;
- `plot` : graphique à sauvegarder (par défaut, le dernier graphique, en faisant appel à la fonction `last_plot()`;
- `device` : dispositif à utiliser (automatiquement extrait de l'extension du fichier indiqué à l'argument `filename`);
- `path` : chemin vers le fichier ;
- `scale` : facteur d'échelle;
- `width` : largeur (par défaut, celle de la fenêtre de graphique actuelle) ;
- `height` : hauteur (par défaut, celle de la fenêtre de graphique actuelle) ;
- `units` : unité pour la largeur et la longueur (`"in"`, `"cm"` ou `"mm"`);
- `dpi` : nombre de points par pouce, uniquement pour les images matricielles ;
- `limitsize` : quand `TRUE` (la valeur par défaut), l'image sauvegardée ne dépassera pas les $50\times 50$ in.

La fonction `ggsave()` est capable de reconnaître les extensions de fichiers suivants :`eps/ps`, `tex`, `pdf`, `jpeg`, `tiff`, `png`, `bmp`, `svg` et `wmf` (ce dernier étant valable uniquement pour Windows).

```{r graphiques_enregistrement, fig.width = 7, fig.height = 3, fig.align = "center", eval = FALSE}
p <- ggplot(data = films_reduit, 
            aes(x = estimated_budget,
                y = gross_revenue,
                colour = country)) +
  geom_point() + xlab("Estimated budget") + ylab("Gross Revenue") +
  scale_colour_discrete(name = "Country") +
  ggtitle("A small sample of movies")

p

# Sauvegarde dans le répertoire de travail,
# au format pdf, le dernier graphique affiché créé via ggplot2,
# aux dimensions égales à la fenêtre des graphiques
ggsave("estim_bud.pdf")


# En précisant plus d'arguments
ggsave(p, 
       file = "estim_bud.pdf", width = 15, height = 8,
       unit = "cm", scale = 2)
```



## Cartes {#graphiques_maps}


Avec {`ggplot2`}, il est très facile de dessiner des cartes. Il faut cependant charger quelques autres _packages_. Attention, le but de cette section est de montrer des méthodes pour dessiner des cartes. Le lecteur ou la lectrie intéressé•e par les traitements des données spatiales ne trouvera pas satisfaction avec cette introduction à l'utilisation de `R` et devra plutôt consulter d'autres références (_e.g._,  @Bivand_2008_Applied).

### Récupérer des cartes toutes faites {#graphiques_maps_recup}



La première chose nécessaire à la création d'une carte, est de disposer des données pour pouvoir tracer les frontières. Dans les cas les plus simples, on peut récupérer des jeux de données présents dans des _packages_. 


#### _Package_ `rworldmap` {#graphiques_maps_recup_rworldmap}




La fonction `getMap()` permet d'accéder à une carte stockée dans le _package_. Ensuite, on applique la fonction `fortify()`, pour transformer le `SpatialPolygonsDataFrame` qui a été retourné par la fonction `getMap()` en tableau de données, afin d'avoir un format lisible par la fonction `ggplot()`.

```{r graphiques_maps_recup_rworldmap, fig.width = 7, fig.height = 3, fig.align = "center"}
library(ggplot2)
library(rworldmap)

# Carte du monde
worldMap <- getMap()
# Format lisible pour ggplot()
world_df <- fortify(worldMap)

head(world_df)

worldmap <- ggplot() +
  geom_polygon(data = world_df, 
               aes(x = long, y = lat, group = group)) +
  scale_y_continuous(breaks = (-2:2) * 30) +
  scale_x_continuous(breaks = (-4:4) * 45) +
  coord_equal()

worldmap
```


On peut tout à fait s'amuser avec la fonction `coord_map()` pour changer le système de coordonnées.
```{r graphiques_maps_2, fig.width = 7, fig.height = 3, fig.align = "center"}
worldmap <- ggplot() +
  geom_polygon(data = world_df, aes(x = long, y = lat, group = group)) +
  scale_y_continuous(breaks = (-2:2) * 30) +
  scale_x_continuous(breaks = (-4:4) * 45) +
  coord_map("ortho", orientation=c(61, 90, 0))
worldmap
```

#### _Package_ \texttt{maps} {#graphiques_maps_recup_maps}



Le _package_ `rworldmap` est pratique pour obtenir les frontières des pays, mais si on désire obtenir les `counties` américains, ou les départements français, il est préférable d'aller voir du côté du _package_ {`maps`}. La fonction `map_data()` du _package_ {`ggplot2`} s'appuie sur les cartes du _package_ {`maps`} pour extraire un tableau de données prêt à être employé avec la fonction `ggplot()`. Il faut lui fournir le nom de la carte voulu, parmi les noms suivants :

- `county` : carte des `counties` américains ;
- `france` : carte de la France;
- `italy` : carte de l'Italie;
- `nz` : carte de la Nouvelle-Zélande;
- `state` : carte des états-Unis avec chaque état ;
- `usa` : carte des états-Unis avec uniquement les frontières;
- `world` : carte du monde ;
- `world2` : carte du monde centrée sur le Pacifique.

Si on désire extraire uniquement certains sous-régions, il faut préciser leur nom à l'argument `region`.

```{r graphiques_maps_recup_maps, fig.width = 7, fig.height = 3, fig.align = "center"}
map_fr <- map_data("france")

# Le nom des régions
head(unique(map_fr$region))

# Carte de la France
p_map_fr <- 
  ggplot(data = map_fr,
         aes(x = long, y = lat, group = group, fill = region)) +
  geom_polygon() + coord_equal() + scale_fill_discrete(guide = "none")

p_map_fr

# Extrayons les données uniquement pour la Bretagne
ind_bzh <- 
  str_which("armor|finis|vilaine|morb",
       pattern = regex(unique(map_fr$region), ignore_case = TRUE))

# Voici les noms des départements de la Bretagne, tels qu'ils sont
# stockés dans le package maps
(dep_bzh <- unique(map_fr$region)[ind_bzh])

map_fr_bzh <- 
  map_data("france", region = dep_bzh) %>%
  as_tibble()

# Carte de la Bretagne
p_map_fr_bzh <- 
  ggplot(data = map_fr_bzh,
         aes(x = long, y = lat, group = group, fill = region)) +
  geom_polygon() + coord_equal() + scale_fill_discrete(name = "Département")

p_map_fr_bzh
```

#### Fichier _shapefile_ {#graphiques_maps_recup_shapefile}



Il est également possible d'importer un fichier `shp` et de tracer une carte basée sur son contenu. Il est cependant nécessaire de charger quelques _packages_ supplémentaires. Par exemple, pour tracer les quartiers de la ville de Rennes, on peut télécharger et extraire le contenu du fichier _shapefile_ zippé disponible sur le site : http://www.data.rennes-metropole.fr. L'importation dans `R` se fait comme suit, en ayant placé le répertoire `"quartiers_shp_lamb93"` que l'on vient d'extraire dans le dossier pointé par la fonction `getwd()`[^pour plus de renseignements, voir ce GitHub : https://github.com/hadley/ggplot2/wiki/plotting-polygon-shapefiles].

```{r graphiques_maps_recup_shapefile, eval = FALSE}
library("rgdal")
library("maptools")
library("ggplot2")
library("plyr")

# Importer les polygones
rennes <- readOGR(dsn="./quartiers_shp_lamb93", layer="quartiers")

# Étape pour changer la projection de la carte
rennes <- spTransform(rennes, CRS("+proj=longlat +ellps=GRS80"))

# Pour permettre la jointure des objets géométriques
rennes@data$id <- rownames(rennes@data)

# Transformer en data frame pour fournir à ggplot()
rennes_points <- fortify(rennes, region="id")

# Permet d'éviter des trous éventuels
rennes_df <- join(rennes_points, rennes@data, by="id")
```

```{r graphiques_maps_recup_shapefile_h, echo = FALSE, warnings=FALSE, message = FALSE}
library("rgdal")
library("maptools")
library("ggplot2")

load("donnees/graphiques/rennes_df.rda")
```


Il ne reste plus qu'à tracer la carte.
```{r graphiques_maps_recup_shapefile_2, fig.width = 7, fig.height = 3, fig.align = "center"}
p_map_rennes <- 
  ggplot(data = rennes_df,
         aes(x = long, y = lat, group = group)) +
  geom_polygon() +
  coord_equal()

p_map_rennes
```

### Carte choroplèthe {#graphiques_maps_choroplethe}


Pour réaliser une carte choroplète, c'est-à-dire une carte où les régions sont remplies par une couleur en fonction d'une statistique, il suffit juste d'ajouter une colonne avec la valeur de la statistique dans le tableau de données permettant de dessiner la carte. Appuyons-nous sur la carte de la Bretagne définie en Section\ \@ref(graphiques_maps_recup_maps).


```{r graphiques_maps_choroplethe, fig.width = 7, fig.height = 3, fig.align = "center"}
tx_chomage_2014_T1 <- 
  tibble(
  region = c("Cotes-Darmor","Finistere",
             "Ille-et-Vilaine", "Morbihan"),
  tx_chomage_2014_T1 = c(8.8, 8.8,7.9, 9.1))

# Ajout des valeurs pour chaque région
map_fr_bzh <- 
  map_fr_bzh %>% 
  left_join(
    tx_chomage_2014_T1
  )


# Il suffit de faire dépendre le remplissage de tx_chomage_2014_T1
p_map_fr_bzh <- 
  ggplot(data = map_fr_bzh) +
  geom_polygon(aes(x = long, y = lat, group = group,
             fill = tx_chomage_2014_T1)) + 
  coord_equal() + 
  scale_fill_gradient(name = "Département", low ="#FFFF00", high = "#FF0000")

p_map_fr_bzh
```


```{r graphiques_maps_choroplethe_2, fig.width = 7, fig.height = 3, fig.align = "center"}
# Fonction pour trouver le point central du polygone
mid_range <- function(x) mean(range(x, na.rm = TRUE))

centres <- 
  map_fr_bzh %>% 
  group_by(region) %>% 
  summarise(lat = mid_range(lat),
            long = mid_range(long))


# Rajout des taux de chômage
centres <- 
  centres %>% 
  left_join(tx_chomage_2014_T1) %>% 
  mutate(label_chomage = str_c(tx_chomage_2014_T1, "%"))

p_map_fr_bzh + 
  geom_label(aes(x = long, y = lat, label = label_chomage),
             data = centres)

```


## Graphiques en 3D {#graphiques_3d}



Le _package_ {`ggplot2`} ne permet malheureusement pas (encore) de réaliser des graphiques en 3D. Il faut aller regarder du côté des _packages_ {`base`}, {`lattice`} ou encore {`rgl`} pour cela. Le lecteur ou la lectrice intéressé•e par ces options offertes par `R` est invité•e à consulter les pages d'aide des fonctions, à parcourir les vignettes et les démos. 
```{r graphiques_3d_persp, fig.width = 7, fig.height = 5, fig.align = "center"}
library(MASS)
set.seed(1)
# Normale bivariée
Sigma <- matrix(c(10,3,3,2),2,2)
biv_n <- mvrnorm(n=1000, rep(0, 2), Sigma)

# Estimation par la méthode du noyau de la densité
biv_n_kde <- kde2d(biv_n[,1], biv_n[,2], n = 50)

persp(biv_n_kde, theta = 10, phi = 15, xlab = "X")
```


Une autre fonction, peut-être plus pratique pour visualiser des graphiques en 3d, puisqu'on peut se servir de la souris pour changer d'angle, est `plot3d()`, du _package_ {`rgl`}.
```{r graphiques_3d, eval=FALSE}
library(rgl)
set.seed(1)
n <- 10000
x <- rnorm(n, mean = 38)
y <- rnorm(n, mean = 42)

biv_kde <- kde2d(x, y, n = 50)
den_z <- biv_kde$z

surface3d(biv_kde$x,biv_kde$y,den_z*20,color="#FF2222",alpha=0.5)
```


Pour les personnes intéressées, l'exécution des lignes ci-après donne un aperçu plus large de ce qu'il est possible de faire avec le _package_ {`rgl`}.
```{r graphiques_3d_demo, eval=FALSE}
demo(rgl)
example(rgl)
```

## Exercices {#graphiques_exercices}


<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 1 : créer un graphique simple, modifier son aspect**
1. Charger le _package_ {`ggplot2`}, et utiliser la fonction `data()` pour charger en mémoire le jeu de données `economics`. Consulter la page d'aide de ce jeu de données pour prendre connaissance de son contenu ;
2. À l'aide de la fonction `ggplot()`, représenter les dépenses personnelles de consommation (`pce`) en fonction de la date (`date`). Les observations doivent être connectées par une ligne.
3. Modifier le graphique de la question précédente de manière à ce que la couleur de la ligne soit `dodger blue` et définir la taille de la ligne à `0.5`. Stocker le résultat dans un objet que l'on appellera `p_1` ;
4. Ajouter une couche au graphique `p_1` pour modifier les titres des axes (les retirer), et définir le titre suivant : "Personal Consumption Expenditures (billions dollars)".
5. Utiliser la fonction `date_breaks()` du _package_ {`scales`} pour modifier l'échelle des abscisses de `p_1`, afin que les étiquettes des marques soient affichées tous les 5 ans ; à l'aide de la fonction `date_format()`, modifier le format de ces étiquettes pour que seule l'année des dates s'affiche.

```



<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 2 : créer un graphique avec plusieurs courbes, modifier son aspect**
  
1. Charger le _package_ {`ggplot2`}, et utiliser la fonction `data()` pour charger en mémoire le jeu de données \texttt{economics}. Consulter la page d'aide de ce jeu de données pour prendre connaissance de son contenu ;
    
2. Charger le _package_ {`}tidyverse`}. Sélectionner les variables `date`, `psavert` et `uempmed` dans le tableau de données `economics` et utiliser la fonction `pivot_longer()` sur le résultat pour obtenir un tableau dans lequel chaque ligne indiquera la valeur (`value`) pour une variable donnée (`key`) à une date donnée (`date`). Stocker le résultat dans un objet que l'on appellera `df` ;
    
3. Sur un même graphique, représenter à l'aide de lignes, l'évolution dans le temps du taux d'épargne personnelle (`psavert`) et de la durée médiane en semaines du chômage (`uempmed`). Stocker le graphique dans un objet que l'on appellera `p_2` ;
    
4. Modifier le code ayant servi à construire le graphique `p_2` pour que le type de ligne soit différent pour chacune des deux séries représentées. Les deux lignes doivent être tracées en bleu. Stocker le graphique dans un objet que l'on appellera `p_3` ;
    
5. À présent, modifier le code ayant servi à construire `p_3` pour qu'à la fois la couleur et le type de ligne servent à différencier les deux séries. Stocker le graphique dans un objet que l'on appellera `p_4` ;
    
6. Modifier le graphique `p_4` en ajoutant une couche d'échelle de couleur pour que le taux d'épargne personnelle (`psavert`) soit représenté en `dodger blue`, et que la durée de chômage (`uempmed`) soit représentée en rouge. Par ailleurs, retirer le titre de la légende ;
    
7. Modifier le graphique `p_4` en ajoutant une couche d'échelle de type de ligne pour que le taux d'épargne personnelle (`psavert`) soit représenté par des tirets, et que la durée de chômage (`uempmed`) soit représentée par une ligne pleine. Par ailleurs, retirer le titre de la légende des types de lignes, afin que les légendes de couleur et de type de ligne soient fusionnées ;
    
8. Créer le tableaux de données `df_2`, une copie de `df`, dans lequel la variable `key` doit être un facteur dont les niveaux sont `uempmed` et `psavert` ;
    
9. Créer le vecteur \texttt{etiq} suivant : 

    `etiq <- c("psavert" = "Pers. Saving Rate",`
    `"uempmed" = "Median Duration of Unemployment (weeks)")`

    Ce vecteur contient des valeurs d'étiquettes pour la légende du graphique qu'il va falloir créer.
    
    Représenter sur un même graphique lévolution dans le temps du taux d'épargne personnelle et de la durée médiane du chômage en semaines, en s'appuyant sur les données contenues dans le tableau `df_2`. La courbe du taux d'épargne personnelle doit être composée de tirets et être de couleur `dodger blue` ; la courbe de la durée médiane du taux de chômage doit être une ligne rouge. La légende ne doit pas comporter de titre, et ses étiquettes doivent être modifiées pour que "Pers. Saving Rate" s'affiche à la place de "psavert", et pour que "Median Duration of Unemployment (weeks)" s'affiche à la place de "uempmed". Stocker le graphique dans un objet que l'on appellera `p_5` ;
    
    _Note : il s'agit de reprendre le code ayant servi à créer le graphique `p_4`, en modifiant légèrement les échelles de couleur et de ligne pour prendre en compte les étiquettes proposées dans le vecteur `etiq`._
    
10. Modifier `p_5` pour lui ajouter une couche permettant de déplacer la légende en bas du graphique (utiliser la fonction `theme()`) ;
    
11. Ajouter une couche au graphique `p_5` qui permet de définir un thème. Utiliser le thème minimal (`theme_minimal()). Que se passe-t-il pour la légende ? Repositionner la légende en dessous, et retirer les titres des axes ;
   
12. Sauvegarder le graphique `p_5` au format PDF en précisant une largeur de 12 et une hauteur de 8.

```


<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 3 : différentes représentations graphiques**

1. Charger le jeu de données `mpg` contenu dans le _package_ {`ggplot2`} en mémoire, puis consulter la page d'aide du jeu de données pour en prendre connaissance ;
    
2. Représenter à l'aide d'un nuage de points la relation entre la consommation sur autoroute des véhicules de l'échantillon (`hwy`) et la cylindrée de leur moteur (`displ`)
    
3. Reprendre le code du graphique précédent et modifier la forme des points pour les changer en symbole `+` ; modifier la couleur des `+` de manière à la faire dépendre du nombre de cylindres (`cyl`) ;
    
4. À présent, représenter par des boîtes à moustaches la distribution de la consommation sur autoroute des véhicules (`hwy`) pour chacune des valeurs possibles du nombre de cylindres (`cyl`) ;
    
5. Charger le jeu de données `economics` contenu dans le _package_ {`ggplot2`} en mémoire, puis consulter la page d'aide du jeu de données pour en prendre connaissance. Ensuite, ajouter au tableau (les créer) les variables `u_rate` et `e_rate`, respectivement le taux de chômage et le taux d'emploi (on définira le taux de chômage de manière très grossière ici : nombre de personnes non employées sur la population totale) ;
    
6. Représenter à l'aide de barres l'évolution dans le temps du taux de chômage, et remplir les barres avec la couleur rouge ;
    
7. Reprendre le code du graphique précédent et ajouter une couche permettant de modifier les limites de l'axe des abscisses pour afficher les valeurs uniquement sur la période "2012-01-01" à  "2015-01-01" (utiliser la fonction `coord_cartesian()`). Stocker le graphique dans un objet que l'on appellera `p` ;
    
8. Dans le tableau de données `economics`, sélectionner les variables `date`, `u_rate` et `e_rate`, puis utiliser la fonction `pivot_longer()` pour obtenir un tableau dans lequel chaque ligne correspond à la valeur d'une des variables (taux de chômage ou taux d'emploi) à une date donnée. Stocker le résultat dans un objet que l'on appellera `df_3` ;
    
9. Utiliser le tableau de données `df_3` pour représenter graphiquement à l'aide de barres les taux de chômage et taux d'emploi par mois sur la période "2012-01-01" à "2015-01-01". Sur le graphique, les barres représentant le taux de chômage et celles représentant le taux d'emploi devront être superposées.
  
    _Note : il s'agit de modifier légèrement le code ayant permis de réaliser le graphique `p`._

```



<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 4 : facettes**

1. Charger le _package_ {`WDI`} (l'installer si nécessaire), puis en utilisant la fonction `WDI()`, récupérer les données de PIB par tête (`NY.GDP.PCAP.PP.KD`, PPP, constant 2005 international \$) et de taux de chômage (`SL.UEM.TOTL.ZS`, total, % of total labor force) pour la France, l'Allemagne et le Royaume Uni, pour la période allant de 1990 à 2015. Ces données doivent être stockées dans un tableau que l'on appellera `df` ;
    
2. Transformer le tableau `df` afin que chaque ligne indique : l'état (`country`), l'année (`year`), le nom de la variable (`variable`) et la valeur (`valeur`) (utiliser la fonction `pivot_longer()`). Puis, modifier la colonne `variable` afin qu'elle soit de type `factor`, et que les étiquettes des niveaux `NY.GDP.PCAP.PP.KD` et \texttt{SL.UEM.TOTL.ZS} deviennent `GDP` et `Unemployment` respectivement ;
    
3. Représenter graphiquement l'évolution du PIB et du taux de chômage pour les trois pays. Utiliser la fonction `facet_wrap()` afin de regrouper les variables par type : les observations des valeurs du PIB d'un côté du "tableau" de graphiques, et celles du taux de chômage de l'autre. Utiliser une représentation en ligne, en faisant dépendre la couleur du pays ;
    
4. Reprendre le code du graphique précédent en le modifiant légèrement afin de libérer les axes des ordonnées ;
    
5. Modifier les arguments esthétiques du graphique afin de faire dépendre le type de ligne des pays de la manière suivante : des points pour la France, des tirets pour l'Allemagne, des tirets longs pour le Royaume Uni. Définir l'épaisseur des lignes à $1.5$ ;
    
6. Modifier légèrement le code ayant permis de réaliser le graphique de la question précédente pour que la direction ne soit non plus horizontale (par défaut), mais verticale (argument `dir`, ou à défaut, `ncol` dans ce cas précis) ;
    
7. En utilisant la fonction `facet_wrap()`, créer une grille de graphiques, de sorte que chaque pannel représente l'évolution d'une seule série pour un pays donné ;
    
8. À présent, utiliser la fonction `facet_grid()` pour créer une grille de graphiques dans laquelle les lignes correspondent aux pays et les colonnes aux variables. Prendre soin de libérer les échelles ;
    
9. Reprendre la question précédente en faisant cette fois une girlle dans laquelle les lignes correspondent aux variables et les colonnes aux pays.

```




  
  


<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 5 : annotations**

1. En utilisant la fonction `WDI()` du _package_ `WDI`, récupérer les séries de 2010 du PIB par tête (`NY.GDP.PCAP.PP.KD`, PPP, constant 2005 international $) et de l'espérance de vie à la naissance (`SP.DYN.LE00.IN`, total, years) pour tous les pays. Les données seront stockées dans un tableau que l'on nommera `df` ;
    
2. Représenter par un nuage de points l'espérance de vie à la naissance en fonction du PIB par tête. Retirer les titres des axes, et ajouter le titre suivant (sur deux lignes) : "Life Expectancy at birth (years) VS  Real GDP per Capita (PPP, contant 2005 international $" ;
    
3. Ajouter une courbe de tendance obtenue par lissage Loess (en utilisant une fonction du _package_ {`ggplot2`}) ;
    
4. Modifier le tableau `df` pour lui ajouter la variable `drapeau` qui prendra la valeur `TRUE` si l'état de l'observation est soit `France`, soit `Luxembourg`, et `FAUX` sinon ;
    
5. Modifier légèrement le code ayant permis de réaliser le précédent graphique, pour faire dépendre la couleur des points de la variable drapeau (rouge pour `TRUE` et noir pour `FALSE`) ;
    
6. Créer un tableau de données que l'on appellera `df_fleche` qui contient les observations du tableau `df` pour la France et le Luxembourg uniquement ;
    
7. Reprendre le code du graphique précédent pour le modifier de façon à ajouter deux flèches : l'une montrant le points de la France et l'autre du Luxembourg. Le nom du pays devra être inscrit à l'origine des deux flèches (utiliser la fonction `annotate()` et se servir du tableau de données `df_fleche`).

```




  


<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 6 : annotations**

1. À l'aide de la fonction `WDI` du _package_ {`WDI`}, récupérer la série de l'inflation (`FP.CPI.TOTL.ZG`, consumer prices, annual %) en France sur la période 1960--2015, et stocker ces données dans un tableau que l'on appellera `inflation_fr` ;
    
2. Représenter par une ligne l'évolution du taux annuel d'inflation en France sur la période 1960--2015. Retirer les titres d'axes et ajouter le titre suivant : "Inflation in France (annual %)" ;

3. Soient les deux vecteurs suivants, qui définissent les dates de début et fin de la période inflationniste et celle de grande modération :

```

```{r, eval=FALSE}
per_1 = c(1970, 1976) # Periode inflationniste
per_2 = c(1976, 1991) # Periode de grande moderation
```

```{block2, type='exframe', echo=TRUE}

3. Reprendre le code du graphique précédent et ajouter deux rectangles : un premier, rouge, pour mettre en valeur la période inflationniste et un second, bleu, mettant en valeur la période de grande modération. Modifier l'argument de transparence pour le fixer à 0.2 ;
    
4. Ajouter au graphique précédent des lignes grises verticales en tirets pour les années 1973, 1979 et 2008. Modifier également les `breaks` de l'échelle des abscisses à l'aide de la fonction `pretty_breaks()` du _package_ scales.

```




<!-- % ======== % -->
<!-- % EXERCICE % -->
<!-- % ======== % -->

```{block2, type='exframe', echo=TRUE}
**Exercice 7 : carte simple**

1. À l'aide de la fonction `WDI()` du _package_ {`WDI`}, récupérer la série fournie par la Banque Mondiale du PIB par tête (`NY.GDP.PCAP.PP.KD`, PPP, constant 2005 international $) pour tous les pays disponibles pour l'année 2010, et stocker ces données dans un tableau que l'on appellera `gdp_capita` ;
   
2. Dans le tableau `gdp_capita`, modifier la valeur de la variable `country` pour l'observation de la Slovaquie, pour qu'elle vaille `Slovakia` au lieu de `Slovak Republic` ;
    
3. Filtrer les observations du tableau `gdp_capita` pour ne conserver que les observations des pays membres de l'Union Européenne dont les noms sont contenus dans le vecteur `membres_ue`. Stocker le résultat dans un tableau que l'on nommera `gdp_capita_eu` ;

```

```{r, eval=FALSE}
membres_ue <-c("Austria", "Belgium", "Bulgaria", "Cyprus", "Croatia",
              "Czech Republic", "Denmark", "Estonia", "Finland", "France",
              "Germany", "Greece", "Hungary", "Ireland", "Italy", "Latvia",
              "Lithuania", "Luxembourg", "Malta", "Netherlands", "Poland",
              "Portugal", "Romania", "Slovakia", "Slovenia", "Spain",
              "Sweden", "United Kingdom")
```


```{block2, type='exframe', echo=TRUE}
4. Utiliser le _package_ {`rworldmap`} pour récupérer les données nécessaires à la réalisation d'une carte du monde ;
    
5. Afficher une carte du monde à l'aide des fonctions contenues dans le _package_ {`ggplot2`} ;
    
6. Modifier les échelles des axes pour faire figurer les méridiens de $-60$ à $60$ par pas de 30 et les parallèles de $-180$ à $180$ par pas de 45. Modifier également la projection cartographique pour choisir la projection orthographique, à l'aide de la fonction `coord_map()` ;
    
7. Joindre les informations contenues dans le tableau `gdp_capita_eu` au tableau contenant les données permettant la réalisation des cartes ;
    
8. Réaliser une carte choroplèthe reflétant pour chaque pays membre de l'Union Européenne la valeur du PIB par tête de 2012 ;
    
9. Modifier les couleurs de l'échelle continue de la carte précédente, pour que les faibles valeurs du PIB par tête soient représentées en jaune, et les valeurs les plus hautes en rouge ;
    
10. Modifier les ruptures de l'échelle de couleur pour qu'elles aillent de $10000$ à $100000$ ; modifier également l'étiquette de ces ruptures de sorte que $35000$ soit affiché comme $35$k, $60000$ comme $60$k, etc. Enfin, ajouter un titre au graphique et retirer les titres d'axes.

```


# Régressions linéaires

## Rappels

On souhaite étudier la liaison entre une variable \(y\) et une ou plusieurs variables \(x_1, x_2, \ldots, x_m\). La variable \(y\) est appelée _variable à expliquer_, ou _réponse_ (ou encore _target_) et les variables \(x_j\), \(j = 1, 2, \ldots, m\) sont appelées variables explicatives (_features_). On suppose que la relation entre la variable à expliquer et les variables explicatives est de la forme \(y = f(x_1, x_2, \ldots, x_m)\), avec \(m\) le nombre de variables explicatives. On émet l'hypothèse que la réponse est linéairement indépendante des variables \(x_j\), avec \(j = 1, \ldots, m\).

Il s'agit d'estimer les coefficients \(\beta_j\) de l'équation à \(m\) variables explicatives \(x_j\), avec \(j=1,2,\cdots, m\), \(\beta_0\) étant la constante, et \(\varepsilon\) un terme d'erreur supposé normal :
\begin{equation}
\boldsymbol y = \beta_0 + \beta_1 \boldsymbol x_1 + \beta_2 \boldsymbol x_2 + \cdots + \beta_j \boldsymbol x_j + \cdots + \beta_m \boldsymbol x_m  + \boldsymbol \varepsilon.\label{eq:chap_5_reg_mult}
\end{equation}

Soit, en termes matriciels
\begin{equation}
  \boldsymbol y = \boldsymbol X \boldsymbol \beta + \boldsymbol \varepsilon,\label{eq:chap_5_reg_mult_mat}
\end{equation}
\begin{align*}
  \textrm{où } \boldsymbol y = \begin{bmatrix}
		y_1 \\ y_2 \\ \vdots \\ y_n
	\end{bmatrix}, \, \boldsymbol X = \begin{bmatrix}
	  1 & x_{11} & x_{12} & \cdots & x_{1m} \\
	  1 & x_{21} & x_{22} & \cdots & x_{2m} \\
	  1 & \vdots  & \vdots  & \ddots & \vdots \\
	  1 & x_{n1} & x_{n2} & \cdots & x_{nm}
 \end{bmatrix}, \, \boldsymbol \beta =  \begin{bmatrix}
 	\beta_0\\
 	\beta_1\\
  \beta_2\\
 	\vdots\\
 	\beta_m
 \end{bmatrix} \textrm{ et } \boldsymbol \varepsilon = \begin{bmatrix}
   \varepsilon_1\\
   \varepsilon_2\\
 	\vdots\\
 	\varepsilon_m
 \end{bmatrix}.
\end{align*}

Les coefficients \(\beta_j\) sont inconnus et estimés par \(\hat{\beta}_j\) tels que :
\begin{align*}
  \begin{cases}
  	\hat{y_1} &  = \hat{\beta}_{0} +\hat{\beta}_1 x_{11} + \hat{\beta}_2 x_{12} + \cdots + \hat{\beta}_j x_{1j} + \hat{\beta}_m x_{1m}\\
		\hat{y_2} &  = \hat{\beta}_{0} + \hat{\beta}_1 x_{21} + \hat{\beta}_2 x_{22} + \cdots + \hat{\beta}_j x_{2j} + \hat{\beta}_m x_{2m}\\
		\vdots & = \vdots\\
		\hat{y_n} &  = \hat{\beta}_{0} + \hat{\beta}_1 x_{n1} + \hat{\beta}_2 x_{n2} + \cdots + \hat{\beta}_j x_{nj} + \hat{\beta}_m x_{nm}\\
	\end{cases}.
\end{align*}

En termes matriciels, cela donne :
\begin{equation}
  \hat{\boldsymbol y} = \boldsymbol X \hat{\boldsymbol \beta},\label{eq:chap_5_reg_mult_mat_1}
\end{equation}
\begin{align*}
	\textrm{où } \hat{\boldsymbol y} = \begin{bmatrix}
		\hat{y}_1 \\ \hat{y}_2 \\ \vdots \\ \hat{y}_n
	\end{bmatrix}, \, \boldsymbol X = \begin{bmatrix}
	  1 & x_{11} & x_{12} & \cdots & x_{1m} \\
	  1 & x_{21} & x_{22} & \cdots & x_{2m} \\
	  1 & \vdots  & \vdots  & \ddots & \vdots \\
	  1 & x_{n1} & x_{n2} & \cdots & x_{nm}
 \end{bmatrix}, \textrm{ et } \hat{\boldsymbol \beta} =  \begin{bmatrix}
  \hat{\beta}_0\\
 	\hat{\beta}_1\\
 	\hat{\beta}_2\\
 	\vdots\\
 	\hat{\beta}_m
 \end{bmatrix}.
\end{align*}

Avec la méthode des moindres carrés, l'objectif est de trouver \(\hat{\boldsymbol\beta}\) tels que la somme des carrés des résidus soit minimale. La somme des carrés des résidus est définie par :
\[\mid \mid \boldsymbol y - \boldsymbol X \boldsymbol \beta \mid \mid^2 = \sum_{i=1}^{n} (y_i - x_i \beta)^2.\]

La condition du premier ordre donne^[On utilise les propriétés suivantes : \(\frac{\partial \boldsymbol x^t \boldsymbol A}{\partial \boldsymbol x} = \boldsymbol A^t\), \(\frac{\partial \boldsymbol A \boldsymbol x}{\partial \boldsymbol x} = \boldsymbol A\) et \(\frac{\partial a \boldsymbol \varepsilon}{\partial \boldsymbol x} = a \frac{\partial u}{\partial \boldsymbol x}\), avec \(u = u(\boldsymbol x)\).] :
\begin{empheq}{align}
& \boldsymbol X^t \boldsymbol X\hat{\boldsymbol \beta} - 2 \boldsymbol X^t \boldsymbol X \hat{\boldsymbol \beta} - 2 \boldsymbol X^t \boldsymbol y = 0\notag\\
  \Leftrightarrow \quad & \boldsymbol X^t \boldsymbol X \hat{\boldsymbol\beta} = \boldsymbol X^t \boldsymbol y\notag\\
	\Leftrightarrow \quad & \hat{\boldsymbol\beta} = (\boldsymbol X^t \boldsymbol X)^{-1} \boldsymbol X^t \boldsymbol y.\label{eq:chap_5_betachap}
\end{empheq}

## Données de l'exemple {#regressions_donnees}

Nous allons nous appuyer sur des données de naissances à Philadelphie, en 1990 [@Elo_2001_Racial]. L'échantillon concerne \(5\%\) des naissances ayant eu lieu dans cette ville en 1990, ce qui représente \(1115\) observations. Chaque enregistrement renseigne sur :

- `grams` : masse à la naissance (grammes) ;
- `gestate` : temps de gestation (semaines) ;
- `educ` : nombre d'années d'éducation de la mère (0--17);
- `black` : variable indicatrice de la couleur de peau de la mère (1 si oui, 0 sinon);
- `smoke`indique si la mère a fumé pendant la grossesse (1 si oui, 0 sinon).



Attention, ce qui est proposé dans cette section ne constitue pas un fil d'Ariane pour réaliser une analyse sur des données. L'idée est de montrer au lecteur les fonctions principales, pour que ce premier puisse réaliser par lui-même ses analyses. D'excellentes références proposent d'aller plus loin au sujet de la régression [@Matzner_2007_Regression, @Lafaye_2011_Logiciel, @Dalgaard_2008_Introductory].

Une très rapide visualisation des données est l'occasion d'introduire ici la fonction `grid.arrange()` du _package_ {`gridExtra`}, qui permet de positionner des graphiques réalisés avec {`ggplot2`} sur une grille.

```{r regressions_estimation_graphiques, message = FALSE, fig.width = 3, fig.height = 2.5, fig.align = "center", tidy.opts=list(width.cutoff=70), fig.show='hold'}

url <- "http://data.princeton.edu/wws509/datasets/phbirths.dat"
births <- read.table(url, header = TRUE)
head(births)

# Un aperçu des données
summary(births)

# Les corrélations
round(cor(births), 2)

# Un aperçu graphique des données
library(ggplot2)
qplot(data = births, grams, fill = I("dodger blue"))
qplot(data = births, gestate, fill = I("dodger blue"))
qplot(data = births, educ, fill = I("dodger blue"))
qplot(data = births, black, fill = I("dodger blue"))
qplot(data = births, smoke, fill = I("dodger blue"))
```


Si on souhaite regarder les différentes valeurs que prennent chaque variable pour chaque observation, on peut utiliser la petite astuce consistant à utiliser la fonction `seq_along()`.

```{r regressions_estimation_graphiques_2, message = FALSE, fig.width = 7, fig.height = 2.5, fig.align = "center", tidy.opts=list(width.cutoff=70)}

# Pour avoir des nuages de points
p_1 <- qplot(data = births, seq_along(grams), grams) + xlab("Index")
p_2 <- qplot(data = births, seq_along(gestate), gestate) + xlab("Index")
p_3 <- qplot(data = births, seq_along(educ), educ) + xlab("Index")

library(gridExtra)
grid.arrange(p_1, p_2, p_3, ncol=3)

```


Pour avoir une idée de la relation possible entre la réponse et chaque variable explicative, il est intéressant de tracer les graphiques suivants.

```{r regressions_estimation_graphiques_3, message = FALSE, fig.width = 7, fig.height = 3, fig.align = "center", tidy.opts=list(width.cutoff=70)}

p_1 <- qplot(data = births, grams, gestate,
             geom = c("point", "smooth"))
p_2 <- qplot(data = births, educ, gestate, 
             geom = c("point", "smooth"))
p_3 <- qplot(data = births, black, gestate, position = "jitter")
p_4 <- qplot(data = births, smoke, gestate, position = "jitter")
grid.arrange(p_1, p_2, p_3, p_4, ncol=2)

```


## Estimation des paramètres {#}


La fonction permettant de réaliser une régression linéaire avec `R` se nomme `lm()`. Il est nécessaire de fournir une formule à l'arguemnt `formula`. L'argument `data` indique le tableau de données (la liste, ou un objet convertible en `data.frame`) dans lequel les variables mentionnées dans la formule se trouvent.

```{r regressions_estimation_lm_1}
reg <- lm(grams ~ gestate, data = births)
reg
```


On lit dans la sortie que le coefficient de la constante vaut `r as.vector(reg$coef["(Intercept)"])` et que le coefficient associé à la variable `gestate` vaut `r as.vector(reg$coef["gestate"])`.

Comme on peut le voir sur les graphiques proposés précédemment, la relation entre la masse du nouveau né et le temps de gestation semble plus quadratique que linéaire. Pour introduire le carré de la durée de gestation, on utilise la fonction `I()`.

```{r regressions_estimation_lm_1_2}
reg_2 <- lm(grams ~ gestate + I(gestate^2), data = births)
reg_2
```

## Lecture des sorties {#regressions_lecture}


Une des fonctions les plus utiles autour de la régression linéaire avec `R`~est `summary()`. Elle affiche plusieurs éléments :

- `Call` : la fomule du modèle ;
- `Residuals` : des statistiques descriptives des résidus ;
- `Coefficients` : un tableau à deux entrées où les lignes correspondent aux coefficients associés aux variables explicatives, et les colonnes, dans l'ordre, à l'estimation du coefficient, l'écart-type estimé, la valeur du test de Student de nullité statistique du coefficient et enfin la _p-value_ associé à ce test, suivie d'un symbole pour lire rapidement la significativité ;
- `Signif. codes` : les significations des symboles de niveau de significativité ;
- `Residual standard error` : estimation de l'écart-type de l'aléa et degré de liberté ;
- `Multiple R-squared` : coefficient de détermination ;
- `Adjusted R-squared` : coefficient de détermination ajusté ;
- `F-statistic` : valeur de la statistique de Fisher du test de significativité globale, ainsi que les degrés de liberté et la _p-value_ associée au test.

```{r regressions_estimation_lm_1_summary}
summary(reg)
```


## Extractions {#regressions_extractions}



L'objet retourné par la régression contient plusieurs éléments auxquels il est possible d'accéder. Voici les principaux

- `coefficients` un vecteur de coefficients (nommé) ;
- `residuals`  les résidus ;
- `fitted.values` : les valeurs estimées ;
- `df.residual` : nombre de degrés de liberté.


```{r regressions_estimation_lm_1_summary_2, message = FALSE, fig.width = 3, fig.height = 2.5, fig.align = "center", tidy.opts=list(width.cutoff=70), fig.show='hold'}

names(reg)
reg$coefficients

# Résidus
qplot(seq_along(reg$residuals), reg$residuals) +
  xlab("") + ylab("Résidus")

# Ordonnons les résidus en fonction de la masse des nouveaux-nés
ind <- order(births$grams)
qplot(seq_along(reg$residuals[ind]), reg$residuals[ind]) +
  xlab("") + ylab("Résidus")

```



Certaines fonctions permettent également d'accéder aux éléments de la régression, comme `residuals()` (ou `resid()`), `fitted()` ou encore `coefficients()` (ou `coef()`) qui retournent les résidus, les valeurs estimées et les coefficients de la régression respectivement. Ces fonctions prennent en argument l'objet retourné par `lm()`. Voici un exemple d'utilisation de `residuals()`, pour tracer la droite de Henry (QQ-plot).

```{r regressions_estimation_lm_1_qqplot, fig.width = 7, fig.height = 2.5, fig.align = "center", tidy.opts=list(width.cutoff=70)}

qqplot <- function(y, distribution=qnorm, title = "Droite de Henry",
                   xlab = "Quantiles théoriques",
                   ylab = "Résidus studentisés") {
  if(class(y) == "lm"){
    # Résidus
    r <- residuals(y)
    # Résidus studentisés
    y <- r / sqrt(deviance(y) / df.residual(y))
  }
  x <- distribution(ppoints(y))
  df <- data.frame(x = x, y = sort(y))
  ggplot(df, aes(x = x, y = y)) +
    geom_point() +
    geom_abline(intercept = 0, slope = 1, col = "red") +
    ggtitle(title) +
    xlab(xlab) + ylab(ylab)
}

qqplot(reg)
```

## Variables catégorielles {#regressions_facteurs}


En `R`, les variables catégorielles sont de mode `factor`. Si on souhaite intégrer une variable catégorielle à un modèle de régression linéaire, il y a deux méthodes. La première, est de définir le type de la variable dans le tableau qui contient les données (`tibble`, `data.frame`, ...). La seconde est d'utiliser la variable `factor()` dans la formule, lors de l'appel de la régression. La première méthode possède l'avantage de la lisibilité, surtout lorsque l'on souhaite définir la valeur de référence.


Lorsque la variable est de type `logical` ou `character`, la conversion est faite automatiquement par R. Le choix de la classe de référence est aussi effectué automatiquement.

```{r regressions_facteurs, tidy.opts=list(width.cutoff=70)}
class(births$smoke)
summary(reg_3 <- 
          lm(grams ~ gestate + smoke + black,
             data = births))
# Equivalent de 
summary(reg_3 <- 
          lm(grams ~ gestate + factor(smoke) + factor(black),
             data = births))
```



Pour changer la valeur de référence, on peut utiliser la fonction `fct_relevel()` de `{forcast}`, ou bien préciser manuellement les niveaux au moment de la créqtion du facteur (le premier niveau énoné devenant la modalité de référence).


```{r regressions_facteurs_2, tidy.opts=list(width.cutoff=70)}
births <- 
  births %>%
  mutate(smoke = factor(smoke))

levels(births$smoke)

births <- 
  births %>% 
  mutate(smoke = fct_relevel(smoke, "TRUE"))

# Au moment de la création
births <- 
  births %>% 
  mutate(black = factor(black, levels = c("TRUE", "FALSE"),
                        labels = c("Black", "Not Black")))

reg_3 <- lm(grams ~ gestate + smoke + black, data = births)
summary(reg_3)

```


Une alternative à `fct_relevel()` est la fonction `relevel()`:
```{r}
exemple <- relevel(births$smoke, ref = "FALSE")
levels(exemple)
```

## Tests de nullité des coefficients et intervalles de confiance {#regressions_tests}


Soit le problème de test :
\begin{align*}
  \begin{cases}
		H_0 : \beta_i = 0\\
		H_1 : \beta_i \ne 0
	\end{cases}, i = 1, 2, \ldots, m.
\end{align*}

La statistique de test est la suivante : 
\begin{align*}
  T = \frac{\hat{\beta}_i - \beta_{i,H_0}}{\hat{\sigma}_{\hat{\beta}_i}} \sim \mathcal{S}t(n-m-1,)
\end{align*}
avec \(\beta_{i,H_0}\) la valeur de \(\beta_j\) sous l'hypothèse nulle, \(\hat{\sigma}_{\hat{\beta}_i}\) l'estimation de l'écart-type de l'estimation du paramètre \(\beta_i\).

Pour effectuer ce test bilatéral, on peut lire dans la table de la loi de Student deux fractiles tels que :
\begin{align*}
  	\mathbb{P}\left( -t_{1-\alpha/2} < \frac{\hat{\beta}_i - \alpha_{i,H_0}}{\hat{\sigma}_{\hat{\beta}_i}} < t_{1-\alpha/2} \right) = 1 - \alpha.
\end{align*}
avec \(\alpha\) le risque de première espèce.

à partir des observations, il est possible de calculer :
\begin{align*}
  t_{i,\textrm{obs.}} = \frac{\hat{\beta}_i}{\hat{\sigma}_{\hat{\beta}_i}}.
\end{align*}

La règle de décision est la suivante : 

- si \(t_{i,\textrm{obs.}} \in [-t_{1-\alpha/2}, t_{1-\alpha/2}]\), nous somme dans la région d'acceptation, on ne rejette donc pas \(H_0\) au seuil de \(\alpha\), et on considère alors que \(\alpha_i\) n'est pas statistiquement différent de zéro ; 
- si en revanche \(t_{i,\textrm{obs.}} \notin [-t_{1-\alpha/2}, t_{1-\alpha/2}]\), nous sommes dans la région critique et cette fois on rejette l'hypothèse nulle en faveur de l'hypothèse alternative. On considère alors qu'avec un risque de première espèce de \(\alpha\), on a \(\alpha_i \ne 0\).


Sous `R`, comme vu dans la Section\ \@ref(regressions_lecture), les tests de nullité de chaque coefficients sont effectués lors de l'appel de la fonction `summary()` sur l'objet retourné par la fonction `lm()`. Pour obtenir les intervalles de confiance, on peut s'amuser à extraire soi-même les coefficients et les écarts-types associés, pour faire le calcul à la main, ou bien avoir recours à la fonction `confint()`. Il suffit de lui fournir l'objet retourné par la fonction `lm()`, et de préciser éventuellement un niveau (le niveau par défaut étant \(95\%\)).

```{r regressions_tests}
# Intervalles de confiance à 95% pour les paramètres
confint(reg_3)
# Intervalles de confiance à 90% pour les paramètres
confint(reg_3, level = 0.95)
```


Voici une fonction qui permet d'afficher les intervalles de confiance pour chaque coefficient.


```{r regressions_tests_coef_bar, tidy.opts=list(width.cutoff=70), fig.width = 7, fig.height = 3, fig.align = "center"}

#' @param x : objet issu de lm()
confint_bar <- function(x){
  df <- data.frame(confint(x))
  colnames(df) <- list("b_inf", "b_sup")
  df$variable <- rownames(df)
  rownames(df) <- NULL
  df$coef <- coef(x)
  
  ggplot(df, aes(x = factor(1), y = coef)) +
    geom_errorbar(aes(ymin = b_inf, ymax = b_sup)) +
    geom_point(col = "dodger blue", size = 3) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    facet_wrap(~variable, scales = "free_y") +
    xlab("") +
    theme(axis.ticks = element_blank(),
          axis.text.x = element_blank())
  
}

```

On peut alors appliquer cette fonction au résultat d'une régression linéaire :
```{r regressions_tests_coef_bar_plot, tidy.opts=list(width.cutoff=70), fig.width = 7, fig.height = 3, fig.align = "center"}
confint_bar(reg_3)
```


## Prévisions {#regressions_previsions}


Une fois que la fonction `lm()`^[voir l'aide de la fonction `?predict.lm`] a estimé les paramètres du modèle, il est possible de réutiliser les estimations pour effectuer des prévisions, avec des nouvelles données. On considère un nouvel enregistrement, \(\boldsymbol{x}^\top_{n+1} = \begin{bmatrix}
  	x_{n+1, 1} & x_{n+1, 2} & \ldots & x_{n+1, m}
	\end{bmatrix}\), et l'objectif est de prévoir la valeur de \(y_{n+1}\), en utilisant la relation initiale :
\begin{equation}
y_{n+1} = \beta_0 + \beta_1 \boldsymbol x_{n+1,1} + \beta_2 \boldsymbol x_{n+1,2} + \cdots + \beta_m \boldsymbol x_{n+1,m} + \boldsymbol \varepsilon_{n+1}.\label{eq:regressions_previsions},
\end{equation}
où \(\mathbb{E}[\varepsilon_{n+1}] = 0\), \(\mathbb{V}(\varepsilon_{n+1}) = \sigma^2\) et \(\mathbb{C}ov(\varepsilon_{n+1}, \varepsilon_{i}) = 0\), \(i = 1, 2, \ldots, n\).\\

La valeur prévue, \(\hat y_{n+1}^p\) s'appuie sur les coefficients estimés par le modèle :
\begin{equation}
\hat y_{n+1}^p = \hat\beta_0 + \hat\beta_1 \boldsymbol x_{n+1,1} + \hat\beta_2 \boldsymbol x_{n+1,2} + \cdots + \hat\beta_m \boldsymbol x_{n+1,m}.\label{eq:regressions_previsions_2}
\end{equation}
On note \(z_{n+1} = y_{n+1} - \hat y_{n+1}^p\) l'erreur de prévision. On a :
\begin{align}
  \begin{cases}
  \mathbb{E}[z_{n+1}] = 0\\
  \mathbb{V}(z_{n+1}) = \sigma^2 \times \left( 1 + \boldsymbol {x}^\top_{n+1} (\boldsymbol X^\top \boldsymbol X)^{-1} \boldsymbol x_{n+1}  \right)
  \end{cases}
\end{align}

Comme on émet l'hypothèse que la distribution des \(\varepsilon_i\) est normale, la distribution des \(y_{i}\) et \(\hat y_{i}^p\) l'est aussi. De fait, on a :
\begin{align}
z_i^p \sim \mathcal{N}\left(0,\sqrt{\mathbb{V}(z_i^p)}\right).
\end{align}

On peut estimer la variance inconnue \(\sigma^2_\varepsilon\) par son estimation \(\hat{\sigma}^2_\varepsilon\).

Dès lors, on a :
\begin{align}
\frac{z_i^p - \mathbb{E}(z_i^p)}{\hat{\sigma}_{\varepsilon}} \sim \mathcal{S}t(n-2).
\end{align}

Il est alors possible de construire un intervalle de confiance au seuil de \(\alpha\) pour \(y_i^p\), soit :
\begin{align}
\widehat{\textrm{I.C.}_{y_{n+1}}(1-\alpha)} = \left[ \hat{y}_{n+1}^p \pm t_{1-\alpha/2} \cdot \hat{\sigma}_{z_{n+1}^p} \right],
\end{align}
où \(t_{1-\alpha/2}\) est la valeur du fractile lue dans la table pour \(\alpha\) et \(\gamma = n-2\) degrés de liberté.\\

`R` propose la fonction `predict()` pour calculer cet intervalle de prévision. L'objet retourné par la fonction `lm()` est passé en argument à la fonction `predict()`. Si aucun autre argument n'est fourni, l'évaluation retourne les valeurs estimées pour la variable à expliquer.

```{r regressions_previsions}
all.equal(predict(reg_3), fitted(reg_3))
```


Si en revanche, on ajoute de nouvelles données, en les passant à l'arguemnt `newdata`, alors le modèle estimé est utilisé à partir de ces nouvelles données pour fournir des prévisions. Il faut toutefois faire attention à ce que les noms des variables du nouveau tableau de données soient identiques à celui passé dans la fonction`lm()`.

```{r regressions_previsions_2, tidy.opts=list(width.cutoff=70)}
donnees_supl <- 
  tibble(black = factor(c(TRUE, FALSE),
                        levels = c(TRUE, FALSE),
                        labels = c("Black", "Not Black")),
         educ = c(10,5),
         smoke = factor(c(FALSE, FALSE)),
         gestate = c(39, 43))
predict(reg_3, newdata = donnees_supl)
```


Par défaut, les intervalles de prévision de sont pas donnés, il faut forcer leur calcul en donnant la valeur `"prediction"` à l'arguemnt `interval`. L'intervalle de confiance pour la valeur prévue est donné pour un risque de première espèce de \(5\%\). Pour un risque de première espèce différent, il faut changer la valeur de l'argument `level`.

```{r regressions_previsions_ic, tidy.opts=list(width.cutoff=70)}
# I.C. à 95% pour la prévision
predict(reg_3, newdata = donnees_supl, interval = "prediction")
# I.C. à 90% pour la prévision
predict(reg_3, newdata = donnees_supl, interval = "prediction", level = 0.9)
```


On peut demander d'afficher les valeurs des écarts-types, avec l'argument `se.fit`.
```{r regressions_previsions_ic_2, tidy.opts=list(width.cutoff=70)}
predict(reg_3, newdata = donnees_supl, interval = "prediction", se.fit = TRUE)
```

## Exercices sur la régression


```{block2, type='exframe', echo=TRUE}
**Exercice 1 : exploration rapide des données**

Cet exercice s'appuie sur un jeu de données de consommation de carburant de 392 véhicules. Il provient de la bibliothèque StatLib, maintenue à la Carnegie Mellon University^[http://archive.ics.uci.edu/ml/datasets/Auto+MPG].

1. Charger le jeu de données `Auto` contenu dans le _package_ `{ISLR}`, puis regarder sa page d'aide ;
2. Afficher un résumé des différentes variables ;
3. En utilisant la fonction `stargazer()` contenue dans le _package_ du même nom, aficher dans la console un tableau de statistiques descriptives en sortie texte ASCII. Prendre soin de limiter à deux le nombre de chiffres des décimales ;
4. Exporter ce tableau dans un fichier `HTML`, en prenant soin d'ajouter le titre suivant : "Statistiques descriptives". De plus, changer le séparateur des décimales en une virgule au lieu d'un point ;
5. Représenter par un nuage de points la relation entre les variables de puissance (`horsepower`) et de consommation (`mpg`), puis sur un autre graphique, la relation entre la masse du véhicule (`weight`) et sa consommation ;
6. Reprendre le code du graphique représentant la consommation en fonction de la masse du véhicule, et faire dépendre la couleur des points du nombre de cylindres (le nombre de cylindres sera considéré comme une variable catégorielle). Puis, ajouter des courbes de tendance pour chaque catégorie de cylindres à l'aide de la fonction `stat_smooth()`. Ces courbes de tendance devront être estimées à l'aide d'une régression linéaire.
7. Afficher un tableau des corrélations entre chaque variables numériques ;
8. En utilisant la fonction `corrplot.mixed()` du _package_ `{corrplot}`, réaliser une visualitation graphique de la matrice de corrélation.

```

```{block2, type='exframe', echo=TRUE}
**Exercice 2 : régression linéaire**

Cet exercice s'appuie sur le même jeu de données que le précédent.

1. Préparer deux tableaux de données : l'un comprenant \(80\%\) des observations, et le second les \(20\%\) restantes. Les observations à conserver dans le tableau contenant \(80\%\) des observations doivent être tirées au hasard ;
2. En prenant comme jeu de données la base avec \(80\%\) des observations, régresser la consommation (`mpg`) sur la puissance (`horsepower`), la masse (`weight`) et l'année de mise en circulation (`year`), en faisant appel à la fonction `lm()`;
3. Afficher un résumé de l'estimation à l'aide de la fonction `summary`, puis extraire uniquement le tableau des coefficients ;
4. Observer les graphiques retournés lorsque la fonction `plot()` est appliquée au résultat de l'estimation ;
5. Créer un tableau de données contenant les résidus de la régression, ainsi qu'une colonne indiquant le numéro des lignes de chaque observation (que l'on peut appeler `index` par exemple) ;
6. Tracer les résidus à l'aide d'un nuage de points (les valeurs de la variable `index` seront représentées en abscisses). Puis, changer la représentation géométrique pour afficher un histogramme des résidus ;
7. Construire un intervalle de confiance à \(95\%\) pour chacun des coefficients de la régression. Pour un paramètre \(\alpha\), l'intervalle de confiance est donné par :
  \[\widehat{\textrm{I.C.}_\alpha(1-p)} = \left[ \hat{\alpha} \pm t_{p/2, n-m-1} \times \hat{\sigma}_{\hat{\alpha}}\right],\]
  avec \(p\) le risque associé au test, \(n\) le nombre d'observations, \(m\) le nombre de variables explicatives et \(t_{p/2, n-m-1}\) le quantile d'ordre \(p/2\) de la Student à \(n-m-1\) degrés de liberté.

   Pour réaliser les intervalles de confiance, procéder comme suit :

    - récupérer le tableau de coefficients issu du résumé de l'estimation, et le stocker dans un objet de type `data.frame` que l'on appellera `coeffs` ;
    - récupérer ensuite le nombre de degrés de libertés associés au test de nullité d'un coefficient ;
    - ajouter dans le tableau `coeffs` les variables `b_inf` et `b_sup`, qui correspondent respectivement aux bornes inférieures et supérieures de chaque intervalle.
    - Enfin, comparer les résultats obtenus avec ceux issus de l'application de la fonction `confint()` à l'objet de la régression ;
8. Exporter les résultats de la régression dans un fichier `html`, en s'appuyant sur la fonction `stargazer()` ;
9. En utilisant le modèle estimé et les données contenues dans la base contenant uniquement \(20\%\) des observations, effectuer des prévisions sur la consommation des véhicules et les comparer aux valeurs réelles ;


```


# Expressions régulières {#regex}


La Section\ \@ref(manip-strings-regex) montre des exemples simples de recherches de chaînes de caractères. Celle-ci s'attarde à présenter un moyen de faire des recherches plus avancées, à l'aide de ce que l'on appelle les *expressions régulières* (ou _regular expressions_, abrégé par _regex_), qui sont des séquences de caractères formant un motif de recherche (ou _search pattern_).


Avant d'aller plus loin, il convient de rappeler au lecteur ou à la lectrice l'existence de l'aide sous `R`. La page réservée aux `regex`, accessible en évaluant la commande `?regex` (_package_ `base`), est un bon aide mémoire. Par ailleurs, le cours intitulé "_Les expressions régulières_" sur _OpenClassrooms_ est un bon support^[http://fr.openclassrooms.com/informatique/cours/concevez-votre-site-web-avec-php-et-mysql/les-expressions-regulieres-partie-1-2]. Cependant, `R` possède quelques terminologiques qui lui sont propres, et qui diffèrent légèrement du cours proposé sur _OpenClassrooms_.




## Les recherches basiques {#manip_regex_structure}

Les fonctions qui emploient les *regex* en R attendent au minimum deux arguments :

- un premier pour indiquer la chaîne de caractères (ou le vecteur de chaînes de caractères) sur lequel (lesquels) les recherches vont être effectuées ;
- un deuxième pour préciser le motif (_pattern_) à rechercher. C'est l'argument qui contient l'expression régulière

Lorsque l'expression est trouvée dans une chaîne de caractère, on dit qu'il y a _match_ (ou appariement). 

Le _package_ `{base}` offre de nombreuses fonctions pour effectuer des manipulations de chaînes de caractères à l'aide des expressions régulières. Elles souffrent toutefois quelques légers problèmes : il y a peu d'unité dans la syntaxe de ces fonctions et le nom de certaines d'entre-elles n'est pas immédiatement compréhensible. Aussi, nous ne nous attarderont pas à vous faire part du panorama des fonctions du _package_ `{base}` ici. Nous passerons davantage de temps sur les fonctions du _package_ `{stringr}`, qui s'appuient, pour la plupart d'entre-elles, sur des fonctions du _package_ {`base`}.

Le nom des fonction du _package_ {`stringr`} possède le préfixe `_`. Les deux arguments principaux indiquant le texte et le vecteur de chaînes de caractères et le motif sont appelés `string` et `pattern`. La syntaxe des fonctions de {`stringr`} est donc comme suit :
```{r donnees_manip_strings_regex_stringr_structure, eval=FALSE}
str_function(string, pattern)
```


### Détection d'un motif avec `str_detect()` {#manip_regex_stringr_detect}



Pour détecter la présence ou l'absence d'un motif dans une chaîne, on peut utiliser la fonction `str_detect()`.

```{r donnees_manip_strings_regex_stringr_detect, tidy.opts=list(width.cutoff=70)}
library(stringr)
textes <- c("J'ai pas le temps, j'ai matériellement pas le temps de faire ça",
           "Y a pas assez d'chaises ici ?",
           "J'ai")

str_detect(textes, "j'ai")
# En ignorant la casse
str_detect(string = textes,
           pattern = regex("j'ai", ignore_case = TRUE))
```


Si on désire rechercher la présence d'un motif ou d'un autre dans un texte, on peut effectuer à la main des appels multiples à une fonction de recherche, un appel par texte à chercher, ou on peut plus simplement utiliser l'opérateur logique "Ou", qui s'écrit `|` en `R`.
```{r donnees_manip_strings_regex_ou, tidy.opts=list(width.cutoff=70)}

textes  <- c("J’accepte votre bonjour, Ashley.",
            "Et je vous l’échange contre un coucou.", 
            "Coucou !")
motif <- "coucou|Ashley"
str_detect(string = textes, pattern = motif)

```


Le premier élément du vecteur `textes` contient le mot `"Ashley"` mais pas `"coucou"`. Il y a bien au moins une des deux sous-chaînes qui a été trouvée. Le troisième élément, en revanche, ne contient ni `"coucou"`, ni `"Ashley"` (il ne faut pas oublier que les fonctions traitant les expressions régulières sont par défaut sensibles à la casse en `R`).

Pour chercher si un motif est présent en début de texte, on fait débuter la sous-chaîne à _matcher_ par un accent circonflexe. Pour chercher si un motif est en fin de texte, on termine la sous-chaîne à _matcher_ par un symbole dollar.
```{r donnees_manip_strings_regex_debut, tidy.opts=list(width.cutoff=70)}

textes <- c("Mais je ne mange pas, voyons !",
          "Mais je ne mange pas", "voyons ! Mais")
str_detect(string = textes, pattern = "^Mais")
str_detect(string = textes, pattern = "je ne mange pas$")
```

## Les classes de caractères {#manip_regex_classes}

Les classes de caractères sont des listes de caractères appartenant à un ensemble, comme par exemple les caractètres alphabétiques, numériques, alphanumériques, etc. Il est possible de les construire soi-même, ou bien d'utiliser des classes prédéfinies. Elles sont écrites en les plaçant entre des crochets `[classe]`.

Par exemple, si on désire chercher s'il y a des occurrences du caractère `o` ou `i` entre les sous-chaînes `Cr` et `q`, on définit la classe de caractères `[oi]` :
```{r donnees_manip_strings_regex_criquette}
str_detect(string = c("Criquette", "Craquer", "Croquette"),
           pattern = "Cr[oi]q", )
```

On a cherché dans chaque élément de `string`, s'il y avait la chaîne `Croq` ou `Criq`.

La construction d'une classe de caractère comme `[oi]` ne représente peut-être pas un attrait énorme, mais il est possible d'en créer d'autres plus alléchantes. En effet, en utilisant le tiret (`-`), on peut définir une séquence de caractère. Ainsi, la classe de caractères `[A-Z]` permet de _matcher_ les lettres de l'ensemble `ABCDEFGHIJKLMNOPQRSTUVWXYZ`, tandis que `[0-9]` permet de `matcher` les caractères de l'ensemble `0123456789`.

```{r donnees_manip_strings_regex_classes}
# Recherche une voyelle minuscule
str_detect(c("_!", "ALLO", "Allo 9-1-1", "9-1-1"), "[aeiou]")

# Recherche une voyelle majuscule
str_detect(c("_!", "ALLO", "Allo 9-1-1", "9-1-1"), "[AEIOU]")

# Recherche un cacractère numérique
str_detect(c("_!", "Allo", "Allo 9-1-1", "9-1-1"), "[0-9]")

# Recherche un cacractère alphabétique ASCII majuscule
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "[A-Z]")

# Recherche un cacractère alphabétique ASCII minuscule
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "[a-z]")

# Recherche un cacractère alphabétique (majuscule ou minuscule)
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "[A-Za-z]")

# Recherche un cacractère alphanumérique
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "[A-Za-z0-9]")

```



Si l'utilisateur•trice désire rechercher un caractère qui n'appartient pas à une classe de caractères, il suffit de rajouter un accent circonflèxe (`^`) juste après le crochet ouvrant. Si on désire rechercher la présence de l'accent circonflèxe dans un texte, en utilisant une classe de caractère, il faut placer le symbole autre part que juste après le crochet. Pour chercher un crochet fermant (ouvrant) il faut le faire précéder des doubles barres obliques inverses. Enfin, pour chercher un tiret, il suffit de la placer en premier ou en dernier de la définition de la classe.
```{r donnees_manip_strings_regex_classes_negations}
# Y a-t-t-il autre chose que des chiffres ?
str_detect(c("_!", "Allo", "Allo 9-1-1", "911"), "[^0-9]")
# Recherche de l'accent circonflèxe ou d'un chiffre
str_detect(c("_!", "Allo", "Allo ^ accent", "Allo 9-1-1", "911"), "[0-9^]")
# Rechercher un crochet
str_detect(c("_!", "All[o", "All]o ^ accent", "Allo 9-1-1", "911"), "[\\[\\]]")
# Rechercher un tiret ou un i
str_detect(c("_!", "All[o", "All-] ^ accent", "Allo 9-1-1", "9i11"), "[-i]")
```

```{block2, type='remarque', echo=TRUE}
Il ne faut pas confondre l'accent circonflèxe inséré entre les crochets et celui placé au début d'une chaîne pour indiquer que le motif doit commencer par cette chaîne.

```

```{r donnees_manip_strings_regex_classes_negations_2}
# Le texte commence-t-il par autre chose qu'un chiffre ?
str_detect(c("_!", "Allo", "9-1-1", "911"), "^[^0-9]")
```

`R` propose la bibliothèque de classes appelée `POSIX`. Ces classes s'utilisent en faisant appel à leur nom, de la même manière que les classes définies par l'utilisateur•trice, ou les séquences : `[classe]`. Il faut toutefois noter que les noms des classes de caractères `POSIX` sont légèrement différentes en `R` que dans d'autres langages, comme `PHP` par exemple. En effet, il faut les entourer de crochets et de deux-points. Ainsi, la classe des alphanumériques sera accessible par son nom `[:alnum:]` et utilisée de la sorte : `[[:alnum:]]`. Le fichier d'aide des _regex_ de `R` met en garde l'utilisateur•trice  que ces classes de caractères prédéfinies peuvent varier selon les configurations des machines, notamment les configurations linguisitiques. Voici quelques exemples.

```{r}
# Recherche un cacractère numérique
str_detect(c("_!", "Allo", "Allo 9-1-1", "9-1-1"), "[[:digit:]]")

# Rechercher un caractère non-numérique
str_detect(c("_!", "Allo", "Allo 9-1-1", "911"), "[^[:digit:]]")

# Recherche un cacractère alphabétique majuscule
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "[[:upper:]]")

# Recherche un cacractère alphabétique minuscule
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "[[:lower:]]")

# Recherche un cacractère alphabétique (majuscule ou minuscule)
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "[[:alpha:]]")

# Recherche un cacractère alphanumérique
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "[[:alnum:]]")

# Recherche une espace ou une tabulation
str_detect(c("_!", "Allo\t", "Allo 9-1-1"), "[[:blank:]]")

# Recherche d'un caractère de ponctuation
# (! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~)
str_detect(c("_!", "Allo", "Allo 9-1-1", "9-1-1"), "[[:punct:]]")
```


`R` propose également quelques abréviations pour accéder à certaines classes. On y accède en écrivant une lettre minuscule précédée de deux barre obliques inversées. Si la lettre est en majuscule, il s'agit de la recherche de non appartenance à la classe. Par exemple, `\\d` recherche un caractère numérique (_digital_), et `\\D` recherche un caractère n'étant pas numérique. Voici quelques exemples.

```{r donnees_manip_strings_regex_classes_raccourcis}
# Recherche un cacractère numérique
str_detect(c("_!", "Allo", "Allo 9-1-1", "911"), "\\d")

# Recherche un caractère non-numérique
str_detect(c("_!", "Allo", "Allo 9-1-1", "911"), "\\D")

# Recherche un cacractère alphanumérique
# Attention à cette abréviation qui match le trait de soulignement...
str_detect(c("_!", "Allo", "allo", "ALLO", "9-1-1"), "\\w")
```


Le tableau ci-dessous donne un récapitulatif des classes de caractères prédéfinies.


| ASCII | POSIX | Raccourcis | Description |
| :-------: | :---------: | :---------: | :-------------- |
| `[[:lower:]]` | `[a-z]` | | Lettre minuscule |
| `[[:upper:]]` | `[A-Z]` | | Lettre majuscule |
| `[[:alpha:]]` | `[a-zA-Z]` | | Lettre minuscule et majuscule |
| `[[:digit:]]` | `[0-9]` | `\\d` | Chiffres de 0 à 9 |
| `[[:alnum:]]` | `[a-zA-Z0-9]` | | Caractère alphanumérique |
| `[[:blank:]]` | `[\t]` | | Espace et tabulation |
| `[[:cntrl:]]` |  | | Caractère de contrôle |
| `[[:punct:]]` | ``[]!\"#$\\%&\'\\(\\)*+,-\\./:;<=>\\?@^_`{|}~[]`` | | Ponctuation et symbole |
| `[[:space:]]` | `[ \t\r\n\v\f]` | `\\s` | Espace blanc ou séparateur de ligne ou de paragraphe |
| `[[:xdigit:]]` | `[A-Fa-f0-9]` | | Chiffre hexadécimal |
| `[[:print:]]` | `[A-Fa-f0-9]` | | Caractère visible et espace (tout sauf caractère de contrôle) |
| `[[:graph:]]` | `[\x20-\x7E]` | | Caractère graphique visible (tout sauf espace et caractère de contrôle) |
|  | `[A-Za-z0-9_]` | `\\w` | Lettre, chiffre et trait de soulignement |

## Les quantificateurs {#manip_regex_quantificateurs}



Afin de pouvoir chercher des motifs qui se répètent, dans un nombre défini _a priori_ ou non, on peut utiliser ce que l'on appelle des quantificateurs.

Les principaux quantificateurs sont les suivants :

- `?` :  le précédent item est factultatif, et sera donc _matché_ \(0\) ou \(1\) fois ;
- `*` : le précédent item sera _matché_ \(0\) fois ou plus ;
- `+` : le précédent item sera `matché` \(1\) fois ou plus ;
- `n` : le précédent item sera `matché` exactement n fois ;
- `n,` : le précédent item sera `matché` \(n\) fois ou plus ;
- `n,m` : le précédent item sera `matché` au mois \(n\) fois, mais pas plus de \(m\) fois.



Quelques exemple pour se fixer les idées.
```{r donnees_manip_strings_regex_classes_quantificateurs, tidy.opts=list(width.cutoff=70)}
# La chaîne "travaille " peut être présente 0 ou 1 fois
textes <- c("Lolo travaille au skateshop", "Lolo au skateshop")
str_detect(textes, "Lolo (travaille )?au skateshop")

# Cherche "ah Sonia", ou "ahah Sonia", ou "ahahah Sonia", etc.
textes <- c("ahahah Sonia", "ahah Sonia", "Sonia", "Amandine")
str_detect(textes, "(ah)* Sonia")

# On souhaite s'assurer qu'il y a au moins un "ah" suivi de " Stéphanie"
# Mais on peut aussi avoir "ahah Stéphanie" ou "ahahah Stéphanie"
textes <- c("Bonjour Stéphanie", "ah Stéphanie", "ahah Stéphanie")
str_detect(textes, "(ah)+")


textes <- c("a#maisoui#maisoui !", "a#maisoui !", "a#maisoui#maisoui#maisoui !",
           "a#maisoui#maisoui#maisoui#maisoui !")

# Y a-t-il une sous chaîne "a#maisoui#maisoui !" dans le texte ?
str_detect(textes, "a(#maisoui){2} !")

# Y a-t-il une sous chaîne "a#maisoui#maisoui !", ou
# "a#maisoui#maisoui#maisoui !", etc. dans le texte ?
str_detect(textes, "a(#maisoui){2,} !")

# La chaîne "skate" sera présente entre deux et trois fois
str_detect(textes, "a(#maisoui){2,3} !")

```

## Les métacaractères {#manip_regex_metacaracteres}


Les _regex_ possèdent quelques caractères spéciaux, qui ont un statut réservé, et qui sont appelés des _métacaractères_. L'accent circonflèxe en fait partie. En effet, l'expression régulière `^Bonjour` ne recherchera pas la chaîne `"^Bonjour"`, comme vu plus haut.

La liste des métacaractères est la suivante : ``. \| ( ) [ { $ * + ?``


En `R` pour pouvoir rechercher ces caractères dans des chaînes, il faut les échapper, à l'aide de deux barres obliques inversées `\\`.

```{r donnees_manip_strings_regex_metacaractere, tidy.opts=list(width.cutoff=70)}

textes <- c("Clément et Marianne vont chez Thibault.",
           "Clément (et Marianne) vont chez Thibault !")

# Recherche la présence de "et Marianne"
str_detect(textes, "(et Marianne)")
# Recherche la présence de "(et Marianne)"
str_detect(textes, "\\(et Marianne\\)")

# Le dernier caractère est-il n'importe quel caractère ?
str_detect(textes, ".$")

# Le texte se termine-t-il par un point ?
str_detect(textes, "\\.$")
```

## Quelques fonctions du _package_ {`stringr`} {#manip_regex_stringr}

Regardons à présent quelques fonctions de {`stringr`} qui permettent de manipuler des chaînes de caractères à l'aide d'expressions régulières.


### La fonction `str_detect()` {#manip_regex_stringr_extract}


Pour extraire une chaîne qui contient un motif, on peut utiliser la fonction `str_extract()`. Le résultat est un vecteur de caractères de la même longueur que celui fourni à l'argument `string`. Pour les éméments pour lesquels il n'y a pas eu de _match_, la valeur `NA` est retournée.

```{r donnees_manip_strings_regex_stringr_extract, tidy.opts=list(width.cutoff=70)}

adresses <- c("criquette.rockwell@gmail.com",
              "brett.montgomery@yahoo.fr",
              "madge_laposte.net")
motif <- "^[[:alnum:].-]+@[[:alnum:].-]+$"

# Extraire les adresses e-mail valides
str_extract(string = adresses, pattern = motif)

```

### La fonction `str_extract_all()` {#manip_regex_stringr_extract_all}

Alors que la fonction `str_extract()` ne permet d'extraire que la première chaîne qui _match_ le motif, `str_extract_all()` retourne toutes les occurrences trouvées. Le résultat est une liste de la même longueur que celle du vecteur fourni à l'argument `string`. Les éléments de cette liste sont des vecteurs de la taille du nombre d'occurrences du motif trouvé. En cas d'absence de `match`, la valeur `character(0)` est retournée.

```{r donnees_manip_strings_regex_stringr_extract_all}
tweets <- c("@kevin_ushey yes sure, it was just an example",
            "@hspter @kwbroman next is to get into #github streak art.")
motif <- c("@[[:alpha:]]{1,}")

# Extraire la première mention trouvée
str_extract(tweets, motif)

# Extraire toutes les mentions trouvées
str_extract_all(tweets, motif)
```


### La fonction `str_match()` {#manip_regex_stringr_match}


La fonction `str_match()` extrait le premier *groupe* trouvé dans une chaîne. Il est donc nécessaire que l'argument `pattern` contienne un ou des groupes (définis par les parenthèses `()`). Le résultat est une matrice dont la première colonne contient le `match` complet, les suivantes sont les _matches_ pour chaque groupe.

```{r donnees_manip_strings_regex_stringr_match, tidy.opts=list(width.cutoff=70)}
telephones <- c("02 23 23 35 45", "02-23-23-35-45", "Madrid",
                "02.23.23.35.45", "0223233545", "Milan",
                "02 23 23 35 45  ", " 02 23 23 35 45",
                "Maison : 02 23 23 35 45")

motif_tel <- str_c(str_dup("([0-9]{2})[- \\.]", 4),  "([0-9]{2})")

# Extrait les numéros de téléphone
str_extract(telephones, motif_tel)
str_match(telephones, motif_tel)
```

### La fonction `str_match_all()` {#manip_regex_stringr_match_all}

Si la chaîne de caractère contient plusieurs _matches_, la fonction `str_match()` ne retournera que le premier. Pour les avoir tous, il faut utiliser la fonction `str_match_all()`. Le résultat est une liste de la même longueur que le vecteur fourni à `string`. Chaque élément de la liste, lorsqu'il y a eu _match_ est une matrice comme celle retournée par `str_match()`. S'il n'y a pas eu _match_, l'élément de la liste retournée est `character(0)`.

```{r donnees_manip_strings_regex_stringr_match_all}

telephones <- c("02 23 23 35 45", "02-23-23-35-45 / 02 23 23 35 35",
                "Madrid", "Maison : 02.23.23.35.45, Travail : 02 23 23 35 35")


motif_tel <- str_c(str_dup("([0-9]{2})[- \\.]", 4),  "([0-9]{2})")

# Extrait les numéros de téléphone
str_extract_all(telephones, motif_tel)
str_match_all(telephones, motif_tel)[[3]]
```

### La fonction `str_locate()` {#manip_regex_stringr_locate}

Pour localiser la position de la première occurrence d'un motif dans une chaîne, on peut utiliser la fonction `str_locate()`. Le résultat est une matrice d'entiers dont la première colonne indique la position de départ du _match_ et la seconde indique la position de fin du _match_. En cas d'absence de _match_, les deux valeurs valent `NA`.

```{r donnees_manip_strings_regex_stringr_locate}
fruits <- c("pomme", "banane", "poire", "ananas")
str_locate(fruits, "a")

# On peut définir le motif pour chaque élément du texte
str_locate(fruits, c("p", "o", "p", "a"))
```

### La fonction `str_locate_all()` {#manip_regex_stringr_locate_all}

Si on désire obtenir la position de toutes les occurrences d'un motif dans une chaîne, on peut utiliser la fonction `str_locate_all()`. Le résultat est une liste de la même longueur que le vecteur fourni à l'argument `string`. Chaque élément de la liste contient une matrice d'entiers dont la première colonne contient les positions de départ des _matches_ et la seconde les positions de fin. Chaque ligne de la matrice correspond à un _match_. En cas d'absence de _match_ dans la chaîne, la matrice retournée est `matrix(0, nrow = 0, ncol = 2)`.

```{r donnees_manip_strings_regex_stringr_locate_all}
fruits <- c("pomme", "banane", "poire", "ananas")
str_locate_all(fruits, "a")

# On peut définir le motif pour chaque élément du texte
str_locate_all(fruits, c("p", "o", "p", "a"))
```

### La fonction `str_replace()` {#manip_regex_stringr_replace}

La fonction `str_replace()` remplace la première occurrence d'un motif _matché_ par la chaîne indiquée à l'argument `replacement`.

```{r donnees_manip_strings_regex_stringr_replace}
telephones <- c("02/23/23/35/45", "02.23.23.35.45", "02 23 23 35 45")

# Remplacer la première occurrence du motif trouvée par un tiret
str_replace(telephones, "[/ \\.]", "-")
```


Lorsqu'il y a des groupes (définis par des parenthèses), on peut faire référence aux groupes _matchés_ à l'aide de deux barres obliques inversées suivies du rang du groupe. Ainsi `\\1` fera référence au premier groupe matché.

```{r donnees_manip_strings_regex_stringr_replace_2}
fruits <- c("01. pomme", "02. pêches", "Maison", "03. bananes")
str_replace(fruits, "([0-9]{2}\\. )([a-z])", "Debut\\1Bonjour\\2Fin")
```

### La fonction `str_replace_all()` {#manip_regex_stringr_replace_all}

La fonction `str_replace_all()` permet de remplacer toutes les occurrences du motif trouvé par une chaîne de remplacement.

```{r donnees_manip_strings_regex_stringr_replace_all}
telephones <- c("02/23/23/35/45", "02.23.23.35.45", "02 23 23 35 45")

# Remplacer toute les occurrences du motif trouvées par un tiret
str_replace_all(telephones, "[/ \\.]", "-")
```

### La fonction `str_split()` {#manip_regex_stringr_split}


La fonction `str_split()` permet de séparer une chaîne de caractères en plusieurs morceaux, suivant un motif donné. On peut préciser le nombre maximum de morceaux à retourner à l'aide de l'argument `n`. Cet argument vaut `Inf` par défaut, et retourne donc tous les morceaux qu"il est possible de trouver. Si la valeur donnée à `n` est plus petite que lon nombre de morceaux qu'il est possible de faire, le dernier élément du vecteur de caractères retourné contient encore des occurrences du motif. Si par contre la valeur fournie à `n` est plus grande, il n'y a pas de rajouts effectués par `R`.

Le résultat est une liste de la même longueur que le vecteur passé à l'argument `string`. Chaque élément de la liste contient les morceaux. Si l'argument `pattern` vaut `NA`, le résultat est le texte original, si `pattern` vaut `""`, le texte original est séparé par caractères.

```{r}
textes <- c("manger des chips", "José",
            "Considère qu'on n'est plus amis, Abitbol !")

str_split(textes, " ")

# Avec n plus grand
str_split(textes, " ", n = 4)
```

### La fonction `str_string_fixed()` {#manip_regex_stringr_split_fixed}

Pour briser une chaîne de caractères en un nombre `n` de morceaux fixe en fonction d'un motif `pattern`, on peut utiliser la fonction `str_string_fixed()`. Le résultat est une matrice à `n`, colonnes. Chaque colonne de la matrice retournée correspond à un morceau. Si `n` est supérieur au nombre de morceaux qu'il est possible de créer, les colonnes de la matrice retournée sont complétées par la chaine vide `""`. En revanche, si `n` est inférieur au nombre de morceaux que l'on peut créer, la dernière colonne contiendra le reste de la chaîne n'ayant pas encore été découpée.

```{r donnees_manip_strings_regex_stringr_split_fixed}
textes <- c("manger des chips", "José",
            "Considère qu'on n'est plus amis, Abitbol !")

# Avec 4 morceaux
str_split_fixed(textes, " ", n = 4)
```


## Quelques fonctions du _package_ {`base`} {#manip_regex_base}


À titre informatif, le tableau ci-dessous présente les fonctions du _package_ `{base}` les plus importantes lorsque l'on manipule des expressions régulières. Les deux arguments principaux de texte et de motif sont nommés `text` et `pattern`, respectivement. Lorsqu'elle existe, la fonction équivalente dans {`stringr`} est donnée.

| Fonction dans {`string`} | Fonction dans {`base`} | Description |
| :------------ | :------------ | :------------ |
| `str_which()` | `grep()` |  Retourne les indices des éléments du vecteur de texte pour lequel il y a un _match_ |
| `str_detect()` | `grepl()` | Retourne un vecteur de valeurs logiques de la même longueur que le vecteur `text`, qui indique, pour chaque élément, s'il y a eu _match_ |
| Proche de `str_locate()` | `regexpr()` | Retourne un vecteur d'entiers de la même taille que `text` donnant la position du premier _match_ (ou `-1` s'il n'y a pas eu de _match_), avec l'attribut `match.length`, un vecteur d'entiers donnant la longueur du text _match_ (ou `-1` si pas de _match_). |
| Proche de `str_locate_all` | `gregexpr()` | Même chose que `regexpr()`, mais le résultat est sous forme de liste, dont chaque élément correspond à la recherche du motif dans l'élément de `text` correspondant. Par ailleurs, les positions de départ de chaque _match_ sont données, et non pas seulement le premier rencontré. Il en est de même pour l'attribut `match.length`. |
| |  `regexec()` | Retourne une liste de la même taille que `text` dont chaque élément est soit `-1` s'il n'y a pas eu de `match`, ou une séquence d'entiers avec les positions de début de `match` de toutes les sous-chaînes correspondant aux sous-expressions parenthésées de l'argument `pattern`, avec l'attribut `match.length`, qui est un vecteur donnant la longueu de chaque _match_, ou `-1` s'il n'y en a pas eu. |



Pour se fixer les idées, voici quelques exemples. La fonction `str_which()`, qui permet d'indiquer les positions des éléments du vecteur donné en argument à `string` dans lesquels le motif est repéré :

```{r donnees_manip_strings_regex_fonctions, tidy.opts=list(width.cutoff=70)}

textes <- c("Je m’évanouis avant d’avoir pu vous révéler",
          "le nom du kidnappeur", "et/ou de la kidnappeuse",
          "du petit Doug Doug !")
motif <- "ou"

str_which(string = textes, pattern = motif)
```


La fonction `str_detect()` qui retourne un vecteur de logique indiquant pour chaque élément du vecteur donné en argument à `string` si le motif a été trouvé :

```{r}
str_detect(string = textes, pattern = motif)
```

La fonction `regexpr()` (dans {`base`}, donne un résultat relativement proche de celui de `str_locate()` de {`stringr`}) :

```{r}
regexpr(pattern = textes, text = motif)
str_locate(string = textes, pattern = motif)
```

La fonction `gregexpr()`

```{r}
gregexpr(pattern = motif, text = textes)
str_locate_all(string = textes, pattern = motif)
```

Et enfin, la fonction `regexec()`

```{r}
regexec(pattern = motif, text = textes)
```




# Pour aller plus loin


Pour aller plus loin dans la pratique de R, voici quelques recommandations. Cette partie est très succincte, et sera (je l'espère) complétée à l'avenir. Il s'agit surtout pour moi d'un pense-bête pour les futures versions de ces notes de cours. Si vous pensez qu'il manque une partie crutiale pour la pratique de R (en se limitant à la manipulation de données, je ne tiens pas à faire figurer de méthodes statistiques avancées dans ces notes), n'hésitez pas à m'envoyer un e-mail pour m'en faire part.


## Travailler par projets, avec RStudio

Pour travailler sereinement avec R, la pratique qui me convient le mieux est de créer des fichiers de projets sur RStudio. Ce faisant, il est plus facile de partager ses codes au sein d'un groupe. Il n'est plus nécessaire de soucier d'éventuels changements de liens pour charger des documents dans R. Pas de problèmes non plus pour sauvegarder au bon endroit des résultats issus d'analyses réalisées avec R.

Par ailleurs, il est possible de lancer plusieurs projets sur la même machine (pratique quand on doit travailler avec plusieurs groupes sur des sujets différents).

Pour plus de détails : https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects

## R Markdown

Ces notes de cours ont été rédigées directement dans RStudio. Le langage d'écriture est le Rmarkdown. Pour réaliser des rapports, ce langage est très utile. Il permet de rédiger le contenu du rapport en alternant du texte et des résutats d'analyses menées sous R, le tout dans le même environnement.

Avec R markdown, il est possible d'exécuter des codes dans de nombreux langages (comme du Python, du D3, du SQL, etc.). Il est même possible d'écrire des formules en LaTeX (sans souffrir de la syntaxe horrible propre à ce langage).

Pour plus de détails : https://rmarkdown.rstudio.com/

## Modification de plusieurs colonnes

Il existe dans l'environnement `tidyverse` une fonction qui permet de modifier plusieurs colonne d'un coup : `across()`. L'utilisation de cette fonction devrait faire l'objet d'une partie dans cette ouvrage.

https://dplyr.tidyverse.org/reference/across.html


# Pense-bête

Cette dernière partie propose des codes R que j'utilise régulièrement mais dont j'oublie systématiquement les détails. Il s'agit de fait d'une partie très destructurée de ces notes et se destinent plutôt à mon usage personnel.


## Installer un _package_ depuis sa source

Parfois, un _package_ n'est plus disponible sur CRAN ou GitHub, mais il est toutefois possible de l'installer directement depuis sa source. Dans ce cas, je télécharge la source et utilise le code suivant :

```{r pense_bete_install_from_source, eval=FALSE}
install.packages("chemin_vers_source", repos = NULL, type = "source")
```





# References {-}